/** Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT. */
package com.algolia.client.api

import com.algolia.client.configuration.*
import com.algolia.client.exception.*
import com.algolia.client.extensions.internal.*
import com.algolia.client.model.search.*
import com.algolia.client.transport.*
import com.algolia.client.transport.internal.*
import kotlinx.serialization.json.*

public class SearchClient(
  override val appId: String,
  override val apiKey: String,
  override val options: ClientOptions = ClientOptions(),
) : ApiClient {

  init {
    require(appId.isNotBlank()) { "`appId` is missing." }
    require(apiKey.isNotBlank()) { "`apiKey` is missing." }
  }

  override val requester: Requester = requesterOf(clientName = "Search", appId = appId, apiKey = apiKey, options = options) {
    listOf(
      Host("$appId-dsn.algolia.net", CallType.Read),
      Host("$appId.algolia.net", CallType.Write),
    ) + mutableListOf(
      Host("$appId-1.algolianet.com"),
      Host("$appId-2.algolianet.com"),
      Host("$appId-3.algolianet.com"),
    ).apply { shuffle() }
  }

  /**
   * Add API key.
   * Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string.
   * @param apiKey
   * @param requestOptions additional request configuration.
   */
  public suspend fun addApiKey(apiKey: ApiKey, requestOptions: RequestOptions? = null): AddApiKeyResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "keys"),
      body = apiKey,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Add or update a record (using objectID).
   * If you use an existing `objectID`, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
   * @param indexName Index on which to perform the request.
   * @param objectID Unique record (object) identifier.
   * @param body Algolia record.
   * @param requestOptions additional request configuration.
   */
  public suspend fun addOrUpdateObject(indexName: String, objectID: String, body: JsonObject, requestOptions: RequestOptions? = null): UpdatedAtWithObjectIdResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `addOrUpdateObject`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `addOrUpdateObject`." }
    require(body.isNotEmpty()) { "Parameter `body` is required when calling `addOrUpdateObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "indexes", "$indexName", "$objectID"),
      body = body,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Add a source.
   * Add a source to the list of allowed sources.
   * @param source Source to add.
   * @param requestOptions additional request configuration.
   */
  public suspend fun appendSource(source: Source, requestOptions: RequestOptions? = null): CreatedAtResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "security", "sources", "append"),
      body = source,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Assign or move a user ID.
   * Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID.
   * @param xAlgoliaUserID userID to assign.
   * @param assignUserIdParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun assignUserId(xAlgoliaUserID: String, assignUserIdParams: AssignUserIdParams, requestOptions: RequestOptions? = null): CreatedAtResponse {
    require(xAlgoliaUserID.isNotBlank()) { "Parameter `xAlgoliaUserID` is required when calling `assignUserId`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "clusters", "mapping"),
      headers = buildMap {
        put("X-Algolia-User-ID", xAlgoliaUserID)
      },
      body = assignUserIdParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Batch write operations on one index.
   * To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported `action`s are equivalent to the individual operations of the same name.
   * @param indexName Index on which to perform the request.
   * @param batchWriteParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun batch(indexName: String, batchWriteParams: BatchWriteParams, requestOptions: RequestOptions? = null): BatchResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `batch`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "batch"),
      body = batchWriteParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Batch assign userIDs.
   * Assign multiple user IDs to a cluster. **You can't _move_ users with this operation.**.
   * @param xAlgoliaUserID userID to assign.
   * @param batchAssignUserIdsParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun batchAssignUserIds(xAlgoliaUserID: String, batchAssignUserIdsParams: BatchAssignUserIdsParams, requestOptions: RequestOptions? = null): CreatedAtResponse {
    require(xAlgoliaUserID.isNotBlank()) { "Parameter `xAlgoliaUserID` is required when calling `batchAssignUserIds`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "clusters", "mapping", "batch"),
      headers = buildMap {
        put("X-Algolia-User-ID", xAlgoliaUserID)
      },
      body = batchAssignUserIdsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Batch dictionary entries.
   * Add or remove a batch of dictionary entries.
   * @param dictionaryName Dictionary to search in.
   * @param batchDictionaryEntriesParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun batchDictionaryEntries(dictionaryName: DictionaryType, batchDictionaryEntriesParams: BatchDictionaryEntriesParams, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "dictionaries", "$dictionaryName", "batch"),
      body = batchDictionaryEntriesParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get all records from an index.
   * Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn't support: - The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.
   * @param indexName Index on which to perform the request.
   * @param browseParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun browse(indexName: String, browseParams: BrowseParams? = null, requestOptions: RequestOptions? = null): BrowseResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `browse`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "browse"),
      body = browseParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete all synonyms.
   * Delete all synonyms in the index.
   * @param indexName Index on which to perform the request.
   * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices.
   * @param requestOptions additional request configuration.
   */
  public suspend fun clearAllSynonyms(indexName: String, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `clearAllSynonyms`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "synonyms", "clear"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete all records from an index.
   * Delete the records but leave settings and index-specific API keys untouched.
   * @param indexName Index on which to perform the request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun clearObjects(indexName: String, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `clearObjects`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "clear"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete all rules.
   * Delete all rules in the index.
   * @param indexName Index on which to perform the request.
   * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices.
   * @param requestOptions additional request configuration.
   */
  public suspend fun clearRules(indexName: String, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `clearRules`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "rules", "clear"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Send requests to the Algolia REST API.
   * This method allow you to send requests to the Algolia REST API.
   * @param path Path of the endpoint, anything after \"/1\" must be specified.
   * @param parameters Query parameters to apply to the current query.
   * @param requestOptions additional request configuration.
   */
  public suspend fun del(path: String, parameters: Map<kotlin.String, Any>? = null, requestOptions: RequestOptions? = null): JsonObject {
    require(path.isNotBlank()) { "Parameter `path` is required when calling `del`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = "/1{path}".replace("{path}", path),
      query = buildMap {
        parameters?.let { putAll(it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete API key.
   * Delete an existing API key. The request must be authenticated with the admin API key.
   * @param key API key.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteApiKey(key: String, requestOptions: RequestOptions? = null): DeleteApiKeyResponse {
    require(key.isNotBlank()) { "Parameter `key` is required when calling `deleteApiKey`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "keys", "$key"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete all records matching a query.
   * This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn't accept empty filters or queries.
   * @param indexName Index on which to perform the request.
   * @param deleteByParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteBy(indexName: String, deleteByParams: DeleteByParams, requestOptions: RequestOptions? = null): DeletedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteBy`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "deleteByQuery"),
      body = deleteByParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete index.
   * Delete an existing index.
   * @param indexName Index on which to perform the request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteIndex(indexName: String, requestOptions: RequestOptions? = null): DeletedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteIndex`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "indexes", "$indexName"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete a record.
   * To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy) instead.
   * @param indexName Index on which to perform the request.
   * @param objectID Unique record (object) identifier.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteObject(indexName: String, objectID: String, requestOptions: RequestOptions? = null): DeletedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteObject`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `deleteObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "indexes", "$indexName", "$objectID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete a rule.
   * Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
   * @param indexName Index on which to perform the request.
   * @param objectID Unique identifier of a rule object.
   * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteRule(indexName: String, objectID: String, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteRule`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `deleteRule`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "indexes", "$indexName", "rules", "$objectID"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Remove a source.
   * Remove a source from the list of allowed sources.
   * @param source IP address range of the source.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteSource(source: String, requestOptions: RequestOptions? = null): DeleteSourceResponse {
    require(source.isNotBlank()) { "Parameter `source` is required when calling `deleteSource`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "security", "sources", "$source"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete a synonym.
   * Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
   * @param indexName Index on which to perform the request.
   * @param objectID Unique identifier of a synonym object.
   * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteSynonym(indexName: String, objectID: String, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): DeletedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteSynonym`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `deleteSynonym`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "indexes", "$indexName", "synonyms", "$objectID"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Send requests to the Algolia REST API.
   * This method allow you to send requests to the Algolia REST API.
   * @param path Path of the endpoint, anything after \"/1\" must be specified.
   * @param parameters Query parameters to apply to the current query.
   * @param requestOptions additional request configuration.
   */
  public suspend fun get(path: String, parameters: Map<kotlin.String, Any>? = null, requestOptions: RequestOptions? = null): JsonObject {
    require(path.isNotBlank()) { "Parameter `path` is required when calling `get`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = "/1{path}".replace("{path}", path),
      query = buildMap {
        parameters?.let { putAll(it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get API key permissions.
   * Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key.
   * @param key API key.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getApiKey(key: String, requestOptions: RequestOptions? = null): GetApiKeyResponse {
    require(key.isNotBlank()) { "Parameter `key` is required when calling `getApiKey`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "keys", "$key"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List available languages.
   * Lists Algolia's [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language's [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getDictionaryLanguages(requestOptions: RequestOptions? = null): Map<kotlin.String, Languages> {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "dictionaries", "*", "languages"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get stop word settings.
   * Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
   * @param requestOptions additional request configuration.
   */
  public suspend fun getDictionarySettings(requestOptions: RequestOptions? = null): GetDictionarySettingsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "dictionaries", "*", "settings"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Return the latest log entries.
   * The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There's also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself. > **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN's endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).
   * @param offset First log entry to retrieve. Sorted by decreasing date with 0 being the most recent. (default to 0)
   * @param length Maximum number of entries to retrieve. (default to 10)
   * @param indexName Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
   * @param type Type of log entries to retrieve. When omitted, all log entries are retrieved. (default to all)
   * @param requestOptions additional request configuration.
   */
  public suspend fun getLogs(offset: Int? = null, length: Int? = null, indexName: String? = null, type: LogType? = null, requestOptions: RequestOptions? = null): GetLogsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "logs"),
      query = buildMap {
        offset?.let { put("offset", it) }
        length?.let { put("length", it) }
        indexName?.let { put("indexName", it) }
        type?.let { put("type", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get a record.
   * To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).
   * @param indexName Index on which to perform the request.
   * @param objectID Unique record (object) identifier.
   * @param attributesToRetrieve Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified. [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won't be retrieved unless the request is authenticated with the admin API key.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getObject(indexName: String, objectID: String, attributesToRetrieve: List<String>? = null, requestOptions: RequestOptions? = null): Map<kotlin.String, String> {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getObject`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `getObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "$objectID"),
      query = buildMap {
        attributesToRetrieve?.let { put("attributesToRetrieve", it.joinToString(",")) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get multiple records.
   * Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.
   * @param getObjectsParams Request object.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getObjects(getObjectsParams: GetObjectsParams, requestOptions: RequestOptions? = null): GetObjectsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "*", "objects"),
      isRead = true,
      body = getObjectsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get a rule.
   * Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
   * @param indexName Index on which to perform the request.
   * @param objectID Unique identifier of a rule object.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getRule(indexName: String, objectID: String, requestOptions: RequestOptions? = null): Rule {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getRule`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `getRule`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "rules", "$objectID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get index settings.
   * Return an object containing an index's [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
   * @param indexName Index on which to perform the request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getSettings(indexName: String, requestOptions: RequestOptions? = null): IndexSettings {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getSettings`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "settings"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get all allowed IP addresses.
   * Get all allowed sources (IP addresses).
   * @param requestOptions additional request configuration.
   */
  public suspend fun getSources(requestOptions: RequestOptions? = null): List<Source> {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "security", "sources"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get a synonym object.
   * Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
   * @param indexName Index on which to perform the request.
   * @param objectID Unique identifier of a synonym object.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getSynonym(indexName: String, objectID: String, requestOptions: RequestOptions? = null): SynonymHit {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getSynonym`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `getSynonym`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "synonyms", "$objectID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Check a task's status.
   * Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the status of that task.
   * @param indexName Index on which to perform the request.
   * @param taskID Unique task identifier.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getTask(indexName: String, taskID: Long, requestOptions: RequestOptions? = null): GetTaskResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getTask`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "task", "$taskID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get top userID.
   * Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getTopUserIds(requestOptions: RequestOptions? = null): GetTopUserIdsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters", "mapping", "top"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get userID.
   * Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
   * @param userID userID to assign.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getUserId(userID: String, requestOptions: RequestOptions? = null): UserId {
    require(userID.isNotBlank()) { "Parameter `userID` is required when calling `getUserId`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters", "mapping", "$userID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get migration and user mapping status.
   * To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
   * @param getClusters Indicates whether to include the cluster's pending mapping state in the response.
   * @param requestOptions additional request configuration.
   */
  public suspend fun hasPendingMappings(getClusters: Boolean? = null, requestOptions: RequestOptions? = null): HasPendingMappingsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters", "mapping", "pending"),
      query = buildMap {
        getClusters?.let { put("getClusters", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List API keys.
   * List all API keys associated with your Algolia application, including their permissions and restrictions.
   * @param requestOptions additional request configuration.
   */
  public suspend fun listApiKeys(requestOptions: RequestOptions? = null): ListApiKeysResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "keys"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List clusters.
   * List the available clusters in a multi-cluster setup.
   * @param requestOptions additional request configuration.
   */
  public suspend fun listClusters(requestOptions: RequestOptions? = null): ListClustersResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List indices.
   * List indices in an Algolia application.
   * @param page Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
   * @param hitsPerPage Maximum number of hits per page. (default to 100)
   * @param requestOptions additional request configuration.
   */
  public suspend fun listIndices(page: Int? = null, hitsPerPage: Int? = null, requestOptions: RequestOptions? = null): ListIndicesResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes"),
      query = buildMap {
        page?.let { put("page", it) }
        hitsPerPage?.let { put("hitsPerPage", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List userIDs.
   * List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
   * @param page Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
   * @param hitsPerPage Maximum number of hits per page. (default to 100)
   * @param requestOptions additional request configuration.
   */
  public suspend fun listUserIds(page: Int? = null, hitsPerPage: Int? = null, requestOptions: RequestOptions? = null): ListUserIdsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters", "mapping"),
      query = buildMap {
        page?.let { put("page", it) }
        hitsPerPage?.let { put("hitsPerPage", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Batch write operations on multiple indices.
   * To reduce the time spent on network round trips, you can perform several write actions in a single request. It's a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name.
   * @param batchParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun multipleBatch(batchParams: BatchParams, requestOptions: RequestOptions? = null): MultipleBatchResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "*", "batch"),
      body = batchParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Copy, move, or rename an index.
   * This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms, and rules to a `destination` index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn't exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  > **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
   * @param indexName Index on which to perform the request.
   * @param operationIndexParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun operationIndex(indexName: String, operationIndexParams: OperationIndexParams, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `operationIndex`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "operation"),
      body = operationIndexParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Update record attributes.
   * Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.
   * @param indexName Index on which to perform the request.
   * @param objectID Unique record (object) identifier.
   * @param attributesToUpdate Object with attributes to update.
   * @param createIfNotExists Indicates whether to create a new record if it doesn't exist yet.  (default to true)
   * @param requestOptions additional request configuration.
   */
  public suspend fun partialUpdateObject(indexName: String, objectID: String, attributesToUpdate: Map<kotlin.String, AttributeToUpdate>, createIfNotExists: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtWithObjectIdResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `partialUpdateObject`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `partialUpdateObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "$objectID", "partial"),
      query = buildMap {
        createIfNotExists?.let { put("createIfNotExists", it) }
      },
      body = attributesToUpdate,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Send requests to the Algolia REST API.
   * This method allow you to send requests to the Algolia REST API.
   * @param path Path of the endpoint, anything after \"/1\" must be specified.
   * @param parameters Query parameters to apply to the current query.
   * @param body Parameters to send with the custom request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun post(path: String, parameters: Map<kotlin.String, Any>? = null, body: JsonObject? = null, requestOptions: RequestOptions? = null): JsonObject {
    require(path.isNotBlank()) { "Parameter `path` is required when calling `post`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = "/1{path}".replace("{path}", path),
      query = buildMap {
        parameters?.let { putAll(it) }
      },
      body = body,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Send requests to the Algolia REST API.
   * This method allow you to send requests to the Algolia REST API.
   * @param path Path of the endpoint, anything after \"/1\" must be specified.
   * @param parameters Query parameters to apply to the current query.
   * @param body Parameters to send with the custom request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun put(path: String, parameters: Map<kotlin.String, Any>? = null, body: JsonObject? = null, requestOptions: RequestOptions? = null): JsonObject {
    require(path.isNotBlank()) { "Parameter `path` is required when calling `put`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = "/1{path}".replace("{path}", path),
      query = buildMap {
        parameters?.let { putAll(it) }
      },
      body = body,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Remove userID.
   * Remove a userID and its associated data from the multi-clusters.
   * @param userID userID to assign.
   * @param requestOptions additional request configuration.
   */
  public suspend fun removeUserId(userID: String, requestOptions: RequestOptions? = null): RemoveUserIdResponse {
    require(userID.isNotBlank()) { "Parameter `userID` is required when calling `removeUserId`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "clusters", "mapping", "$userID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Replace all sources.
   * Replace all allowed sources.
   * @param source Allowed sources.
   * @param requestOptions additional request configuration.
   */
  public suspend fun replaceSources(source: List<Source>, requestOptions: RequestOptions? = null): ReplaceSourceResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "security", "sources"),
      body = source,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Restore API key.
   * Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key.
   * @param key API key.
   * @param requestOptions additional request configuration.
   */
  public suspend fun restoreApiKey(key: String, requestOptions: RequestOptions? = null): AddApiKeyResponse {
    require(key.isNotBlank()) { "Parameter `key` is required when calling `restoreApiKey`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "keys", "$key", "restore"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Add or update a record.
   * Add a record (object) to an index or replace it. If the record doesn't contain an `objectID`, Algolia automatically adds it. If you use an existing `objectID`, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
   * @param indexName Index on which to perform the request.
   * @param body The Algolia record.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveObject(indexName: String, body: JsonObject, requestOptions: RequestOptions? = null): SaveObjectResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveObject`." }
    require(body.isNotEmpty()) { "Parameter `body` is required when calling `saveObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName"),
      body = body,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Create or update a rule.
   * To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).
   * @param indexName Index on which to perform the request.
   * @param objectID Unique identifier of a rule object.
   * @param rule
   * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveRule(indexName: String, objectID: String, rule: Rule, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedRuleResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveRule`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `saveRule`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "indexes", "$indexName", "rules", "$objectID"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
      body = rule,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Save a batch of rules.
   * Create or update multiple rules.
   * @param indexName Index on which to perform the request.
   * @param rules
   * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices.
   * @param clearExistingRules Indicates whether existing rules should be deleted before adding this batch.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveRules(indexName: String, rules: List<Rule>, forwardToReplicas: Boolean? = null, clearExistingRules: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveRules`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "rules", "batch"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
        clearExistingRules?.let { put("clearExistingRules", it) }
      },
      body = rules,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Save a synonym.
   * Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym `objectID` doesn't exist, Algolia adds a new one. If you use an existing synonym `objectID`, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).
   * @param indexName Index on which to perform the request.
   * @param objectID Unique identifier of a synonym object.
   * @param synonymHit
   * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveSynonym(indexName: String, objectID: String, synonymHit: SynonymHit, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): SaveSynonymResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveSynonym`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `saveSynonym`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "indexes", "$indexName", "synonyms", "$objectID"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
      body = synonymHit,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Save a batch of synonyms.
   * Create or update multiple synonyms.
   * @param indexName Index on which to perform the request.
   * @param synonymHit
   * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices.
   * @param replaceExistingSynonyms Indicates whether to replace all synonyms in the index with the ones sent with this request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveSynonyms(indexName: String, synonymHit: List<SynonymHit>, forwardToReplicas: Boolean? = null, replaceExistingSynonyms: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveSynonyms`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "synonyms", "batch"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
        replaceExistingSynonyms?.let { put("replaceExistingSynonyms", it) }
      },
      body = synonymHit,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search multiple indices.
   * Send multiple search queries to one or more indices.
   * @param searchMethodParams Query requests and strategies. Results will be received in the same order as the queries.
   * @param requestOptions additional request configuration.
   */
  public suspend fun search(searchMethodParams: SearchMethodParams, requestOptions: RequestOptions? = null): SearchResponses {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "*", "queries"),
      isRead = true,
      body = searchMethodParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search dictionary entries.
   * Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.
   * @param dictionaryName Dictionary to search in.
   * @param searchDictionaryEntriesParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchDictionaryEntries(dictionaryName: DictionaryType, searchDictionaryEntriesParams: SearchDictionaryEntriesParams, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "dictionaries", "$dictionaryName", "search"),
      isRead = true,
      body = searchDictionaryEntriesParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search for facet values.
   * [Search for a facet's values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. > **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.
   * @param indexName Index on which to perform the request.
   * @param facetName Facet name.
   * @param searchForFacetValuesRequest
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchForFacetValues(indexName: String, facetName: String, searchForFacetValuesRequest: SearchForFacetValuesRequest? = null, requestOptions: RequestOptions? = null): SearchForFacetValuesResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `searchForFacetValues`." }
    require(facetName.isNotBlank()) { "Parameter `facetName` is required when calling `searchForFacetValues`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "facets", "$facetName", "query"),
      isRead = true,
      body = searchForFacetValuesRequest,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search for rules.
   * Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.
   * @param indexName Index on which to perform the request.
   * @param searchRulesParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchRules(indexName: String, searchRulesParams: SearchRulesParams? = null, requestOptions: RequestOptions? = null): SearchRulesResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `searchRules`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "rules", "search"),
      isRead = true,
      body = searchRulesParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search an index.
   * Return records that match the query.
   * @param indexName Index on which to perform the request.
   * @param searchParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchSingleIndex(indexName: String, searchParams: SearchParams? = null, requestOptions: RequestOptions? = null): SearchResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `searchSingleIndex`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "query"),
      isRead = true,
      body = searchParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search for synonyms.
   * Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.
   * @param indexName Index on which to perform the request.
   * @param type Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms).
   * @param page Returns the requested page number (the first page is 0). Page size is set by `hitsPerPage`. When null, there's no pagination.  (default to 0)
   * @param hitsPerPage Maximum number of hits per page. (default to 100)
   * @param searchSynonymsParams Body of the `searchSynonyms` operation.
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchSynonyms(indexName: String, type: SynonymType? = null, page: Int? = null, hitsPerPage: Int? = null, searchSynonymsParams: SearchSynonymsParams? = null, requestOptions: RequestOptions? = null): SearchSynonymsResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `searchSynonyms`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "synonyms", "search"),
      isRead = true,
      query = buildMap {
        type?.let { put("type", it) }
        page?.let { put("page", it) }
        hitsPerPage?.let { put("hitsPerPage", it) }
      },
      body = searchSynonymsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search for a user ID.
   * Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time. To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
   * @param searchUserIdsParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchUserIds(searchUserIdsParams: SearchUserIdsParams, requestOptions: RequestOptions? = null): SearchUserIdsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "clusters", "mapping", "search"),
      isRead = true,
      body = searchUserIdsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Set stop word settings.
   * Set stop word settings for a specific language.
   * @param dictionarySettingsParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun setDictionarySettings(dictionarySettingsParams: DictionarySettingsParams, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "dictionaries", "*", "settings"),
      body = dictionarySettingsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Update index settings.
   * Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.
   * @param indexName Index on which to perform the request.
   * @param indexSettings
   * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices.
   * @param requestOptions additional request configuration.
   */
  public suspend fun setSettings(indexName: String, indexSettings: IndexSettings, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `setSettings`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "indexes", "$indexName", "settings"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
      body = indexSettings,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Update an API key.
   * Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key.
   * @param key API key.
   * @param apiKey
   * @param requestOptions additional request configuration.
   */
  public suspend fun updateApiKey(key: String, apiKey: ApiKey, requestOptions: RequestOptions? = null): UpdateApiKeyResponse {
    require(key.isNotBlank()) { "Parameter `key` is required when calling `updateApiKey`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "keys", "$key"),
      body = apiKey,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }
}
