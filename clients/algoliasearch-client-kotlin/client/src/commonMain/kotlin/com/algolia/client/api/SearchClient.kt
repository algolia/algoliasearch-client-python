/** Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT. */
package com.algolia.client.api

import com.algolia.client.configuration.*
import com.algolia.client.exception.*
import com.algolia.client.extensions.internal.*
import com.algolia.client.model.search.*
import com.algolia.client.transport.*
import com.algolia.client.transport.internal.*
import kotlinx.serialization.json.*

public class SearchClient(
  override val appId: String,
  override val apiKey: String,
  override val options: ClientOptions = ClientOptions(),
) : ApiClient {

  init {
    require(appId.isNotBlank()) { "`appId` is missing." }
    require(apiKey.isNotBlank()) { "`apiKey` is missing." }
  }

  override val requester: Requester = requesterOf(clientName = "Search", appId = appId, apiKey = apiKey, options = options) {
    listOf(
      Host("$appId-dsn.algolia.net", CallType.Read),
      Host("$appId.algolia.net", CallType.Write),
    ) + mutableListOf(
      Host("$appId-1.algolianet.com"),
      Host("$appId-2.algolianet.com"),
      Host("$appId-3.algolianet.com"),
    ).apply { shuffle() }
  }

  /**
   * Create an API key.
   * Add a new API Key with specific permissions/restrictions.
   * @param apiKey
   * @param requestOptions additional request configuration.
   */
  public suspend fun addApiKey(apiKey: ApiKey, requestOptions: RequestOptions? = null): AddApiKeyResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "keys"),
      body = apiKey,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Add or replace an object.
   * Add or replace an object with a given object ID. If the object does not exist, it will be created. If it already exists, it will be replaced.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param body The Algolia object.
   * @param requestOptions additional request configuration.
   */
  public suspend fun addOrUpdateObject(indexName: String, objectID: String, body: JsonObject, requestOptions: RequestOptions? = null): UpdatedAtWithObjectIdResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `addOrUpdateObject`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `addOrUpdateObject`." }
    require(body.isNotEmpty()) { "Parameter `body` is required when calling `addOrUpdateObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "indexes", "$indexName", "$objectID"),
      body = body,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Add a single source.
   * Add a single source to the list of allowed sources.
   * @param source The source to add.
   * @param requestOptions additional request configuration.
   */
  public suspend fun appendSource(source: Source, requestOptions: RequestOptions? = null): CreatedAtResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "security", "sources", "append"),
      body = source,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Assign or Move userID.
   * Assign or Move a userID to a cluster. The time it takes to migrate (move) a user is proportional to the amount of data linked to the userID. Upon success, the response is 200 OK. A successful response indicates that the operation has been taken into account, and the userID is directly usable.
   * @param xAlgoliaUserID userID to assign.
   * @param assignUserIdParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun assignUserId(xAlgoliaUserID: String, assignUserIdParams: AssignUserIdParams, requestOptions: RequestOptions? = null): CreatedAtResponse {
    require(xAlgoliaUserID.isNotBlank()) { "Parameter `xAlgoliaUserID` is required when calling `assignUserId`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "clusters", "mapping"),
      headers = buildMap {
        put("X-Algolia-User-ID", xAlgoliaUserID)
      },
      body = assignUserIdParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Batch operations to one index.
   * Perform multiple write operations targeting one index, in a single API call.
   * @param indexName The index in which to perform the request.
   * @param batchWriteParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun batch(indexName: String, batchWriteParams: BatchWriteParams, requestOptions: RequestOptions? = null): BatchResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `batch`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "batch"),
      body = batchWriteParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Batch assign userIDs.
   * Assign multiple userIDs to a cluster. Upon success, the response is 200 OK. A successful response indicates that the operation has been taken into account, and the userIDs are directly usable.
   * @param xAlgoliaUserID userID to assign.
   * @param batchAssignUserIdsParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun batchAssignUserIds(xAlgoliaUserID: String, batchAssignUserIdsParams: BatchAssignUserIdsParams, requestOptions: RequestOptions? = null): CreatedAtResponse {
    require(xAlgoliaUserID.isNotBlank()) { "Parameter `xAlgoliaUserID` is required when calling `batchAssignUserIds`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "clusters", "mapping", "batch"),
      headers = buildMap {
        put("X-Algolia-User-ID", xAlgoliaUserID)
      },
      body = batchAssignUserIdsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Batch dictionary entries.
   * Send a batch of dictionary entries.
   * @param dictionaryName The dictionary to search in.
   * @param batchDictionaryEntriesParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun batchDictionaryEntries(dictionaryName: DictionaryType, batchDictionaryEntriesParams: BatchDictionaryEntriesParams, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "dictionaries", "$dictionaryName", "batch"),
      body = batchDictionaryEntriesParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Retrieve all index content.
   * This method allows you to retrieve all index content. It can retrieve up to 1,000 records per call and supports full text search and filters. For performance reasons, some features are not supported, including `distinct`, sorting by `typos`, `words` or `geo distance`. When there is more content to be browsed, the response contains a cursor field. This cursor has to be passed to the subsequent call to browse in order to get the next page of results. When the end of the index has been reached, the cursor field is absent from the response.
   * @param indexName The index in which to perform the request.
   * @param browseParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun browse(indexName: String, browseParams: BrowseParams? = null, requestOptions: RequestOptions? = null): BrowseResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `browse`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "browse"),
      body = browseParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Clear all synonyms.
   * Remove all synonyms from an index.
   * @param indexName The index in which to perform the request.
   * @param forwardToReplicas When true, changes are also propagated to replicas of the given indexName.
   * @param requestOptions additional request configuration.
   */
  public suspend fun clearAllSynonyms(indexName: String, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `clearAllSynonyms`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "synonyms", "clear"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Clear all objects from an index.
   * Delete an index's content, but leave settings and index-specific API keys untouched.
   * @param indexName The index in which to perform the request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun clearObjects(indexName: String, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `clearObjects`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "clear"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Clear Rules.
   * Delete all Rules in the index.
   * @param indexName The index in which to perform the request.
   * @param forwardToReplicas When true, changes are also propagated to replicas of the given indexName.
   * @param requestOptions additional request configuration.
   */
  public suspend fun clearRules(indexName: String, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `clearRules`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "rules", "clear"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Send requests to the Algolia REST API.
   * This method allow you to send requests to the Algolia REST API.
   * @param path The path of the API endpoint to target, anything after the /1 needs to be specified.
   * @param parameters Query parameters to be applied to the current query.
   * @param requestOptions additional request configuration.
   */
  public suspend fun del(path: String, parameters: Map<kotlin.String, Any>? = null, requestOptions: RequestOptions? = null): JsonObject {
    require(path.isNotBlank()) { "Parameter `path` is required when calling `del`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = "/1{path}".replace("{path}", path),
      query = buildMap {
        parameters?.let { putAll(it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete an API key.
   * Delete an existing API Key.
   * @param key API Key string.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteApiKey(key: String, requestOptions: RequestOptions? = null): DeleteApiKeyResponse {
    require(key.isNotBlank()) { "Parameter `key` is required when calling `deleteApiKey`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "keys", "$key"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete all records matching the query.
   * Remove all objects matching a filter (including geo filters). This method enables you to delete one or more objects based on filters (numeric, facet, tag or geo queries). It doesn't accept empty filters or a query.
   * @param indexName The index in which to perform the request.
   * @param deleteByParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteBy(indexName: String, deleteByParams: DeleteByParams, requestOptions: RequestOptions? = null): DeletedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteBy`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "deleteByQuery"),
      body = deleteByParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete index.
   * Delete an existing index.
   * @param indexName The index in which to perform the request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteIndex(indexName: String, requestOptions: RequestOptions? = null): DeletedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteIndex`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "indexes", "$indexName"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete an object.
   * Delete an existing object.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteObject(indexName: String, objectID: String, requestOptions: RequestOptions? = null): DeletedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteObject`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `deleteObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "indexes", "$indexName", "$objectID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete a rule.
   * Delete the Rule with the specified objectID.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param forwardToReplicas When true, changes are also propagated to replicas of the given indexName.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteRule(indexName: String, objectID: String, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteRule`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `deleteRule`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "indexes", "$indexName", "rules", "$objectID"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Remove a single source.
   * Remove a single source from the list of allowed sources.
   * @param source The IP range of the source.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteSource(source: String, requestOptions: RequestOptions? = null): DeleteSourceResponse {
    require(source.isNotBlank()) { "Parameter `source` is required when calling `deleteSource`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "security", "sources", "$source"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Delete synonym.
   * Delete a single synonyms set, identified by the given objectID.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param forwardToReplicas When true, changes are also propagated to replicas of the given indexName.
   * @param requestOptions additional request configuration.
   */
  public suspend fun deleteSynonym(indexName: String, objectID: String, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): DeletedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `deleteSynonym`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `deleteSynonym`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "indexes", "$indexName", "synonyms", "$objectID"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Send requests to the Algolia REST API.
   * This method allow you to send requests to the Algolia REST API.
   * @param path The path of the API endpoint to target, anything after the /1 needs to be specified.
   * @param parameters Query parameters to be applied to the current query.
   * @param requestOptions additional request configuration.
   */
  public suspend fun get(path: String, parameters: Map<kotlin.String, Any>? = null, requestOptions: RequestOptions? = null): JsonObject {
    require(path.isNotBlank()) { "Parameter `path` is required when calling `get`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = "/1{path}".replace("{path}", path),
      query = buildMap {
        parameters?.let { putAll(it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get an API key.
   * Get the permissions of an API key.
   * @param key API Key string.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getApiKey(key: String, requestOptions: RequestOptions? = null): GetApiKeyResponse {
    require(key.isNotBlank()) { "Parameter `key` is required when calling `getApiKey`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "keys", "$key"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List available languages.
   * List dictionaries supported per language.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getDictionaryLanguages(requestOptions: RequestOptions? = null): Map<kotlin.String, Languages> {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "dictionaries", "*", "languages"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Retrieve dictionaries settings.
   * Retrieve dictionaries settings. The API stores languages whose standard entries are disabled. Fetch settings does not return false values.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getDictionarySettings(requestOptions: RequestOptions? = null): GetDictionarySettingsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "dictionaries", "*", "settings"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Return the latest log entries.
   * Return the latest log entries.
   * @param offset First entry to retrieve (zero-based). Log entries are sorted by decreasing date, therefore 0 designates the most recent log entry. (default to 0)
   * @param length Maximum number of entries to retrieve. The maximum allowed value is 1000. (default to 10)
   * @param indexName Index for which log entries should be retrieved. When omitted, log entries are retrieved across all indices.
   * @param type Type of log entries to retrieve. When omitted, all log entries are retrieved. (default to all)
   * @param requestOptions additional request configuration.
   */
  public suspend fun getLogs(offset: Int? = null, length: Int? = null, indexName: String? = null, type: LogType? = null, requestOptions: RequestOptions? = null): GetLogsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "logs"),
      query = buildMap {
        offset?.let { put("offset", it) }
        length?.let { put("length", it) }
        indexName?.let { put("indexName", it) }
        type?.let { put("type", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Retrieve an object.
   * Retrieve one object from the index.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param attributesToRetrieve List of attributes to retrieve. If not specified, all retrievable attributes are returned.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getObject(indexName: String, objectID: String, attributesToRetrieve: List<String>? = null, requestOptions: RequestOptions? = null): Map<kotlin.String, String> {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getObject`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `getObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "$objectID"),
      query = buildMap {
        attributesToRetrieve?.let { put("attributesToRetrieve", it.joinToString(",")) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Retrieve one or more objects.
   * Retrieve one or more objects, potentially from different indices, in a single API call.
   * @param getObjectsParams The Algolia object.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getObjects(getObjectsParams: GetObjectsParams, requestOptions: RequestOptions? = null): GetObjectsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "*", "objects"),
      isRead = true,
      body = getObjectsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get a rule.
   * Retrieve the Rule with the specified objectID.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getRule(indexName: String, objectID: String, requestOptions: RequestOptions? = null): Rule {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getRule`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `getRule`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "rules", "$objectID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Retrieve settings of an index.
   * Retrieve settings of an index.
   * @param indexName The index in which to perform the request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getSettings(indexName: String, requestOptions: RequestOptions? = null): IndexSettings {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getSettings`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "settings"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List all allowed sources.
   * List all allowed sources.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getSources(requestOptions: RequestOptions? = null): List<Source> {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "security", "sources"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get synonym.
   * Fetch a synonym object identified by its objectID.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getSynonym(indexName: String, objectID: String, requestOptions: RequestOptions? = null): SynonymHit {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getSynonym`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `getSynonym`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "synonyms", "$objectID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Check the status of a task.
   * Check the current status of a given task.
   * @param indexName The index in which to perform the request.
   * @param taskID Unique identifier of an task. Numeric value (up to 64bits).
   * @param requestOptions additional request configuration.
   */
  public suspend fun getTask(indexName: String, taskID: Long, requestOptions: RequestOptions? = null): GetTaskResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `getTask`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes", "$indexName", "task", "$taskID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get top userID.
   * Get the top 10 userIDs with the highest number of records per cluster. The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters. Upon success, the response is 200 OK and contains the following array of userIDs and clusters.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getTopUserIds(requestOptions: RequestOptions? = null): GetTopUserIdsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters", "mapping", "top"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get userID.
   * Returns the userID data stored in the mapping. The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters. Upon success, the response is 200 OK and contains the following userID data.
   * @param userID userID to assign.
   * @param requestOptions additional request configuration.
   */
  public suspend fun getUserId(userID: String, requestOptions: RequestOptions? = null): UserId {
    require(userID.isNotBlank()) { "Parameter `userID` is required when calling `getUserId`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters", "mapping", "$userID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Get migration status.
   * Get the status of your clusters' migrations or user creations. Creating a large batch of users or migrating your multi-cluster may take quite some time. This method lets you retrieve the status of the migration, so you can know when it's done. Upon success, the response is 200 OK. A successful response indicates that the operation has been taken into account, and the userIDs are directly usable.
   * @param getClusters If the clusters pending mapping state should be on the response.
   * @param requestOptions additional request configuration.
   */
  public suspend fun hasPendingMappings(getClusters: Boolean? = null, requestOptions: RequestOptions? = null): HasPendingMappingsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters", "mapping", "pending"),
      query = buildMap {
        getClusters?.let { put("getClusters", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List API Keys.
   * List API keys, along with their associated rights.
   * @param requestOptions additional request configuration.
   */
  public suspend fun listApiKeys(requestOptions: RequestOptions? = null): ListApiKeysResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "keys"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List clusters.
   * List the clusters available in a multi-clusters setup for a single appID. Upon success, the response is 200 OK and contains the following clusters.
   * @param requestOptions additional request configuration.
   */
  public suspend fun listClusters(requestOptions: RequestOptions? = null): ListClustersResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List existing indexes.
   * List existing indexes from an application.
   * @param page Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
   * @param requestOptions additional request configuration.
   */
  public suspend fun listIndices(page: Int? = null, requestOptions: RequestOptions? = null): ListIndicesResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "indexes"),
      query = buildMap {
        page?.let { put("page", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * List userIDs.
   * List the userIDs assigned to a multi-clusters appID. The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters. Upon success, the response is 200 OK and contains the following userIDs data.
   * @param page Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
   * @param hitsPerPage Maximum number of objects to retrieve. (default to 100)
   * @param requestOptions additional request configuration.
   */
  public suspend fun listUserIds(page: Int? = null, hitsPerPage: Int? = null, requestOptions: RequestOptions? = null): ListUserIdsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.GET,
      path = listOf("1", "clusters", "mapping"),
      query = buildMap {
        page?.let { put("page", it) }
        hitsPerPage?.let { put("hitsPerPage", it) }
      },
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Batch operations to many indices.
   * Perform multiple write operations, potentially targeting multiple indices, in a single API call.
   * @param batchParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun multipleBatch(batchParams: BatchParams, requestOptions: RequestOptions? = null): MultipleBatchResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "*", "batch"),
      body = batchParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Copy/move index.
   * Performs a copy or a move operation on a index.
   * @param indexName The index in which to perform the request.
   * @param operationIndexParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun operationIndex(indexName: String, operationIndexParams: OperationIndexParams, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `operationIndex`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "operation"),
      body = operationIndexParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Partially update an object.
   * Update one or more attributes of an existing object. This method lets you update only a part of an existing object, either by adding new attributes or updating existing ones. You can partially update several objects in a single method call. If the index targeted by this operation doesn't exist yet, it's automatically created.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param attributesToUpdate Map of attribute(s) to update.
   * @param createIfNotExists Creates the record if it does not exist yet. (default to true)
   * @param requestOptions additional request configuration.
   */
  public suspend fun partialUpdateObject(indexName: String, objectID: String, attributesToUpdate: Map<kotlin.String, AttributeToUpdate>, createIfNotExists: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtWithObjectIdResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `partialUpdateObject`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `partialUpdateObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "$objectID", "partial"),
      query = buildMap {
        createIfNotExists?.let { put("createIfNotExists", it) }
      },
      body = attributesToUpdate,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Send requests to the Algolia REST API.
   * This method allow you to send requests to the Algolia REST API.
   * @param path The path of the API endpoint to target, anything after the /1 needs to be specified.
   * @param parameters Query parameters to be applied to the current query.
   * @param body The parameters to send with the custom request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun post(path: String, parameters: Map<kotlin.String, Any>? = null, body: JsonObject? = null, requestOptions: RequestOptions? = null): JsonObject {
    require(path.isNotBlank()) { "Parameter `path` is required when calling `post`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = "/1{path}".replace("{path}", path),
      query = buildMap {
        parameters?.let { putAll(it) }
      },
      body = body,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Send requests to the Algolia REST API.
   * This method allow you to send requests to the Algolia REST API.
   * @param path The path of the API endpoint to target, anything after the /1 needs to be specified.
   * @param parameters Query parameters to be applied to the current query.
   * @param body The parameters to send with the custom request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun put(path: String, parameters: Map<kotlin.String, Any>? = null, body: JsonObject? = null, requestOptions: RequestOptions? = null): JsonObject {
    require(path.isNotBlank()) { "Parameter `path` is required when calling `put`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = "/1{path}".replace("{path}", path),
      query = buildMap {
        parameters?.let { putAll(it) }
      },
      body = body,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Remove userID.
   * Remove a userID and its associated data from the multi-clusters. Upon success, the response is 200 OK and a task is created to remove the userID data and mapping.
   * @param userID userID to assign.
   * @param requestOptions additional request configuration.
   */
  public suspend fun removeUserId(userID: String, requestOptions: RequestOptions? = null): RemoveUserIdResponse {
    require(userID.isNotBlank()) { "Parameter `userID` is required when calling `removeUserId`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.DELETE,
      path = listOf("1", "clusters", "mapping", "$userID"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Replace all allowed sources.
   * Replace all allowed sources.
   * @param source The sources to allow.
   * @param requestOptions additional request configuration.
   */
  public suspend fun replaceSources(source: List<Source>, requestOptions: RequestOptions? = null): ReplaceSourceResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "security", "sources"),
      body = source,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Restore an API key.
   * Restore a deleted API key, along with its associated rights.
   * @param key API Key string.
   * @param requestOptions additional request configuration.
   */
  public suspend fun restoreApiKey(key: String, requestOptions: RequestOptions? = null): AddApiKeyResponse {
    require(key.isNotBlank()) { "Parameter `key` is required when calling `restoreApiKey`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "keys", "$key", "restore"),
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Add an object to the index.
   * Add an object to the index, automatically assigning it an object ID.
   * @param indexName The index in which to perform the request.
   * @param body The Algolia record.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveObject(indexName: String, body: JsonObject, requestOptions: RequestOptions? = null): SaveObjectResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveObject`." }
    require(body.isNotEmpty()) { "Parameter `body` is required when calling `saveObject`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName"),
      body = body,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Save/Update a rule.
   * Create or update the Rule with the specified objectID.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param rule
   * @param forwardToReplicas When true, changes are also propagated to replicas of the given indexName.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveRule(indexName: String, objectID: String, rule: Rule, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedRuleResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveRule`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `saveRule`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "indexes", "$indexName", "rules", "$objectID"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
      body = rule,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Save a batch of rules.
   * Create/update multiple rules objects at once.
   * @param indexName The index in which to perform the request.
   * @param rules
   * @param forwardToReplicas When true, changes are also propagated to replicas of the given indexName.
   * @param clearExistingRules When true, existing Rules are cleared before adding this batch. When false, existing Rules are kept.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveRules(indexName: String, rules: List<Rule>, forwardToReplicas: Boolean? = null, clearExistingRules: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveRules`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "rules", "batch"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
        clearExistingRules?.let { put("clearExistingRules", it) }
      },
      body = rules,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Save synonym.
   * Create a new synonym object or update the existing synonym object with the given object ID.
   * @param indexName The index in which to perform the request.
   * @param objectID Unique identifier of an object.
   * @param synonymHit
   * @param forwardToReplicas When true, changes are also propagated to replicas of the given indexName.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveSynonym(indexName: String, objectID: String, synonymHit: SynonymHit, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): SaveSynonymResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveSynonym`." }
    require(objectID.isNotBlank()) { "Parameter `objectID` is required when calling `saveSynonym`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "indexes", "$indexName", "synonyms", "$objectID"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
      body = synonymHit,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Save a batch of synonyms.
   * Create/update multiple synonym objects at once, potentially replacing the entire list of synonyms if replaceExistingSynonyms is true.
   * @param indexName The index in which to perform the request.
   * @param synonymHit
   * @param forwardToReplicas When true, changes are also propagated to replicas of the given indexName.
   * @param replaceExistingSynonyms Replace all synonyms of the index with the ones sent with this request.
   * @param requestOptions additional request configuration.
   */
  public suspend fun saveSynonyms(indexName: String, synonymHit: List<SynonymHit>, forwardToReplicas: Boolean? = null, replaceExistingSynonyms: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `saveSynonyms`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "synonyms", "batch"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
        replaceExistingSynonyms?.let { put("replaceExistingSynonyms", it) }
      },
      body = synonymHit,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search multiple indices.
   * Perform a search operation targeting one or many indices.
   * @param searchMethodParams The `search` requests and strategy.
   * @param requestOptions additional request configuration.
   */
  public suspend fun search(searchMethodParams: SearchMethodParams, requestOptions: RequestOptions? = null): SearchResponses {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "*", "queries"),
      isRead = true,
      body = searchMethodParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search a dictionary entries.
   * Search the dictionary entries.
   * @param dictionaryName The dictionary to search in.
   * @param searchDictionaryEntriesParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchDictionaryEntries(dictionaryName: DictionaryType, searchDictionaryEntriesParams: SearchDictionaryEntriesParams, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "dictionaries", "$dictionaryName", "search"),
      isRead = true,
      body = searchDictionaryEntriesParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search for values of a given facet.
   * Search for values of a given facet, optionally restricting the returned values to those contained in objects matching other search criteria.
   * @param indexName The index in which to perform the request.
   * @param facetName The facet name.
   * @param searchForFacetValuesRequest
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchForFacetValues(indexName: String, facetName: String, searchForFacetValuesRequest: SearchForFacetValuesRequest? = null, requestOptions: RequestOptions? = null): SearchForFacetValuesResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `searchForFacetValues`." }
    require(facetName.isNotBlank()) { "Parameter `facetName` is required when calling `searchForFacetValues`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "facets", "$facetName", "query"),
      isRead = true,
      body = searchForFacetValuesRequest,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search for rules.
   * Search for rules matching various criteria.
   * @param indexName The index in which to perform the request.
   * @param searchRulesParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchRules(indexName: String, searchRulesParams: SearchRulesParams? = null, requestOptions: RequestOptions? = null): SearchRulesResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `searchRules`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "rules", "search"),
      isRead = true,
      body = searchRulesParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search in a single index.
   * Perform a search operation targeting one specific index.
   * @param indexName The index in which to perform the request.
   * @param searchParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchSingleIndex(indexName: String, searchParams: SearchParams? = null, requestOptions: RequestOptions? = null): SearchResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `searchSingleIndex`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "query"),
      isRead = true,
      body = searchParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search synonyms.
   * Search or browse all synonyms, optionally filtering them by type.
   * @param indexName The index in which to perform the request.
   * @param type Only search for specific types of synonyms.
   * @param page Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination). (default to 0)
   * @param hitsPerPage Maximum number of objects to retrieve. (default to 100)
   * @param searchSynonymsParams The body of the the `searchSynonyms` method.
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchSynonyms(indexName: String, type: SynonymType? = null, page: Int? = null, hitsPerPage: Int? = null, searchSynonymsParams: SearchSynonymsParams? = null, requestOptions: RequestOptions? = null): SearchSynonymsResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `searchSynonyms`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "indexes", "$indexName", "synonyms", "search"),
      isRead = true,
      query = buildMap {
        type?.let { put("type", it) }
        page?.let { put("page", it) }
        hitsPerPage?.let { put("hitsPerPage", it) }
      },
      body = searchSynonymsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Search userID.
   * Search for userIDs. The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds propagate to the different clusters. To keep updates moving quickly, the index of userIDs isn't built synchronously with the mapping. Instead, the index is built once every 12h, at the same time as the update of userID usage. For example, when you perform a modification like adding or moving a userID, the search will report an outdated value until the next rebuild of the mapping, which takes place every 12h. Upon success, the response is 200 OK and contains the following userIDs data.
   * @param searchUserIdsParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun searchUserIds(searchUserIdsParams: SearchUserIdsParams, requestOptions: RequestOptions? = null): SearchUserIdsResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.POST,
      path = listOf("1", "clusters", "mapping", "search"),
      isRead = true,
      body = searchUserIdsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Set dictionaries settings.
   * Set dictionaries settings.
   * @param dictionarySettingsParams
   * @param requestOptions additional request configuration.
   */
  public suspend fun setDictionarySettings(dictionarySettingsParams: DictionarySettingsParams, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "dictionaries", "*", "settings"),
      body = dictionarySettingsParams,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Update settings of an index.
   * Update settings of an index. Only specified settings are overridden; unspecified settings are left unchanged. Specifying null for a setting resets it to its default value.
   * @param indexName The index in which to perform the request.
   * @param indexSettings
   * @param forwardToReplicas When true, changes are also propagated to replicas of the given indexName.
   * @param requestOptions additional request configuration.
   */
  public suspend fun setSettings(indexName: String, indexSettings: IndexSettings, forwardToReplicas: Boolean? = null, requestOptions: RequestOptions? = null): UpdatedAtResponse {
    require(indexName.isNotBlank()) { "Parameter `indexName` is required when calling `setSettings`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "indexes", "$indexName", "settings"),
      query = buildMap {
        forwardToReplicas?.let { put("forwardToReplicas", it) }
      },
      body = indexSettings,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }

  /**
   * Update an API key.
   * Replace every permission of an existing API key.
   * @param key API Key string.
   * @param apiKey
   * @param requestOptions additional request configuration.
   */
  public suspend fun updateApiKey(key: String, apiKey: ApiKey, requestOptions: RequestOptions? = null): UpdateApiKeyResponse {
    require(key.isNotBlank()) { "Parameter `key` is required when calling `updateApiKey`." }
    val requestConfig = RequestConfig(
      method = RequestMethod.PUT,
      path = listOf("1", "keys", "$key"),
      body = apiKey,
    )
    return requester.execute(
      requestConfig = requestConfig,
      requestOptions = requestOptions,
    )
  }
}
