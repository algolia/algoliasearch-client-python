/** Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT. */
package com.algolia.client.model.search

import com.algolia.client.extensions.internal.*
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*
import kotlinx.serialization.json.*

/**
 * Dictionary entry.
 *
 * @param objectID Unique identifier for a dictionary object.
 * @param language [Supported language ISO code](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/).
 * @param word Dictionary entry word. Usage depends on the type of dictionary entry. **`stopwordEntry`** The stop word you want to add or update. If the entry already exists in Algolia's standard dictionary, you can override its behavior by adding it to the custom dictionary and setting its `state` to `disabled`. **`compoundEntry`** When `decomposition` is empty: adds `word` as a compound atom. For example, atom “kino” decomposes the query “kopfkino” into \"kopf\" and \"kino\". When `decomposition` isn't empty: creates a decomposition exception. For example, when decomposition is set to the [\"hund\", \"hutte\"] exception, \"hundehutte\" decomposes into “hund” and “hutte”, discarding the linking \"e\".
 * @param words Compound dictionary [word declensions](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/). If the entry already exists in Algolia's standard dictionary, you can override its behavior by adding it to the custom dictionary and setting its `state` to `disabled`.
 * @param decomposition For compound entries, governs the behavior of the `word` parameter.
 * @param state
 */
@Serializable(DictionaryEntrySerializer::class)
public data class DictionaryEntry(

  /** Unique identifier for a dictionary object. */
  val objectID: String,

  /** [Supported language ISO code](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/).  */
  val language: String,

  /** Dictionary entry word. Usage depends on the type of dictionary entry. **`stopwordEntry`** The stop word you want to add or update. If the entry already exists in Algolia's standard dictionary, you can override its behavior by adding it to the custom dictionary and setting its `state` to `disabled`. **`compoundEntry`** When `decomposition` is empty: adds `word` as a compound atom. For example, atom “kino” decomposes the query “kopfkino” into \"kopf\" and \"kino\". When `decomposition` isn't empty: creates a decomposition exception. For example, when decomposition is set to the [\"hund\", \"hutte\"] exception, \"hundehutte\" decomposes into “hund” and “hutte”, discarding the linking \"e\".  */
  val word: String? = null,

  /** Compound dictionary [word declensions](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/). If the entry already exists in Algolia's standard dictionary, you can override its behavior by adding it to the custom dictionary and setting its `state` to `disabled`.  */
  val words: List<String>? = null,

  /** For compound entries, governs the behavior of the `word` parameter. */
  val decomposition: List<String>? = null,

  val state: DictionaryEntryState? = null,

  val additionalProperties: Map<String, JsonElement>? = null,
)

internal object DictionaryEntrySerializer : KSerializer<DictionaryEntry> {

  override val descriptor: SerialDescriptor = buildClassSerialDescriptor("DictionaryEntry") {
    element<String>("objectID")
    element<String>("language")
    element<String>("word")
    element<List<String>>("words")
    element<List<String>>("decomposition")
    element<DictionaryEntryState>("state")
  }

  override fun deserialize(decoder: Decoder): DictionaryEntry {
    val input = decoder.asJsonDecoder()
    val tree = input.decodeJsonObject()
    return DictionaryEntry(
      objectID = tree.getValue("objectID").let { input.json.decodeFromJsonElement(it) },
      language = tree.getValue("language").let { input.json.decodeFromJsonElement(it) },
      word = tree["word"]?.let { input.json.decodeFromJsonElement(it) },
      words = tree["words"]?.let { input.json.decodeFromJsonElement(it) },
      decomposition = tree["decomposition"]?.let { input.json.decodeFromJsonElement(it) },
      state = tree["state"]?.let { input.json.decodeFromJsonElement(it) },
      additionalProperties = tree.filterKeys { it !in descriptor.elementNames },
    )
  }

  override fun serialize(encoder: Encoder, value: DictionaryEntry) {
    val output = encoder.asJsonEncoder()
    val json = buildJsonObject {
      put("objectID", output.json.encodeToJsonElement(value.objectID))
      put("language", output.json.encodeToJsonElement(value.language))
      value.word?.let { put("word", output.json.encodeToJsonElement(it)) }
      value.words?.let { put("words", output.json.encodeToJsonElement(it)) }
      value.decomposition?.let { put("decomposition", output.json.encodeToJsonElement(it)) }
      value.state?.let { put("state", output.json.encodeToJsonElement(it)) }
      value.additionalProperties?.onEach { (key, element) -> put(key, element) }
    }
    (encoder as JsonEncoder).encodeJsonElement(json)
  }
}
