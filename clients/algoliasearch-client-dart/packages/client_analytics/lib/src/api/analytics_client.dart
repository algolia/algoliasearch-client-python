// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import 'package:algolia_client_core/algolia_client_core.dart';
import 'package:algolia_client_analytics/src/deserialize.dart';
import 'package:algolia_client_analytics/src/version.dart';

import 'package:algolia_client_analytics/src/model/direction.dart';
import 'package:algolia_client_analytics/src/model/get_average_click_position_response.dart';
import 'package:algolia_client_analytics/src/model/get_click_positions_response.dart';
import 'package:algolia_client_analytics/src/model/get_click_through_rate_response.dart';
import 'package:algolia_client_analytics/src/model/get_conversation_rate_response.dart';
import 'package:algolia_client_analytics/src/model/get_no_click_rate_response.dart';
import 'package:algolia_client_analytics/src/model/get_no_results_rate_response.dart';
import 'package:algolia_client_analytics/src/model/get_searches_count_response.dart';
import 'package:algolia_client_analytics/src/model/get_searches_no_clicks_response.dart';
import 'package:algolia_client_analytics/src/model/get_searches_no_results_response.dart';
import 'package:algolia_client_analytics/src/model/get_status_response.dart';
import 'package:algolia_client_analytics/src/model/get_top_countries_response.dart';
import 'package:algolia_client_analytics/src/model/get_top_filter_attributes_response.dart';
import 'package:algolia_client_analytics/src/model/get_top_filter_for_attribute_response.dart';
import 'package:algolia_client_analytics/src/model/get_top_filters_no_results_response.dart';
import 'package:algolia_client_analytics/src/model/get_users_count_response.dart';
import 'package:algolia_client_analytics/src/model/order_by.dart';

final class AnalyticsClient implements ApiClient {
  @override
  final String apiKey;

  @override
  final String appId;

  @override
  final ClientOptions options;

  final String? region;

  final RetryStrategy _retryStrategy;

  AnalyticsClient({
    required this.appId,
    required this.apiKey,
    this.options = const ClientOptions(),
    this.region,
  }) : _retryStrategy = RetryStrategy.create(
            segment: AgentSegment(value: "Analytics", version: packageVersion),
            appId: appId,
            apiKey: apiKey,
            options: options,
            defaultHosts: () {
              final allowedRegions = ['de', 'us'];
              assert(
                region == null || allowedRegions.contains(region),
                '`region` must be one of the following: ${allowedRegions.join(', ')}',
              );
              final url = region == null
                  ? 'analytics.algolia.com'
                  : 'analytics.{region}.algolia.com'
                      .replaceAll('{region}', region);
              return [Host(url: url)];
            }) {
    assert(appId.isNotEmpty, '`appId` is missing.');
    assert(apiKey.isNotEmpty, '`apiKey` is missing.');
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> del({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `del`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> get({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `get`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Get average click position.
  /// Return the average click position for the complete time range and for individual days. > **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetAverageClickPositionResponse> getAverageClickPosition({
    required String index,
    String? startDate,
    String? endDate,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getAverageClickPosition`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/clicks/averageClickPosition',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetAverageClickPositionResponse,
        GetAverageClickPositionResponse>(
      response,
      'GetAverageClickPositionResponse',
      growable: true,
    );
  }

  /// Get click positions.
  /// Show the number of clicks events and their associated position in the search results.  > **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetClickPositionsResponse> getClickPositions({
    required String index,
    String? startDate,
    String? endDate,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getClickPositions`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/clicks/positions',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetClickPositionsResponse, GetClickPositionsResponse>(
      response,
      'GetClickPositionsResponse',
      growable: true,
    );
  }

  /// Get click-through rate (CTR).
  /// Returns a [click-through rate (CTR)](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#click-through-rate).
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetClickThroughRateResponse> getClickThroughRate({
    required String index,
    String? startDate,
    String? endDate,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getClickThroughRate`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/clicks/clickThroughRate',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetClickThroughRateResponse,
        GetClickThroughRateResponse>(
      response,
      'GetClickThroughRateResponse',
      growable: true,
    );
  }

  /// Get conversion rate (CR).
  /// Return a [conversion rate](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#conversion-rate).
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetConversationRateResponse> getConversationRate({
    required String index,
    String? startDate,
    String? endDate,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getConversationRate`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/conversions/conversionRate',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetConversationRateResponse,
        GetConversationRateResponse>(
      response,
      'GetConversationRateResponse',
      growable: true,
    );
  }

  /// Get no click rate.
  /// Returns the rate at which searches don't lead to any clicks. The endpoint returns a value for the complete given time range, as well as a value per day. It also returns the count of searches and searches without clicks.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetNoClickRateResponse> getNoClickRate({
    required String index,
    String? startDate,
    String? endDate,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getNoClickRate`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/searches/noClickRate',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetNoClickRateResponse, GetNoClickRateResponse>(
      response,
      'GetNoClickRateResponse',
      growable: true,
    );
  }

  /// Get no results rate.
  /// Returns the rate at which searches didn't return any results.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetNoResultsRateResponse> getNoResultsRate({
    required String index,
    String? startDate,
    String? endDate,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getNoResultsRate`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/searches/noResultRate',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetNoResultsRateResponse, GetNoResultsRateResponse>(
      response,
      'GetNoResultsRateResponse',
      growable: true,
    );
  }

  /// Get number of searches.
  /// Returns the number of searches within a time range.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetSearchesCountResponse> getSearchesCount({
    required String index,
    String? startDate,
    String? endDate,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getSearchesCount`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/searches/count',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetSearchesCountResponse, GetSearchesCountResponse>(
      response,
      'GetSearchesCountResponse',
      growable: true,
    );
  }

  /// Get top searches with no clicks.
  /// Return the most popular of the last 1,000 searches that didn't lead to any clicks.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [limit] Number of records to return (page size).
  /// * [offset] Position of the starting record. Used for paging. 0 is the first record.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetSearchesNoClicksResponse> getSearchesNoClicks({
    required String index,
    String? startDate,
    String? endDate,
    int? limit,
    int? offset,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getSearchesNoClicks`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/searches/noClicks',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetSearchesNoClicksResponse,
        GetSearchesNoClicksResponse>(
      response,
      'GetSearchesNoClicksResponse',
      growable: true,
    );
  }

  /// Get top searches with no results.
  /// Returns the most popular of the latest 1,000 searches that didn't return any results.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [limit] Number of records to return (page size).
  /// * [offset] Position of the starting record. Used for paging. 0 is the first record.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetSearchesNoResultsResponse> getSearchesNoResults({
    required String index,
    String? startDate,
    String? endDate,
    int? limit,
    int? offset,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getSearchesNoResults`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/searches/noResults',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetSearchesNoResultsResponse,
        GetSearchesNoResultsResponse>(
      response,
      'GetSearchesNoResultsResponse',
      growable: true,
    );
  }

  /// Get Analytics API status.
  /// Return the latest update time of the Analytics API for an index. If the index has been recently created or no search has been performed yet, `updatedAt` will be `null`. > **Note**: The Analytics API is updated every 5&nbsp;minutes.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [requestOptions] additional request configuration.
  Future<GetStatusResponse> getStatus({
    required String index,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getStatus`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/status',
      queryParams: {
        'index': index,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetStatusResponse, GetStatusResponse>(
      response,
      'GetStatusResponse',
      growable: true,
    );
  }

  /// Get top countries.
  /// Returns top countries. Limited to the 1,000 most frequent ones.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [limit] Number of records to return (page size).
  /// * [offset] Position of the starting record. Used for paging. 0 is the first record.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetTopCountriesResponse> getTopCountries({
    required String index,
    String? startDate,
    String? endDate,
    int? limit,
    int? offset,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getTopCountries`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/countries',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTopCountriesResponse, GetTopCountriesResponse>(
      response,
      'GetTopCountriesResponse',
      growable: true,
    );
  }

  /// Get top filterable attributes.
  /// Return the most popular [filterable attributes](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/) in the 1,000 most recently used filters.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [search] User query.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [limit] Number of records to return (page size).
  /// * [offset] Position of the starting record. Used for paging. 0 is the first record.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetTopFilterAttributesResponse> getTopFilterAttributes({
    required String index,
    String? search,
    String? startDate,
    String? endDate,
    int? limit,
    int? offset,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getTopFilterAttributes`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/filters',
      queryParams: {
        'index': index,
        if (search != null) 'search': search,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTopFilterAttributesResponse,
        GetTopFilterAttributesResponse>(
      response,
      'GetTopFilterAttributesResponse',
      growable: true,
    );
  }

  /// Get top filter values for an attribute.
  /// Returns the most popular filter values for an attribute in the 1,000 most recently used filters.
  ///
  /// Parameters:
  /// * [attribute] Attribute name.
  /// * [index] Index name to target.
  /// * [search] User query.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [limit] Number of records to return (page size).
  /// * [offset] Position of the starting record. Used for paging. 0 is the first record.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetTopFilterForAttributeResponse> getTopFilterForAttribute({
    required String attribute,
    required String index,
    String? search,
    String? startDate,
    String? endDate,
    int? limit,
    int? offset,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      attribute.isNotEmpty,
      'Parameter `attribute` is required when calling `getTopFilterForAttribute`.',
    );
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getTopFilterForAttribute`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/filters/{attribute}'.replaceAll(
          '{' r'attribute' '}', Uri.encodeComponent(attribute.toString())),
      queryParams: {
        'index': index,
        if (search != null) 'search': search,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTopFilterForAttributeResponse,
        GetTopFilterForAttributeResponse>(
      response,
      'GetTopFilterForAttributeResponse',
      growable: true,
    );
  }

  /// Get top filters for a no result search.
  /// Returns top filters for filter-enabled searches that don't return results. Limited to the 1,000 most recently used filters.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [search] User query.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [limit] Number of records to return (page size).
  /// * [offset] Position of the starting record. Used for paging. 0 is the first record.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetTopFiltersNoResultsResponse> getTopFiltersNoResults({
    required String index,
    String? search,
    String? startDate,
    String? endDate,
    int? limit,
    int? offset,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getTopFiltersNoResults`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/filters/noResults',
      queryParams: {
        'index': index,
        if (search != null) 'search': search,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTopFiltersNoResultsResponse,
        GetTopFiltersNoResultsResponse>(
      response,
      'GetTopFiltersNoResultsResponse',
      growable: true,
    );
  }

  /// Get top hits.
  /// Return the most popular clicked results in the last 1,000 searches.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [search] User query.
  /// * [clickAnalytics] Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [limit] Number of records to return (page size).
  /// * [offset] Position of the starting record. Used for paging. 0 is the first record.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  /// Returns one of types:
  /// - [dynamic]
  Future<dynamic> getTopHits({
    required String index,
    String? search,
    bool? clickAnalytics,
    String? startDate,
    String? endDate,
    int? limit,
    int? offset,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getTopHits`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/hits',
      queryParams: {
        'index': index,
        if (search != null) 'search': search,
        if (clickAnalytics != null) 'clickAnalytics': clickAnalytics,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<dynamic, dynamic>(
      response,
      'dynamic',
      growable: true,
    );
  }

  /// Get top searches.
  /// Returns the most popular of the latest 1,000 searches. For each search, also returns the number of hits.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [clickAnalytics] Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [orderBy] Reorder the results.
  /// * [direction] Sorting direction of the results: ascending or descending.
  /// * [limit] Number of records to return (page size).
  /// * [offset] Position of the starting record. Used for paging. 0 is the first record.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  /// Returns one of types:
  /// - [dynamic]
  Future<dynamic> getTopSearches({
    required String index,
    bool? clickAnalytics,
    String? startDate,
    String? endDate,
    OrderBy? orderBy,
    Direction? direction,
    int? limit,
    int? offset,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getTopSearches`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/searches',
      queryParams: {
        'index': index,
        if (clickAnalytics != null) 'clickAnalytics': clickAnalytics,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (orderBy != null) 'orderBy': orderBy,
        if (direction != null) 'direction': direction,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<dynamic, dynamic>(
      response,
      'dynamic',
      growable: true,
    );
  }

  /// Get user count.
  /// Return the count of unique users.
  ///
  /// Parameters:
  /// * [index] Index name to target.
  /// * [startDate] Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [endDate] End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
  /// * [tags] Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
  /// * [requestOptions] additional request configuration.
  Future<GetUsersCountResponse> getUsersCount({
    required String index,
    String? startDate,
    String? endDate,
    String? tags,
    RequestOptions? requestOptions,
  }) async {
    assert(
      index.isNotEmpty,
      'Parameter `index` is required when calling `getUsersCount`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/2/users/count',
      queryParams: {
        'index': index,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (tags != null) 'tags': tags,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetUsersCountResponse, GetUsersCountResponse>(
      response,
      'GetUsersCountResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> post({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `post`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> put({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `put`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  @override
  void dispose() => _retryStrategy.dispose();
}
