// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import 'package:algolia_client_core/algolia_client_core.dart';
import 'package:algolia_client_ingestion/src/deserialize.dart';
import 'package:algolia_client_ingestion/src/version.dart';

import 'package:algolia_client_ingestion/src/model/action_type.dart';
import 'package:algolia_client_ingestion/src/model/authentication.dart';
import 'package:algolia_client_ingestion/src/model/authentication_create.dart';
import 'package:algolia_client_ingestion/src/model/authentication_create_response.dart';
import 'package:algolia_client_ingestion/src/model/authentication_search.dart';
import 'package:algolia_client_ingestion/src/model/authentication_sort_keys.dart';
import 'package:algolia_client_ingestion/src/model/authentication_type.dart';
import 'package:algolia_client_ingestion/src/model/authentication_update.dart';
import 'package:algolia_client_ingestion/src/model/authentication_update_response.dart';
import 'package:algolia_client_ingestion/src/model/delete_response.dart';
import 'package:algolia_client_ingestion/src/model/destination.dart';
import 'package:algolia_client_ingestion/src/model/destination_create.dart';
import 'package:algolia_client_ingestion/src/model/destination_create_response.dart';
import 'package:algolia_client_ingestion/src/model/destination_search.dart';
import 'package:algolia_client_ingestion/src/model/destination_sort_keys.dart';
import 'package:algolia_client_ingestion/src/model/destination_type.dart';
import 'package:algolia_client_ingestion/src/model/destination_update.dart';
import 'package:algolia_client_ingestion/src/model/destination_update_response.dart';
import 'package:algolia_client_ingestion/src/model/event.dart';
import 'package:algolia_client_ingestion/src/model/event_sort_keys.dart';
import 'package:algolia_client_ingestion/src/model/event_status.dart';
import 'package:algolia_client_ingestion/src/model/event_type.dart';
import 'package:algolia_client_ingestion/src/model/list_authentications_response.dart';
import 'package:algolia_client_ingestion/src/model/list_destinations_response.dart';
import 'package:algolia_client_ingestion/src/model/list_events_response.dart';
import 'package:algolia_client_ingestion/src/model/list_sources_response.dart';
import 'package:algolia_client_ingestion/src/model/list_tasks_response.dart';
import 'package:algolia_client_ingestion/src/model/order_keys.dart';
import 'package:algolia_client_ingestion/src/model/run.dart';
import 'package:algolia_client_ingestion/src/model/run_list_response.dart';
import 'package:algolia_client_ingestion/src/model/run_response.dart';
import 'package:algolia_client_ingestion/src/model/run_sort_keys.dart';
import 'package:algolia_client_ingestion/src/model/run_status.dart';
import 'package:algolia_client_ingestion/src/model/source.dart';
import 'package:algolia_client_ingestion/src/model/source_create.dart';
import 'package:algolia_client_ingestion/src/model/source_create_response.dart';
import 'package:algolia_client_ingestion/src/model/source_search.dart';
import 'package:algolia_client_ingestion/src/model/source_sort_keys.dart';
import 'package:algolia_client_ingestion/src/model/source_type.dart';
import 'package:algolia_client_ingestion/src/model/source_update.dart';
import 'package:algolia_client_ingestion/src/model/source_update_response.dart';
import 'package:algolia_client_ingestion/src/model/task.dart';
import 'package:algolia_client_ingestion/src/model/task_create.dart';
import 'package:algolia_client_ingestion/src/model/task_create_response.dart';
import 'package:algolia_client_ingestion/src/model/task_search.dart';
import 'package:algolia_client_ingestion/src/model/task_sort_keys.dart';
import 'package:algolia_client_ingestion/src/model/task_update.dart';
import 'package:algolia_client_ingestion/src/model/task_update_response.dart';
import 'package:algolia_client_ingestion/src/model/trigger_type.dart';

final class IngestionClient implements ApiClient {
  @override
  final String apiKey;

  @override
  final String appId;

  @override
  final ClientOptions options;

  final String region;

  final RetryStrategy _retryStrategy;

  IngestionClient({
    required this.appId,
    required this.apiKey,
    this.options = const ClientOptions(),
    required this.region,
  }) : _retryStrategy = RetryStrategy.create(
            segment: AgentSegment(value: "Ingestion", version: packageVersion),
            appId: appId,
            apiKey: apiKey,
            options: options,
            defaultHosts: () {
              final allowedRegions = ['eu', 'us'];
              assert(
                allowedRegions.contains(region),
                '`region` is required and must be one of the following: ${allowedRegions.join(', ')}',
              );
              final url =
                  'data.{region}.algolia.com'.replaceAll('{region}', region);
              return [Host(url: url)];
            }) {
    assert(appId.isNotEmpty, '`appId` is missing.');
    assert(apiKey.isNotEmpty, '`apiKey` is missing.');
  }

  /// Create a authentication.
  /// Create a authentication.
  ///
  /// Parameters:
  /// * [authenticationCreate]
  /// * [requestOptions] additional request configuration.
  Future<AuthenticationCreateResponse> createAuthentication({
    required AuthenticationCreate authenticationCreate,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/authentications',
      body: authenticationCreate.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<AuthenticationCreateResponse,
        AuthenticationCreateResponse>(
      response,
      'AuthenticationCreateResponse',
      growable: true,
    );
  }

  /// Create a destination.
  /// Create a destination.
  ///
  /// Parameters:
  /// * [destinationCreate]
  /// * [requestOptions] additional request configuration.
  Future<DestinationCreateResponse> createDestination({
    required DestinationCreate destinationCreate,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/destinations',
      body: destinationCreate.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DestinationCreateResponse, DestinationCreateResponse>(
      response,
      'DestinationCreateResponse',
      growable: true,
    );
  }

  /// Create a source.
  /// Create a source.
  ///
  /// Parameters:
  /// * [sourceCreate]
  /// * [requestOptions] additional request configuration.
  Future<SourceCreateResponse> createSource({
    required SourceCreate sourceCreate,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/sources',
      body: sourceCreate.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SourceCreateResponse, SourceCreateResponse>(
      response,
      'SourceCreateResponse',
      growable: true,
    );
  }

  /// Create a task.
  /// Create a task.
  ///
  /// Parameters:
  /// * [taskCreate]
  /// * [requestOptions] additional request configuration.
  Future<TaskCreateResponse> createTask({
    required TaskCreate taskCreate,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/tasks',
      body: taskCreate.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<TaskCreateResponse, TaskCreateResponse>(
      response,
      'TaskCreateResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> del({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `del`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Delete a authentication.
  /// Soft delete the authentication of the given authenticationID.
  ///
  /// Parameters:
  /// * [authenticationID] The authentication UUID.
  /// * [requestOptions] additional request configuration.
  Future<DeleteResponse> deleteAuthentication({
    required String authenticationID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      authenticationID.isNotEmpty,
      'Parameter `authenticationID` is required when calling `deleteAuthentication`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/authentications/{authenticationID}'.replaceAll(
          '{' r'authenticationID' '}',
          Uri.encodeComponent(authenticationID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteResponse, DeleteResponse>(
      response,
      'DeleteResponse',
      growable: true,
    );
  }

  /// Delete a destination.
  /// Soft delete the destination of the given destinationID.
  ///
  /// Parameters:
  /// * [destinationID] The destination UUID.
  /// * [requestOptions] additional request configuration.
  Future<DeleteResponse> deleteDestination({
    required String destinationID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      destinationID.isNotEmpty,
      'Parameter `destinationID` is required when calling `deleteDestination`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/destinations/{destinationID}'.replaceAll(
          '{' r'destinationID' '}',
          Uri.encodeComponent(destinationID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteResponse, DeleteResponse>(
      response,
      'DeleteResponse',
      growable: true,
    );
  }

  /// Delete a source.
  /// Soft delete the source of the given sourceID.
  ///
  /// Parameters:
  /// * [sourceID] The source UUID.
  /// * [requestOptions] additional request configuration.
  Future<DeleteResponse> deleteSource({
    required String sourceID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      sourceID.isNotEmpty,
      'Parameter `sourceID` is required when calling `deleteSource`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/sources/{sourceID}'.replaceAll(
          '{' r'sourceID' '}', Uri.encodeComponent(sourceID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteResponse, DeleteResponse>(
      response,
      'DeleteResponse',
      growable: true,
    );
  }

  /// Delete a task.
  /// Soft delete the task of the given taskID.
  ///
  /// Parameters:
  /// * [taskID] The task UUID.
  /// * [requestOptions] additional request configuration.
  Future<DeleteResponse> deleteTask({
    required String taskID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      taskID.isNotEmpty,
      'Parameter `taskID` is required when calling `deleteTask`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/tasks/{taskID}'.replaceAll(
          '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteResponse, DeleteResponse>(
      response,
      'DeleteResponse',
      growable: true,
    );
  }

  /// Disable a task.
  /// Disable the task of the given taskID.
  ///
  /// Parameters:
  /// * [taskID] The task UUID.
  /// * [requestOptions] additional request configuration.
  Future<TaskUpdateResponse> disableTask({
    required String taskID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      taskID.isNotEmpty,
      'Parameter `taskID` is required when calling `disableTask`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/tasks/{taskID}/disable'.replaceAll(
          '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<TaskUpdateResponse, TaskUpdateResponse>(
      response,
      'TaskUpdateResponse',
      growable: true,
    );
  }

  /// Enable a task.
  /// Enable the task of the given taskID.
  ///
  /// Parameters:
  /// * [taskID] The task UUID.
  /// * [requestOptions] additional request configuration.
  Future<TaskUpdateResponse> enableTask({
    required String taskID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      taskID.isNotEmpty,
      'Parameter `taskID` is required when calling `enableTask`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/tasks/{taskID}/enable'.replaceAll(
          '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<TaskUpdateResponse, TaskUpdateResponse>(
      response,
      'TaskUpdateResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> get({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `get`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Get a authentication.
  /// Get the authentication of the given authenticationID.
  ///
  /// Parameters:
  /// * [authenticationID] The authentication UUID.
  /// * [requestOptions] additional request configuration.
  Future<Authentication> getAuthentication({
    required String authenticationID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      authenticationID.isNotEmpty,
      'Parameter `authenticationID` is required when calling `getAuthentication`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/authentications/{authenticationID}'.replaceAll(
          '{' r'authenticationID' '}',
          Uri.encodeComponent(authenticationID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Authentication, Authentication>(
      response,
      'Authentication',
      growable: true,
    );
  }

  /// Get a list of authentications.
  /// Get a list of authentications for the given query parameters, with pagination details.
  ///
  /// Parameters:
  /// * [itemsPerPage] The number of items per page to return.
  /// * [page] The page number to fetch, starting at 1.
  /// * [type] The type of the authentications to retrieve.
  /// * [platform] The platform of the authentications to retrieve. - one of types: [Platform], [PlatformNone],
  /// * [sort] The key by which the list should be sorted.
  /// * [order] The order of the returned list.
  /// * [requestOptions] additional request configuration.
  Future<ListAuthenticationsResponse> getAuthentications({
    int? itemsPerPage,
    int? page,
    List<AuthenticationType>? type,
    Iterable<dynamic>? platform,
    AuthenticationSortKeys? sort,
    OrderKeys? order,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/authentications',
      queryParams: {
        if (itemsPerPage != null) 'itemsPerPage': itemsPerPage,
        if (page != null) 'page': page,
        if (type != null) 'type': type.join(','),
        if (platform != null) 'platform': platform.join(','),
        if (sort != null) 'sort': sort,
        if (order != null) 'order': order,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListAuthenticationsResponse,
        ListAuthenticationsResponse>(
      response,
      'ListAuthenticationsResponse',
      growable: true,
    );
  }

  /// Get a destination.
  /// Get the destination of the given destinationID.
  ///
  /// Parameters:
  /// * [destinationID] The destination UUID.
  /// * [requestOptions] additional request configuration.
  Future<Destination> getDestination({
    required String destinationID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      destinationID.isNotEmpty,
      'Parameter `destinationID` is required when calling `getDestination`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/destinations/{destinationID}'.replaceAll(
          '{' r'destinationID' '}',
          Uri.encodeComponent(destinationID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Destination, Destination>(
      response,
      'Destination',
      growable: true,
    );
  }

  /// Get a list of destinations.
  /// Get a list of destinations for the given query parameters, with pagination details.
  ///
  /// Parameters:
  /// * [itemsPerPage] The number of items per page to return.
  /// * [page] The page number to fetch, starting at 1.
  /// * [type] The type of the destinations to retrive.
  /// * [authenticationID] The authenticationIDs of the destinations to retrive.
  /// * [sort] The key by which the list should be sorted.
  /// * [order] The order of the returned list.
  /// * [requestOptions] additional request configuration.
  Future<ListDestinationsResponse> getDestinations({
    int? itemsPerPage,
    int? page,
    List<DestinationType>? type,
    List<String>? authenticationID,
    DestinationSortKeys? sort,
    OrderKeys? order,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/destinations',
      queryParams: {
        if (itemsPerPage != null) 'itemsPerPage': itemsPerPage,
        if (page != null) 'page': page,
        if (type != null) 'type': type.join(','),
        if (authenticationID != null)
          'authenticationID': authenticationID.join(','),
        if (sort != null) 'sort': sort,
        if (order != null) 'order': order,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListDestinationsResponse, ListDestinationsResponse>(
      response,
      'ListDestinationsResponse',
      growable: true,
    );
  }

  /// Get an event.
  /// Get a single event for a specific runID.
  ///
  /// Parameters:
  /// * [runID] The run UUID.
  /// * [eventID] The event UUID.
  /// * [requestOptions] additional request configuration.
  Future<Event> getEvent({
    required String runID,
    required String eventID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      runID.isNotEmpty,
      'Parameter `runID` is required when calling `getEvent`.',
    );
    assert(
      eventID.isNotEmpty,
      'Parameter `eventID` is required when calling `getEvent`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/runs/{runID}/events/{eventID}'
          .replaceAll('{' r'runID' '}', Uri.encodeComponent(runID.toString()))
          .replaceAll(
              '{' r'eventID' '}', Uri.encodeComponent(eventID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Event, Event>(
      response,
      'Event',
      growable: true,
    );
  }

  /// Get a list of events.
  /// Get a list of events associated to the given runID, for the given query parameters.
  ///
  /// Parameters:
  /// * [runID] The run UUID.
  /// * [itemsPerPage] The number of items per page to return.
  /// * [page] The page number to fetch, starting at 1.
  /// * [status] Filter the status of the events.
  /// * [type] Filter the type of the events.
  /// * [sort] The key by which the list should be sorted.
  /// * [order] The order of the returned list.
  /// * [requestOptions] additional request configuration.
  Future<ListEventsResponse> getEvents({
    required String runID,
    int? itemsPerPage,
    int? page,
    List<EventStatus>? status,
    List<EventType>? type,
    EventSortKeys? sort,
    OrderKeys? order,
    RequestOptions? requestOptions,
  }) async {
    assert(
      runID.isNotEmpty,
      'Parameter `runID` is required when calling `getEvents`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/runs/{runID}/events'
          .replaceAll('{' r'runID' '}', Uri.encodeComponent(runID.toString())),
      queryParams: {
        if (itemsPerPage != null) 'itemsPerPage': itemsPerPage,
        if (page != null) 'page': page,
        if (status != null) 'status': status.join(','),
        if (type != null) 'type': type.join(','),
        if (sort != null) 'sort': sort,
        if (order != null) 'order': order,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListEventsResponse, ListEventsResponse>(
      response,
      'ListEventsResponse',
      growable: true,
    );
  }

  /// Get a run.
  /// Get a single run for the given ID.
  ///
  /// Parameters:
  /// * [runID] The run UUID.
  /// * [requestOptions] additional request configuration.
  Future<Run> getRun({
    required String runID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      runID.isNotEmpty,
      'Parameter `runID` is required when calling `getRun`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/runs/{runID}'
          .replaceAll('{' r'runID' '}', Uri.encodeComponent(runID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Run, Run>(
      response,
      'Run',
      growable: true,
    );
  }

  /// Get a list of runs.
  /// Get a list of runs for the given query parameters, with pagination details.
  ///
  /// Parameters:
  /// * [itemsPerPage] The number of items per page to return.
  /// * [page] The page number to fetch, starting at 1.
  /// * [status] Filter the status of the runs.
  /// * [taskID] Filter by taskID.
  /// * [sort] The key by which the list should be sorted.
  /// * [order] The order of the returned list.
  /// * [startDate] The start date (in RFC3339 format) of the runs fetching window. Defaults to 'now'-7 days if omitted. The timespan between `startDate` and `endDate` must be smaller than 7 days.
  /// * [endDate] The end date (in RFC3339 format) of the runs fetching window. Defaults to 'now' days if omitted. The timespan between `startDate` and `endDate` must be smaller than 7 days.
  /// * [requestOptions] additional request configuration.
  Future<RunListResponse> getRuns({
    int? itemsPerPage,
    int? page,
    List<RunStatus>? status,
    String? taskID,
    RunSortKeys? sort,
    OrderKeys? order,
    String? startDate,
    String? endDate,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/runs',
      queryParams: {
        if (itemsPerPage != null) 'itemsPerPage': itemsPerPage,
        if (page != null) 'page': page,
        if (status != null) 'status': status.join(','),
        if (taskID != null) 'taskID': taskID,
        if (sort != null) 'sort': sort,
        if (order != null) 'order': order,
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<RunListResponse, RunListResponse>(
      response,
      'RunListResponse',
      growable: true,
    );
  }

  /// Get a source.
  /// Get the source of the given sourceID.
  ///
  /// Parameters:
  /// * [sourceID] The source UUID.
  /// * [requestOptions] additional request configuration.
  Future<Source> getSource({
    required String sourceID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      sourceID.isNotEmpty,
      'Parameter `sourceID` is required when calling `getSource`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/sources/{sourceID}'.replaceAll(
          '{' r'sourceID' '}', Uri.encodeComponent(sourceID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Source, Source>(
      response,
      'Source',
      growable: true,
    );
  }

  /// Get a list of sources.
  /// Get a list of sources for the given query parameters, with pagination details.
  ///
  /// Parameters:
  /// * [itemsPerPage] The number of items per page to return.
  /// * [page] The page number to fetch, starting at 1.
  /// * [type] The type of the sources to retrieve.
  /// * [authenticationID] The authenticationIDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
  /// * [sort] The key by which the list should be sorted.
  /// * [order] The order of the returned list.
  /// * [requestOptions] additional request configuration.
  Future<ListSourcesResponse> getSources({
    int? itemsPerPage,
    int? page,
    List<SourceType>? type,
    List<String>? authenticationID,
    SourceSortKeys? sort,
    OrderKeys? order,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/sources',
      queryParams: {
        if (itemsPerPage != null) 'itemsPerPage': itemsPerPage,
        if (page != null) 'page': page,
        if (type != null) 'type': type.join(','),
        if (authenticationID != null)
          'authenticationID': authenticationID.join(','),
        if (sort != null) 'sort': sort,
        if (order != null) 'order': order,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListSourcesResponse, ListSourcesResponse>(
      response,
      'ListSourcesResponse',
      growable: true,
    );
  }

  /// Get a task.
  /// Get the task of the given taskID.
  ///
  /// Parameters:
  /// * [taskID] The task UUID.
  /// * [requestOptions] additional request configuration.
  Future<Task> getTask({
    required String taskID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      taskID.isNotEmpty,
      'Parameter `taskID` is required when calling `getTask`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/tasks/{taskID}'.replaceAll(
          '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Task, Task>(
      response,
      'Task',
      growable: true,
    );
  }

  /// Get a list of tasks.
  /// Get a list of tasks for the given query parameters, with pagination details.
  ///
  /// Parameters:
  /// * [itemsPerPage] The number of items per page to return.
  /// * [page] The page number to fetch, starting at 1.
  /// * [action] The action of the tasks to retrieve.
  /// * [enabled] Whether the task is enabled or not.
  /// * [sourceID] The sourceIDs of the tasks to retrive.
  /// * [destinationID] The destinationIDs of the tasks to retrive.
  /// * [triggerType] The trigger type of the task.
  /// * [sort] The key by which the list should be sorted.
  /// * [order] The order of the returned list.
  /// * [requestOptions] additional request configuration.
  Future<ListTasksResponse> getTasks({
    int? itemsPerPage,
    int? page,
    List<ActionType>? action,
    bool? enabled,
    List<String>? sourceID,
    List<String>? destinationID,
    List<TriggerType>? triggerType,
    TaskSortKeys? sort,
    OrderKeys? order,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/tasks',
      queryParams: {
        if (itemsPerPage != null) 'itemsPerPage': itemsPerPage,
        if (page != null) 'page': page,
        if (action != null) 'action': action.join(','),
        if (enabled != null) 'enabled': enabled,
        if (sourceID != null) 'sourceID': sourceID.join(','),
        if (destinationID != null) 'destinationID': destinationID.join(','),
        if (triggerType != null) 'triggerType': triggerType.join(','),
        if (sort != null) 'sort': sort,
        if (order != null) 'order': order,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListTasksResponse, ListTasksResponse>(
      response,
      'ListTasksResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> post({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `post`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> put({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `put`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Run a task.
  /// Run the task of the given taskID.
  ///
  /// Parameters:
  /// * [taskID] The task UUID.
  /// * [requestOptions] additional request configuration.
  Future<RunResponse> runTask({
    required String taskID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      taskID.isNotEmpty,
      'Parameter `taskID` is required when calling `runTask`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/tasks/{taskID}/run'.replaceAll(
          '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<RunResponse, RunResponse>(
      response,
      'RunResponse',
      growable: true,
    );
  }

  /// Search among authentications.
  /// Search among authentications with a defined set of parameters.
  ///
  /// Parameters:
  /// * [authenticationSearch]
  /// * [requestOptions] additional request configuration.
  Future<List<Authentication>> searchAuthentications({
    required AuthenticationSearch authenticationSearch,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/authentications/search',
      body: authenticationSearch.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<List<Authentication>, Authentication>(
      response,
      'List<Authentication>',
      growable: true,
    );
  }

  /// Search among destinations.
  /// Search among destinations with a defined set of parameters.
  ///
  /// Parameters:
  /// * [destinationSearch]
  /// * [requestOptions] additional request configuration.
  Future<List<Destination>> searchDestinations({
    required DestinationSearch destinationSearch,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/destinations/search',
      body: destinationSearch.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<List<Destination>, Destination>(
      response,
      'List<Destination>',
      growable: true,
    );
  }

  /// Search among sources.
  /// Search among sources with a defined set of parameters.
  ///
  /// Parameters:
  /// * [sourceSearch]
  /// * [requestOptions] additional request configuration.
  Future<List<Source>> searchSources({
    required SourceSearch sourceSearch,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/sources/search',
      body: sourceSearch.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<List<Source>, Source>(
      response,
      'List<Source>',
      growable: true,
    );
  }

  /// Search among tasks.
  /// Search among tasks with a defined set of parameters.
  ///
  /// Parameters:
  /// * [taskSearch]
  /// * [requestOptions] additional request configuration.
  Future<List<Task>> searchTasks({
    required TaskSearch taskSearch,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/tasks/search',
      body: taskSearch.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<List<Task>, Task>(
      response,
      'List<Task>',
      growable: true,
    );
  }

  /// Update a authentication.
  /// Update the authentication of the given authenticationID.
  ///
  /// Parameters:
  /// * [authenticationID] The authentication UUID.
  /// * [authenticationUpdate]
  /// * [requestOptions] additional request configuration.
  Future<AuthenticationUpdateResponse> updateAuthentication({
    required String authenticationID,
    required AuthenticationUpdate authenticationUpdate,
    RequestOptions? requestOptions,
  }) async {
    assert(
      authenticationID.isNotEmpty,
      'Parameter `authenticationID` is required when calling `updateAuthentication`.',
    );
    final request = ApiRequest(
      method: RequestMethod.patch,
      path: r'/1/authentications/{authenticationID}'.replaceAll(
          '{' r'authenticationID' '}',
          Uri.encodeComponent(authenticationID.toString())),
      body: authenticationUpdate.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<AuthenticationUpdateResponse,
        AuthenticationUpdateResponse>(
      response,
      'AuthenticationUpdateResponse',
      growable: true,
    );
  }

  /// Update a destination.
  /// Update the destination of the given destinationID.
  ///
  /// Parameters:
  /// * [destinationID] The destination UUID.
  /// * [destinationUpdate]
  /// * [requestOptions] additional request configuration.
  Future<DestinationUpdateResponse> updateDestination({
    required String destinationID,
    required DestinationUpdate destinationUpdate,
    RequestOptions? requestOptions,
  }) async {
    assert(
      destinationID.isNotEmpty,
      'Parameter `destinationID` is required when calling `updateDestination`.',
    );
    final request = ApiRequest(
      method: RequestMethod.patch,
      path: r'/1/destinations/{destinationID}'.replaceAll(
          '{' r'destinationID' '}',
          Uri.encodeComponent(destinationID.toString())),
      body: destinationUpdate.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DestinationUpdateResponse, DestinationUpdateResponse>(
      response,
      'DestinationUpdateResponse',
      growable: true,
    );
  }

  /// Update a source.
  /// Update the source of the given sourceID.
  ///
  /// Parameters:
  /// * [sourceID] The source UUID.
  /// * [sourceUpdate]
  /// * [requestOptions] additional request configuration.
  Future<SourceUpdateResponse> updateSource({
    required String sourceID,
    required SourceUpdate sourceUpdate,
    RequestOptions? requestOptions,
  }) async {
    assert(
      sourceID.isNotEmpty,
      'Parameter `sourceID` is required when calling `updateSource`.',
    );
    final request = ApiRequest(
      method: RequestMethod.patch,
      path: r'/1/sources/{sourceID}'.replaceAll(
          '{' r'sourceID' '}', Uri.encodeComponent(sourceID.toString())),
      body: sourceUpdate.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SourceUpdateResponse, SourceUpdateResponse>(
      response,
      'SourceUpdateResponse',
      growable: true,
    );
  }

  /// Update a task.
  /// Update the task of the given taskID.
  ///
  /// Parameters:
  /// * [taskID] The task UUID.
  /// * [taskUpdate]
  /// * [requestOptions] additional request configuration.
  Future<TaskUpdateResponse> updateTask({
    required String taskID,
    required TaskUpdate taskUpdate,
    RequestOptions? requestOptions,
  }) async {
    assert(
      taskID.isNotEmpty,
      'Parameter `taskID` is required when calling `updateTask`.',
    );
    final request = ApiRequest(
      method: RequestMethod.patch,
      path: r'/1/tasks/{taskID}'.replaceAll(
          '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
      body: taskUpdate.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<TaskUpdateResponse, TaskUpdateResponse>(
      response,
      'TaskUpdateResponse',
      growable: true,
    );
  }

  @override
  void dispose() => _retryStrategy.dispose();
}
