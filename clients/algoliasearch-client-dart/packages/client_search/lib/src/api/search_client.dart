// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import 'package:algolia_client_core/algolia_client_core.dart';
import 'package:algolia_client_search/src/deserialize.dart';
import 'package:algolia_client_search/src/version.dart';

import 'package:algolia_client_search/src/model/add_api_key_response.dart';
import 'package:algolia_client_search/src/model/api_key.dart';
import 'package:algolia_client_search/src/model/assign_user_id_params.dart';
import 'package:algolia_client_search/src/model/batch_assign_user_ids_params.dart';
import 'package:algolia_client_search/src/model/batch_dictionary_entries_params.dart';
import 'package:algolia_client_search/src/model/batch_params.dart';
import 'package:algolia_client_search/src/model/batch_response.dart';
import 'package:algolia_client_search/src/model/batch_write_params.dart';
import 'package:algolia_client_search/src/model/browse_response.dart';
import 'package:algolia_client_search/src/model/created_at_response.dart';
import 'package:algolia_client_search/src/model/delete_api_key_response.dart';
import 'package:algolia_client_search/src/model/delete_by_params.dart';
import 'package:algolia_client_search/src/model/delete_source_response.dart';
import 'package:algolia_client_search/src/model/deleted_at_response.dart';
import 'package:algolia_client_search/src/model/dictionary_settings_params.dart';
import 'package:algolia_client_search/src/model/dictionary_type.dart';
import 'package:algolia_client_search/src/model/get_api_key_response.dart';
import 'package:algolia_client_search/src/model/get_dictionary_settings_response.dart';
import 'package:algolia_client_search/src/model/get_logs_response.dart';
import 'package:algolia_client_search/src/model/get_objects_params.dart';
import 'package:algolia_client_search/src/model/get_objects_response.dart';
import 'package:algolia_client_search/src/model/get_task_response.dart';
import 'package:algolia_client_search/src/model/get_top_user_ids_response.dart';
import 'package:algolia_client_search/src/model/has_pending_mappings_response.dart';
import 'package:algolia_client_search/src/model/index_settings.dart';
import 'package:algolia_client_search/src/model/languages.dart';
import 'package:algolia_client_search/src/model/list_api_keys_response.dart';
import 'package:algolia_client_search/src/model/list_clusters_response.dart';
import 'package:algolia_client_search/src/model/list_indices_response.dart';
import 'package:algolia_client_search/src/model/list_user_ids_response.dart';
import 'package:algolia_client_search/src/model/log_type.dart';
import 'package:algolia_client_search/src/model/model_source.dart';
import 'package:algolia_client_search/src/model/multiple_batch_response.dart';
import 'package:algolia_client_search/src/model/operation_index_params.dart';
import 'package:algolia_client_search/src/model/remove_user_id_response.dart';
import 'package:algolia_client_search/src/model/replace_source_response.dart';
import 'package:algolia_client_search/src/model/rule.dart';
import 'package:algolia_client_search/src/model/save_object_response.dart';
import 'package:algolia_client_search/src/model/save_synonym_response.dart';
import 'package:algolia_client_search/src/model/search_dictionary_entries_params.dart';
import 'package:algolia_client_search/src/model/search_for_facet_values_request.dart';
import 'package:algolia_client_search/src/model/search_for_facet_values_response.dart';
import 'package:algolia_client_search/src/model/search_method_params.dart';
import 'package:algolia_client_search/src/model/search_response.dart';
import 'package:algolia_client_search/src/model/search_responses.dart';
import 'package:algolia_client_search/src/model/search_rules_params.dart';
import 'package:algolia_client_search/src/model/search_rules_response.dart';
import 'package:algolia_client_search/src/model/search_synonyms_params.dart';
import 'package:algolia_client_search/src/model/search_synonyms_response.dart';
import 'package:algolia_client_search/src/model/search_user_ids_params.dart';
import 'package:algolia_client_search/src/model/search_user_ids_response.dart';
import 'package:algolia_client_search/src/model/synonym_hit.dart';
import 'package:algolia_client_search/src/model/synonym_type.dart';
import 'package:algolia_client_search/src/model/update_api_key_response.dart';
import 'package:algolia_client_search/src/model/updated_at_response.dart';
import 'package:algolia_client_search/src/model/updated_at_with_object_id_response.dart';
import 'package:algolia_client_search/src/model/updated_rule_response.dart';
import 'package:algolia_client_search/src/model/user_id.dart';

final class SearchClient implements ApiClient {
  @override
  final String apiKey;

  @override
  final String appId;

  @override
  final ClientOptions options;

  final RetryStrategy _retryStrategy;

  SearchClient({
    required this.appId,
    required this.apiKey,
    this.options = const ClientOptions(),
  }) : _retryStrategy = RetryStrategy.create(
          segment: AgentSegment(value: "Search", version: packageVersion),
          appId: appId,
          apiKey: apiKey,
          options: options,
          defaultHosts: () => [
                Host(url: '$appId-dsn.algolia.net', callType: CallType.read),
                Host(url: '$appId.algolia.net', callType: CallType.write),
              ] +
              [
                Host(url: '$appId-1.algolianet.com'),
                Host(url: '$appId-2.algolianet.com'),
                Host(url: '$appId-3.algolianet.com')
              ]
            ..shuffle(),
        ) {
    assert(appId.isNotEmpty, '`appId` is missing.');
    assert(apiKey.isNotEmpty, '`apiKey` is missing.');
  }

  /// Create an API key.
  /// Add a new API Key with specific permissions/restrictions.
  ///
  /// Parameters:
  /// * [apiKey]
  /// * [requestOptions] additional request configuration.
  Future<AddApiKeyResponse> addApiKey({
    required ApiKey apiKey,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/keys',
      body: apiKey.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<AddApiKeyResponse, AddApiKeyResponse>(
      response,
      'AddApiKeyResponse',
      growable: true,
    );
  }

  /// Add or replace an object.
  /// Add or replace an object with a given object ID. If the object does not exist, it will be created. If it already exists, it will be replaced.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [body] - The Algolia object.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtWithObjectIdResponse> addOrUpdateObject({
    required String indexName,
    required String objectID,
    required Object body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `addOrUpdateObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `addOrUpdateObject`.',
    );
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body` is required when calling `addOrUpdateObject`.',
      );
    }
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body ` is required when calling `addOrUpdateObject`.',
      );
    }
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtWithObjectIdResponse,
        UpdatedAtWithObjectIdResponse>(
      response,
      'UpdatedAtWithObjectIdResponse',
      growable: true,
    );
  }

  /// Add a single source.
  /// Add a single source to the list of allowed sources.
  ///
  /// Parameters:
  /// * [modelSource] - The source to add.
  /// * [requestOptions] additional request configuration.
  Future<CreatedAtResponse> appendSource({
    required ModelSource modelSource,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/security/sources/append',
      body: modelSource.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<CreatedAtResponse, CreatedAtResponse>(
      response,
      'CreatedAtResponse',
      growable: true,
    );
  }

  /// Assign or Move userID.
  /// Assign or Move a userID to a cluster. The time it takes to migrate (move) a user is proportional to the amount of data linked to the userID. Upon success, the response is 200 OK. A successful response indicates that the operation has been taken into account, and the userID is directly usable.
  ///
  /// Parameters:
  /// * [xAlgoliaUserID] - userID to assign.
  /// * [assignUserIdParams]
  /// * [requestOptions] additional request configuration.
  Future<CreatedAtResponse> assignUserId({
    required String xAlgoliaUserID,
    required AssignUserIdParams assignUserIdParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      xAlgoliaUserID.isNotEmpty,
      'Parameter `xAlgoliaUserID` is required when calling `assignUserId`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/clusters/mapping',
      headers: {
        'X-Algolia-User-ID': xAlgoliaUserID,
      },
      body: assignUserIdParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<CreatedAtResponse, CreatedAtResponse>(
      response,
      'CreatedAtResponse',
      growable: true,
    );
  }

  /// Batch operations to one index.
  /// Perform multiple write operations targeting one index, in a single API call.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [batchWriteParams]
  /// * [requestOptions] additional request configuration.
  Future<BatchResponse> batch({
    required String indexName,
    required BatchWriteParams batchWriteParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `batch`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/batch'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: batchWriteParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<BatchResponse, BatchResponse>(
      response,
      'BatchResponse',
      growable: true,
    );
  }

  /// Batch assign userIDs.
  /// Assign multiple userIDs to a cluster. Upon success, the response is 200 OK. A successful response indicates that the operation has been taken into account, and the userIDs are directly usable.
  ///
  /// Parameters:
  /// * [xAlgoliaUserID] - userID to assign.
  /// * [batchAssignUserIdsParams]
  /// * [requestOptions] additional request configuration.
  Future<CreatedAtResponse> batchAssignUserIds({
    required String xAlgoliaUserID,
    required BatchAssignUserIdsParams batchAssignUserIdsParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      xAlgoliaUserID.isNotEmpty,
      'Parameter `xAlgoliaUserID` is required when calling `batchAssignUserIds`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/clusters/mapping/batch',
      headers: {
        'X-Algolia-User-ID': xAlgoliaUserID,
      },
      body: batchAssignUserIdsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<CreatedAtResponse, CreatedAtResponse>(
      response,
      'CreatedAtResponse',
      growable: true,
    );
  }

  /// Batch dictionary entries.
  /// Send a batch of dictionary entries.
  ///
  /// Parameters:
  /// * [dictionaryName] - The dictionary to search in.
  /// * [batchDictionaryEntriesParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> batchDictionaryEntries({
    required DictionaryType dictionaryName,
    required BatchDictionaryEntriesParams batchDictionaryEntriesParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/dictionaries/{dictionaryName}/batch'.replaceAll(
          '{' r'dictionaryName' '}',
          Uri.encodeComponent(dictionaryName.toString())),
      body: batchDictionaryEntriesParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Retrieve all index content.
  /// This method allows you to retrieve all index content. It can retrieve up to 1,000 records per call and supports full text search and filters. For performance reasons, some features are not supported, including `distinct`, sorting by `typos`, `words` or `geo distance`. When there is more content to be browsed, the response contains a cursor field. This cursor has to be passed to the subsequent call to browse in order to get the next page of results. When the end of the index has been reached, the cursor field is absent from the response.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [browseParams]
  /// * [requestOptions] additional request configuration.
  Future<BrowseResponse> browse({
    required String indexName,
    dynamic browseParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `browse`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/browse'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: browseParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<BrowseResponse, BrowseResponse>(
      response,
      'BrowseResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] - The path of the API endpoint to target, anything after the /1 needs to be specified.
  /// * [parameters] - Query parameters to be applied to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> callGet({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `callGet`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1{path}'
          .replaceAll('{' r'path' '}', Uri.encodeComponent(path.toString())),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Clear all synonyms.
  /// Remove all synonyms from an index.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [forwardToReplicas] - When true, changes are also propagated to replicas of the given indexName.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> clearAllSynonyms({
    required String indexName,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `clearAllSynonyms`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/synonyms/clear'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Clear all objects from an index.
  /// Delete an index's content, but leave settings and index-specific API keys untouched.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> clearObjects({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `clearObjects`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/clear'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Clear Rules.
  /// Delete all Rules in the index.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [forwardToReplicas] - When true, changes are also propagated to replicas of the given indexName.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> clearRules({
    required String indexName,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `clearRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/rules/clear'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] - The path of the API endpoint to target, anything after the /1 needs to be specified.
  /// * [parameters] - Query parameters to be applied to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> del({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `del`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1{path}'
          .replaceAll('{' r'path' '}', Uri.encodeComponent(path.toString())),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Delete an API key.
  /// Delete an existing API Key.
  ///
  /// Parameters:
  /// * [key] - API Key string.
  /// * [requestOptions] additional request configuration.
  Future<DeleteApiKeyResponse> deleteApiKey({
    required String key,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `deleteApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/keys/{key}'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteApiKeyResponse, DeleteApiKeyResponse>(
      response,
      'DeleteApiKeyResponse',
      growable: true,
    );
  }

  /// Delete all records matching the query.
  /// Remove all objects matching a filter (including geo filters). This method enables you to delete one or more objects based on filters (numeric, facet, tag or geo queries). It doesn't accept empty filters or a query.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [deleteByParams]
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteBy({
    required String indexName,
    required DeleteByParams deleteByParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteBy`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/deleteByQuery'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: deleteByParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Delete index.
  /// Delete an existing index.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteIndex({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteIndex`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Delete an object.
  /// Delete an existing object.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteObject({
    required String indexName,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteObject`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Delete a rule.
  /// Delete the Rule with the specified objectID.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [forwardToReplicas] - When true, changes are also propagated to replicas of the given indexName.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> deleteRule({
    required String indexName,
    required String objectID,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Remove a single source.
  /// Remove a single source from the list of allowed sources.
  ///
  /// Parameters:
  /// * [source_] - The IP range of the source.
  /// * [requestOptions] additional request configuration.
  Future<DeleteSourceResponse> deleteSource({
    required String source_,
    RequestOptions? requestOptions,
  }) async {
    assert(
      source_.isNotEmpty,
      'Parameter `source_` is required when calling `deleteSource`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/security/sources/{source}'.replaceAll(
          '{' r'source' '}', Uri.encodeComponent(source_.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteSourceResponse, DeleteSourceResponse>(
      response,
      'DeleteSourceResponse',
      growable: true,
    );
  }

  /// Delete synonym.
  /// Delete a single synonyms set, identified by the given objectID.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [forwardToReplicas] - When true, changes are also propagated to replicas of the given indexName.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteSynonym({
    required String indexName,
    required String objectID,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteSynonym`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteSynonym`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/synonyms/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Get an API key.
  /// Get the permissions of an API key.
  ///
  /// Parameters:
  /// * [key] - API Key string.
  /// * [requestOptions] additional request configuration.
  Future<GetApiKeyResponse> getApiKey({
    required String key,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `getApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/keys/{key}'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetApiKeyResponse, GetApiKeyResponse>(
      response,
      'GetApiKeyResponse',
      growable: true,
    );
  }

  /// List available languages.
  /// List dictionaries supported per language.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<Map<String, Languages>> getDictionaryLanguages({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/dictionaries/*/languages',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Map<String, Languages>, Languages>(
      response,
      'Map<String, Languages>',
      growable: true,
    );
  }

  /// Retrieve dictionaries settings.
  /// Retrieve dictionaries settings. The API stores languages whose standard entries are disabled. Fetch settings does not return false values.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<GetDictionarySettingsResponse> getDictionarySettings({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/dictionaries/*/settings',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetDictionarySettingsResponse,
        GetDictionarySettingsResponse>(
      response,
      'GetDictionarySettingsResponse',
      growable: true,
    );
  }

  /// Return the latest log entries.
  /// Return the latest log entries.
  ///
  /// Parameters:
  /// * [offset] - First entry to retrieve (zero-based). Log entries are sorted by decreasing date, therefore 0 designates the most recent log entry.
  /// * [length] - Maximum number of entries to retrieve. The maximum allowed value is 1000.
  /// * [indexName] - Index for which log entries should be retrieved. When omitted, log entries are retrieved across all indices.
  /// * [type] - Type of log entries to retrieve. When omitted, all log entries are retrieved.
  /// * [requestOptions] additional request configuration.
  Future<GetLogsResponse> getLogs({
    int? offset = 0,
    int? length = 10,
    String? indexName,
    LogType? type,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/logs',
      queryParams: {
        if (offset != null) 'offset': offset,
        if (length != null) 'length': length,
        if (indexName != null) 'indexName': indexName,
        if (type != null) 'type': type,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetLogsResponse, GetLogsResponse>(
      response,
      'GetLogsResponse',
      growable: true,
    );
  }

  /// Retrieve an object.
  /// Retrieve one object from the index.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [attributesToRetrieve] - List of attributes to retrieve. If not specified, all retrievable attributes are returned.
  /// * [requestOptions] additional request configuration.
  Future<Map<String, String>> getObject({
    required String indexName,
    required String objectID,
    List<String>? attributesToRetrieve,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getObject`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (attributesToRetrieve != null)
          'attributesToRetrieve': attributesToRetrieve.join(','),
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Map<String, String>, String>(
      response,
      'Map<String, String>',
      growable: true,
    );
  }

  /// Retrieve one or more objects.
  /// Retrieve one or more objects, potentially from different indices, in a single API call.
  ///
  /// Parameters:
  /// * [getObjectsParams] - The Algolia object.
  /// * [requestOptions] additional request configuration.
  Future<GetObjectsResponse> getObjects({
    required GetObjectsParams getObjectsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/objects',
      isRead: true,
      body: getObjectsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetObjectsResponse, GetObjectsResponse>(
      response,
      'GetObjectsResponse',
      growable: true,
    );
  }

  /// Get a rule.
  /// Retrieve the Rule with the specified objectID.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [requestOptions] additional request configuration.
  Future<Rule> getRule({
    required String indexName,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Rule, Rule>(
      response,
      'Rule',
      growable: true,
    );
  }

  /// Retrieve settings of an index.
  /// Retrieve settings of an index.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [requestOptions] additional request configuration.
  Future<IndexSettings> getSettings({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getSettings`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/settings'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<IndexSettings, IndexSettings>(
      response,
      'IndexSettings',
      growable: true,
    );
  }

  /// List all allowed sources.
  /// List all allowed sources.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<List<ModelSource>> getSources({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/security/sources',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<List<ModelSource>, ModelSource>(
      response,
      'List<ModelSource>',
      growable: true,
    );
  }

  /// Get synonym.
  /// Fetch a synonym object identified by its objectID.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [requestOptions] additional request configuration.
  Future<SynonymHit> getSynonym({
    required String indexName,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getSynonym`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getSynonym`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/synonyms/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SynonymHit, SynonymHit>(
      response,
      'SynonymHit',
      growable: true,
    );
  }

  /// Check the status of a task.
  /// Check the current status of a given task.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [taskID] - Unique identifier of an task. Numeric value (up to 64bits).
  /// * [requestOptions] additional request configuration.
  Future<GetTaskResponse> getTask({
    required String indexName,
    required int taskID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getTask`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/task/{taskID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTaskResponse, GetTaskResponse>(
      response,
      'GetTaskResponse',
      growable: true,
    );
  }

  /// Get top userID.
  /// Get the top 10 userIDs with the highest number of records per cluster. The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters. Upon success, the response is 200 OK and contains the following array of userIDs and clusters.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<GetTopUserIdsResponse> getTopUserIds({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping/top',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTopUserIdsResponse, GetTopUserIdsResponse>(
      response,
      'GetTopUserIdsResponse',
      growable: true,
    );
  }

  /// Get userID.
  /// Returns the userID data stored in the mapping. The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters. Upon success, the response is 200 OK and contains the following userID data.
  ///
  /// Parameters:
  /// * [userID] - userID to assign.
  /// * [requestOptions] additional request configuration.
  Future<UserId> getUserId({
    required String userID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      userID.isNotEmpty,
      'Parameter `userID` is required when calling `getUserId`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping/{userID}'.replaceAll(
          '{' r'userID' '}', Uri.encodeComponent(userID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UserId, UserId>(
      response,
      'UserId',
      growable: true,
    );
  }

  /// Get migration status.
  /// Get the status of your clusters' migrations or user creations. Creating a large batch of users or migrating your multi-cluster may take quite some time. This method lets you retrieve the status of the migration, so you can know when it's done. Upon success, the response is 200 OK. A successful response indicates that the operation has been taken into account, and the userIDs are directly usable.
  ///
  /// Parameters:
  /// * [getClusters] - If the clusters pending mapping state should be on the response.
  /// * [requestOptions] additional request configuration.
  Future<HasPendingMappingsResponse> hasPendingMappings({
    bool? getClusters,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping/pending',
      queryParams: {
        if (getClusters != null) 'getClusters': getClusters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<HasPendingMappingsResponse, HasPendingMappingsResponse>(
      response,
      'HasPendingMappingsResponse',
      growable: true,
    );
  }

  /// List API Keys.
  /// List API keys, along with their associated rights.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<ListApiKeysResponse> listApiKeys({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/keys',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListApiKeysResponse, ListApiKeysResponse>(
      response,
      'ListApiKeysResponse',
      growable: true,
    );
  }

  /// List clusters.
  /// List the clusters available in a multi-clusters setup for a single appID. Upon success, the response is 200 OK and contains the following clusters.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<ListClustersResponse> listClusters({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListClustersResponse, ListClustersResponse>(
      response,
      'ListClustersResponse',
      growable: true,
    );
  }

  /// List existing indexes.
  /// List existing indexes from an application.
  ///
  /// Parameters:
  /// * [page] - Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
  /// * [requestOptions] additional request configuration.
  Future<ListIndicesResponse> listIndices({
    int? page,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes',
      queryParams: {
        if (page != null) 'page': page,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListIndicesResponse, ListIndicesResponse>(
      response,
      'ListIndicesResponse',
      growable: true,
    );
  }

  /// List userIDs.
  /// List the userIDs assigned to a multi-clusters appID. The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters. Upon success, the response is 200 OK and contains the following userIDs data.
  ///
  /// Parameters:
  /// * [page] - Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
  /// * [hitsPerPage] - Maximum number of objects to retrieve.
  /// * [requestOptions] additional request configuration.
  Future<ListUserIdsResponse> listUserIds({
    int? page,
    int? hitsPerPage = 100,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping',
      queryParams: {
        if (page != null) 'page': page,
        if (hitsPerPage != null) 'hitsPerPage': hitsPerPage,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListUserIdsResponse, ListUserIdsResponse>(
      response,
      'ListUserIdsResponse',
      growable: true,
    );
  }

  /// Batch operations to many indices.
  /// Perform multiple write operations, potentially targeting multiple indices, in a single API call.
  ///
  /// Parameters:
  /// * [batchParams]
  /// * [requestOptions] additional request configuration.
  Future<MultipleBatchResponse> multipleBatch({
    required BatchParams batchParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/batch',
      body: batchParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<MultipleBatchResponse, MultipleBatchResponse>(
      response,
      'MultipleBatchResponse',
      growable: true,
    );
  }

  /// Copy/move index.
  /// Performs a copy or a move operation on a index.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [operationIndexParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> operationIndex({
    required String indexName,
    required OperationIndexParams operationIndexParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `operationIndex`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/operation'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: operationIndexParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Partially update an object.
  /// Update one or more attributes of an existing object. This method lets you update only a part of an existing object, either by adding new attributes or updating existing ones. You can partially update several objects in a single method call. If the index targeted by this operation doesn't exist yet, it's automatically created.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [attributesToUpdate] - Map of attribute(s) to update.
  /// * [createIfNotExists] - Creates the record if it does not exist yet.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtWithObjectIdResponse> partialUpdateObject({
    required String indexName,
    required String objectID,
    required Map<String, dynamic> attributesToUpdate,
    bool? createIfNotExists = true,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `partialUpdateObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `partialUpdateObject`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/{objectID}/partial'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (createIfNotExists != null) 'createIfNotExists': createIfNotExists,
      },
      body: attributesToUpdate,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtWithObjectIdResponse,
        UpdatedAtWithObjectIdResponse>(
      response,
      'UpdatedAtWithObjectIdResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] - The path of the API endpoint to target, anything after the /1 needs to be specified.
  /// * [parameters] - Query parameters to be applied to the current query.
  /// * [body] - The parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> post({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `post`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1{path}'
          .replaceAll('{' r'path' '}', Uri.encodeComponent(path.toString())),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] - The path of the API endpoint to target, anything after the /1 needs to be specified.
  /// * [parameters] - Query parameters to be applied to the current query.
  /// * [body] - The parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> put({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `put`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1{path}'
          .replaceAll('{' r'path' '}', Uri.encodeComponent(path.toString())),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Remove userID.
  /// Remove a userID and its associated data from the multi-clusters. Upon success, the response is 200 OK and a task is created to remove the userID data and mapping.
  ///
  /// Parameters:
  /// * [userID] - userID to assign.
  /// * [requestOptions] additional request configuration.
  Future<RemoveUserIdResponse> removeUserId({
    required String userID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      userID.isNotEmpty,
      'Parameter `userID` is required when calling `removeUserId`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/clusters/mapping/{userID}'.replaceAll(
          '{' r'userID' '}', Uri.encodeComponent(userID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<RemoveUserIdResponse, RemoveUserIdResponse>(
      response,
      'RemoveUserIdResponse',
      growable: true,
    );
  }

  /// Replace all allowed sources.
  /// Replace all allowed sources.
  ///
  /// Parameters:
  /// * [modelSource] - The sources to allow.
  /// * [requestOptions] additional request configuration.
  Future<ReplaceSourceResponse> replaceSources({
    required List<ModelSource> modelSource,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/security/sources',
      body: modelSource,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ReplaceSourceResponse, ReplaceSourceResponse>(
      response,
      'ReplaceSourceResponse',
      growable: true,
    );
  }

  /// Restore an API key.
  /// Restore a deleted API key, along with its associated rights.
  ///
  /// Parameters:
  /// * [key] - API Key string.
  /// * [requestOptions] additional request configuration.
  Future<AddApiKeyResponse> restoreApiKey({
    required String key,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `restoreApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/keys/{key}/restore'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<AddApiKeyResponse, AddApiKeyResponse>(
      response,
      'AddApiKeyResponse',
      growable: true,
    );
  }

  /// Add an object to the index.
  /// Add an object to the index, automatically assigning it an object ID.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [body] - The Algolia record.
  /// * [requestOptions] additional request configuration.
  Future<SaveObjectResponse> saveObject({
    required String indexName,
    required Object body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveObject`.',
    );
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body` is required when calling `saveObject`.',
      );
    }
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body ` is required when calling `saveObject`.',
      );
    }
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SaveObjectResponse, SaveObjectResponse>(
      response,
      'SaveObjectResponse',
      growable: true,
    );
  }

  /// Save/Update a rule.
  /// Create or update the Rule with the specified objectID.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [rule]
  /// * [forwardToReplicas] - When true, changes are also propagated to replicas of the given indexName.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedRuleResponse> saveRule({
    required String indexName,
    required String objectID,
    required Rule rule,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `saveRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
      body: rule.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedRuleResponse, UpdatedRuleResponse>(
      response,
      'UpdatedRuleResponse',
      growable: true,
    );
  }

  /// Save a batch of rules.
  /// Create/update multiple rules objects at once.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [rules]
  /// * [forwardToReplicas] - When true, changes are also propagated to replicas of the given indexName.
  /// * [clearExistingRules] - When true, existing Rules are cleared before adding this batch. When false, existing Rules are kept.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> saveRules({
    required String indexName,
    required List<Rule> rules,
    bool? forwardToReplicas,
    bool? clearExistingRules,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/rules/batch'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
        if (clearExistingRules != null)
          'clearExistingRules': clearExistingRules,
      },
      body: rules,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Save synonym.
  /// Create a new synonym object or update the existing synonym object with the given object ID.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [objectID] - Unique identifier of an object.
  /// * [synonymHit]
  /// * [forwardToReplicas] - When true, changes are also propagated to replicas of the given indexName.
  /// * [requestOptions] additional request configuration.
  Future<SaveSynonymResponse> saveSynonym({
    required String indexName,
    required String objectID,
    required SynonymHit synonymHit,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveSynonym`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `saveSynonym`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/synonyms/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
      body: synonymHit.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SaveSynonymResponse, SaveSynonymResponse>(
      response,
      'SaveSynonymResponse',
      growable: true,
    );
  }

  /// Save a batch of synonyms.
  /// Create/update multiple synonym objects at once, potentially replacing the entire list of synonyms if replaceExistingSynonyms is true.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [synonymHit]
  /// * [forwardToReplicas] - When true, changes are also propagated to replicas of the given indexName.
  /// * [replaceExistingSynonyms] - Replace all synonyms of the index with the ones sent with this request.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> saveSynonyms({
    required String indexName,
    required List<SynonymHit> synonymHit,
    bool? forwardToReplicas,
    bool? replaceExistingSynonyms,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveSynonyms`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/synonyms/batch'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
        if (replaceExistingSynonyms != null)
          'replaceExistingSynonyms': replaceExistingSynonyms,
      },
      body: synonymHit,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Search multiple indices.
  /// Perform a search operation targeting one or many indices.
  ///
  /// Parameters:
  /// * [searchMethodParams] - The `search` requests and strategy.
  /// * [requestOptions] additional request configuration.
  Future<SearchResponses> search({
    required SearchMethodParams searchMethodParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/queries',
      isRead: true,
      body: searchMethodParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchResponses, SearchResponses>(
      response,
      'SearchResponses',
      growable: true,
    );
  }

  /// Search a dictionary entries.
  /// Search the dictionary entries.
  ///
  /// Parameters:
  /// * [dictionaryName] - The dictionary to search in.
  /// * [searchDictionaryEntriesParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> searchDictionaryEntries({
    required DictionaryType dictionaryName,
    required SearchDictionaryEntriesParams searchDictionaryEntriesParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/dictionaries/{dictionaryName}/search'.replaceAll(
          '{' r'dictionaryName' '}',
          Uri.encodeComponent(dictionaryName.toString())),
      isRead: true,
      body: searchDictionaryEntriesParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Search for values of a given facet.
  /// Search for values of a given facet, optionally restricting the returned values to those contained in objects matching other search criteria.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [facetName] - The facet name.
  /// * [searchForFacetValuesRequest]
  /// * [requestOptions] additional request configuration.
  Future<SearchForFacetValuesResponse> searchForFacetValues({
    required String indexName,
    required String facetName,
    SearchForFacetValuesRequest? searchForFacetValuesRequest,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchForFacetValues`.',
    );
    assert(
      facetName.isNotEmpty,
      'Parameter `facetName` is required when calling `searchForFacetValues`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/facets/{facetName}/query'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'facetName' '}', Uri.encodeComponent(facetName.toString())),
      isRead: true,
      body: searchForFacetValuesRequest?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchForFacetValuesResponse,
        SearchForFacetValuesResponse>(
      response,
      'SearchForFacetValuesResponse',
      growable: true,
    );
  }

  /// Search for rules.
  /// Search for rules matching various criteria.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [searchRulesParams]
  /// * [requestOptions] additional request configuration.
  Future<SearchRulesResponse> searchRules({
    required String indexName,
    SearchRulesParams? searchRulesParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/rules/search'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      body: searchRulesParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchRulesResponse, SearchRulesResponse>(
      response,
      'SearchRulesResponse',
      growable: true,
    );
  }

  /// Search in a single index.
  /// Perform a search operation targeting one specific index.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [searchParams]
  /// * [requestOptions] additional request configuration.
  Future<SearchResponse> searchSingleIndex({
    required String indexName,
    dynamic searchParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchSingleIndex`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/query'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      body: searchParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchResponse, SearchResponse>(
      response,
      'SearchResponse',
      growable: true,
    );
  }

  /// Search synonyms.
  /// Search or browse all synonyms, optionally filtering them by type.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [type] - Only search for specific types of synonyms.
  /// * [page] - Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
  /// * [hitsPerPage] - Maximum number of objects to retrieve.
  /// * [searchSynonymsParams] - The body of the the `searchSynonyms` method.
  /// * [requestOptions] additional request configuration.
  Future<SearchSynonymsResponse> searchSynonyms({
    required String indexName,
    SynonymType? type,
    int? page = 0,
    int? hitsPerPage = 100,
    SearchSynonymsParams? searchSynonymsParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchSynonyms`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/synonyms/search'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      queryParams: {
        if (type != null) 'type': type,
        if (page != null) 'page': page,
        if (hitsPerPage != null) 'hitsPerPage': hitsPerPage,
      },
      body: searchSynonymsParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchSynonymsResponse, SearchSynonymsResponse>(
      response,
      'SearchSynonymsResponse',
      growable: true,
    );
  }

  /// Search userID.
  /// Search for userIDs. The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds propagate to the different clusters. To keep updates moving quickly, the index of userIDs isn't built synchronously with the mapping. Instead, the index is built once every 12h, at the same time as the update of userID usage. For example, when you perform a modification like adding or moving a userID, the search will report an outdated value until the next rebuild of the mapping, which takes place every 12h. Upon success, the response is 200 OK and contains the following userIDs data.
  ///
  /// Parameters:
  /// * [searchUserIdsParams]
  /// * [requestOptions] additional request configuration.
  Future<SearchUserIdsResponse> searchUserIds({
    required SearchUserIdsParams searchUserIdsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/clusters/mapping/search',
      isRead: true,
      body: searchUserIdsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchUserIdsResponse, SearchUserIdsResponse>(
      response,
      'SearchUserIdsResponse',
      growable: true,
    );
  }

  /// Set dictionaries settings.
  /// Set dictionaries settings.
  ///
  /// Parameters:
  /// * [dictionarySettingsParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> setDictionarySettings({
    required DictionarySettingsParams dictionarySettingsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/dictionaries/*/settings',
      body: dictionarySettingsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Update settings of an index.
  /// Update settings of an index. Only specified settings are overridden; unspecified settings are left unchanged. Specifying null for a setting resets it to its default value.
  ///
  /// Parameters:
  /// * [indexName] - The index in which to perform the request.
  /// * [indexSettings]
  /// * [forwardToReplicas] - When true, changes are also propagated to replicas of the given indexName.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> setSettings({
    required String indexName,
    required IndexSettings indexSettings,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `setSettings`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/settings'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
      body: indexSettings.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Update an API key.
  /// Replace every permission of an existing API key.
  ///
  /// Parameters:
  /// * [key] - API Key string.
  /// * [apiKey]
  /// * [requestOptions] additional request configuration.
  Future<UpdateApiKeyResponse> updateApiKey({
    required String key,
    required ApiKey apiKey,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `updateApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/keys/{key}'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
      body: apiKey.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdateApiKeyResponse, UpdateApiKeyResponse>(
      response,
      'UpdateApiKeyResponse',
      growable: true,
    );
  }

  @override
  void dispose() => _retryStrategy.dispose();
}
