// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import 'package:algolia_client_core/algolia_client_core.dart';
import 'package:algolia_client_search/src/deserialize.dart';
import 'package:algolia_client_search/src/version.dart';

import 'package:algolia_client_search/src/model/add_api_key_response.dart';
import 'package:algolia_client_search/src/model/api_key.dart';
import 'package:algolia_client_search/src/model/assign_user_id_params.dart';
import 'package:algolia_client_search/src/model/batch_assign_user_ids_params.dart';
import 'package:algolia_client_search/src/model/batch_dictionary_entries_params.dart';
import 'package:algolia_client_search/src/model/batch_params.dart';
import 'package:algolia_client_search/src/model/batch_response.dart';
import 'package:algolia_client_search/src/model/batch_write_params.dart';
import 'package:algolia_client_search/src/model/browse_response.dart';
import 'package:algolia_client_search/src/model/created_at_response.dart';
import 'package:algolia_client_search/src/model/delete_api_key_response.dart';
import 'package:algolia_client_search/src/model/delete_by_params.dart';
import 'package:algolia_client_search/src/model/delete_source_response.dart';
import 'package:algolia_client_search/src/model/deleted_at_response.dart';
import 'package:algolia_client_search/src/model/dictionary_settings_params.dart';
import 'package:algolia_client_search/src/model/dictionary_type.dart';
import 'package:algolia_client_search/src/model/get_api_key_response.dart';
import 'package:algolia_client_search/src/model/get_dictionary_settings_response.dart';
import 'package:algolia_client_search/src/model/get_logs_response.dart';
import 'package:algolia_client_search/src/model/get_objects_params.dart';
import 'package:algolia_client_search/src/model/get_objects_response.dart';
import 'package:algolia_client_search/src/model/get_task_response.dart';
import 'package:algolia_client_search/src/model/get_top_user_ids_response.dart';
import 'package:algolia_client_search/src/model/has_pending_mappings_response.dart';
import 'package:algolia_client_search/src/model/index_settings.dart';
import 'package:algolia_client_search/src/model/languages.dart';
import 'package:algolia_client_search/src/model/list_api_keys_response.dart';
import 'package:algolia_client_search/src/model/list_clusters_response.dart';
import 'package:algolia_client_search/src/model/list_indices_response.dart';
import 'package:algolia_client_search/src/model/list_user_ids_response.dart';
import 'package:algolia_client_search/src/model/log_type.dart';
import 'package:algolia_client_search/src/model/multiple_batch_response.dart';
import 'package:algolia_client_search/src/model/operation_index_params.dart';
import 'package:algolia_client_search/src/model/remove_user_id_response.dart';
import 'package:algolia_client_search/src/model/replace_source_response.dart';
import 'package:algolia_client_search/src/model/rule.dart';
import 'package:algolia_client_search/src/model/save_object_response.dart';
import 'package:algolia_client_search/src/model/save_synonym_response.dart';
import 'package:algolia_client_search/src/model/search_dictionary_entries_params.dart';
import 'package:algolia_client_search/src/model/search_for_facet_values_request.dart';
import 'package:algolia_client_search/src/model/search_for_facet_values_response.dart';
import 'package:algolia_client_search/src/model/search_method_params.dart';
import 'package:algolia_client_search/src/model/search_response.dart';
import 'package:algolia_client_search/src/model/search_responses.dart';
import 'package:algolia_client_search/src/model/search_rules_params.dart';
import 'package:algolia_client_search/src/model/search_rules_response.dart';
import 'package:algolia_client_search/src/model/search_synonyms_params.dart';
import 'package:algolia_client_search/src/model/search_synonyms_response.dart';
import 'package:algolia_client_search/src/model/search_user_ids_params.dart';
import 'package:algolia_client_search/src/model/search_user_ids_response.dart';
import 'package:algolia_client_search/src/model/source.dart';
import 'package:algolia_client_search/src/model/synonym_hit.dart';
import 'package:algolia_client_search/src/model/synonym_type.dart';
import 'package:algolia_client_search/src/model/update_api_key_response.dart';
import 'package:algolia_client_search/src/model/updated_at_response.dart';
import 'package:algolia_client_search/src/model/updated_at_with_object_id_response.dart';
import 'package:algolia_client_search/src/model/updated_rule_response.dart';
import 'package:algolia_client_search/src/model/user_id.dart';

final class SearchClient implements ApiClient {
  @override
  final String apiKey;

  @override
  final String appId;

  @override
  final ClientOptions options;

  final RetryStrategy _retryStrategy;

  SearchClient({
    required this.appId,
    required this.apiKey,
    this.options = const ClientOptions(),
  }) : _retryStrategy = RetryStrategy.create(
          segment: AgentSegment(value: "Search", version: packageVersion),
          appId: appId,
          apiKey: apiKey,
          options: options,
          defaultHosts: () =>
              [
                Host(url: '$appId-dsn.algolia.net', callType: CallType.read),
                Host(url: '$appId.algolia.net', callType: CallType.write),
              ] +
              ([
                Host(url: '$appId-1.algolianet.com'),
                Host(url: '$appId-2.algolianet.com'),
                Host(url: '$appId-3.algolianet.com'),
              ]..shuffle()),
        ) {
    assert(appId.isNotEmpty, '`appId` is missing.');
    assert(apiKey.isNotEmpty, '`apiKey` is missing.');
  }

  /// Add API key.
  /// Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string.
  ///
  /// Parameters:
  /// * [apiKey]
  /// * [requestOptions] additional request configuration.
  Future<AddApiKeyResponse> addApiKey({
    required ApiKey apiKey,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/keys',
      body: apiKey.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<AddApiKeyResponse, AddApiKeyResponse>(
      response,
      'AddApiKeyResponse',
      growable: true,
    );
  }

  /// Add or update a record (using objectID).
  /// If you use an existing `objectID`, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique record (object) identifier.
  /// * [body] Algolia record.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtWithObjectIdResponse> addOrUpdateObject({
    required String indexName,
    required String objectID,
    required Object body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `addOrUpdateObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `addOrUpdateObject`.',
    );
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body` is required when calling `addOrUpdateObject`.',
      );
    }
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body ` is required when calling `addOrUpdateObject`.',
      );
    }
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtWithObjectIdResponse,
        UpdatedAtWithObjectIdResponse>(
      response,
      'UpdatedAtWithObjectIdResponse',
      growable: true,
    );
  }

  /// Add a source.
  /// Add a source to the list of allowed sources.
  ///
  /// Parameters:
  /// * [source] Source to add.
  /// * [requestOptions] additional request configuration.
  Future<CreatedAtResponse> appendSource({
    required Source source,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/security/sources/append',
      body: source.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<CreatedAtResponse, CreatedAtResponse>(
      response,
      'CreatedAtResponse',
      growable: true,
    );
  }

  /// Assign or move a user ID.
  /// Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID.
  ///
  /// Parameters:
  /// * [xAlgoliaUserID] userID to assign.
  /// * [assignUserIdParams]
  /// * [requestOptions] additional request configuration.
  Future<CreatedAtResponse> assignUserId({
    required String xAlgoliaUserID,
    required AssignUserIdParams assignUserIdParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      xAlgoliaUserID.isNotEmpty,
      'Parameter `xAlgoliaUserID` is required when calling `assignUserId`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/clusters/mapping',
      headers: {
        'X-Algolia-User-ID': xAlgoliaUserID,
      },
      body: assignUserIdParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<CreatedAtResponse, CreatedAtResponse>(
      response,
      'CreatedAtResponse',
      growable: true,
    );
  }

  /// Batch write operations on one index.
  /// To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported `action`s are equivalent to the individual operations of the same name.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [batchWriteParams]
  /// * [requestOptions] additional request configuration.
  Future<BatchResponse> batch({
    required String indexName,
    required BatchWriteParams batchWriteParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `batch`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/batch'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: batchWriteParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<BatchResponse, BatchResponse>(
      response,
      'BatchResponse',
      growable: true,
    );
  }

  /// Batch assign userIDs.
  /// Assign multiple user IDs to a cluster. **You can't _move_ users with this operation.**.
  ///
  /// Parameters:
  /// * [xAlgoliaUserID] userID to assign.
  /// * [batchAssignUserIdsParams]
  /// * [requestOptions] additional request configuration.
  Future<CreatedAtResponse> batchAssignUserIds({
    required String xAlgoliaUserID,
    required BatchAssignUserIdsParams batchAssignUserIdsParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      xAlgoliaUserID.isNotEmpty,
      'Parameter `xAlgoliaUserID` is required when calling `batchAssignUserIds`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/clusters/mapping/batch',
      headers: {
        'X-Algolia-User-ID': xAlgoliaUserID,
      },
      body: batchAssignUserIdsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<CreatedAtResponse, CreatedAtResponse>(
      response,
      'CreatedAtResponse',
      growable: true,
    );
  }

  /// Batch dictionary entries.
  /// Add or remove a batch of dictionary entries.
  ///
  /// Parameters:
  /// * [dictionaryName] Dictionary to search in.
  /// * [batchDictionaryEntriesParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> batchDictionaryEntries({
    required DictionaryType dictionaryName,
    required BatchDictionaryEntriesParams batchDictionaryEntriesParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/dictionaries/{dictionaryName}/batch'.replaceAll(
          '{' r'dictionaryName' '}',
          Uri.encodeComponent(dictionaryName.toString())),
      body: batchDictionaryEntriesParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Get all records from an index.
  /// Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn't support: - The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [browseParams]  - one of types: [SearchParamsString], [BrowseParamsObject],
  /// * [requestOptions] additional request configuration.
  Future<BrowseResponse> browse({
    required String indexName,
    dynamic browseParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `browse`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/browse'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: browseParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<BrowseResponse, BrowseResponse>(
      response,
      'BrowseResponse',
      growable: true,
    );
  }

  /// Delete all synonyms.
  /// Delete all synonyms in the index.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [forwardToReplicas] Indicates whether changed index settings are forwarded to the replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> clearAllSynonyms({
    required String indexName,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `clearAllSynonyms`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/synonyms/clear'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Delete all records from an index.
  /// Delete the records but leave settings and index-specific API keys untouched.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> clearObjects({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `clearObjects`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/clear'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Delete all rules.
  /// Delete all rules in the index.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [forwardToReplicas] Indicates whether changed index settings are forwarded to the replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> clearRules({
    required String indexName,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `clearRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/rules/clear'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> del({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `del`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Delete API key.
  /// Delete an existing API key. The request must be authenticated with the admin API key.
  ///
  /// Parameters:
  /// * [key] API key.
  /// * [requestOptions] additional request configuration.
  Future<DeleteApiKeyResponse> deleteApiKey({
    required String key,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `deleteApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/keys/{key}'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteApiKeyResponse, DeleteApiKeyResponse>(
      response,
      'DeleteApiKeyResponse',
      growable: true,
    );
  }

  /// Delete all records matching a query.
  /// This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn't accept empty filters or queries.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [deleteByParams]
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteBy({
    required String indexName,
    required DeleteByParams deleteByParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteBy`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/deleteByQuery'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: deleteByParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Delete index.
  /// Delete an existing index.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteIndex({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteIndex`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Delete a record.
  /// To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy) instead.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique record (object) identifier.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteObject({
    required String indexName,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteObject`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Delete a rule.
  /// Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique identifier of a rule object.
  /// * [forwardToReplicas] Indicates whether changed index settings are forwarded to the replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> deleteRule({
    required String indexName,
    required String objectID,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Remove a source.
  /// Remove a source from the list of allowed sources.
  ///
  /// Parameters:
  /// * [source] IP address range of the source.
  /// * [requestOptions] additional request configuration.
  Future<DeleteSourceResponse> deleteSource({
    required String source,
    RequestOptions? requestOptions,
  }) async {
    assert(
      source.isNotEmpty,
      'Parameter `source` is required when calling `deleteSource`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/security/sources/{source}'.replaceAll(
          '{' r'source' '}', Uri.encodeComponent(source.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteSourceResponse, DeleteSourceResponse>(
      response,
      'DeleteSourceResponse',
      growable: true,
    );
  }

  /// Delete a synonym.
  /// Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique identifier of a synonym object.
  /// * [forwardToReplicas] Indicates whether changed index settings are forwarded to the replica indices.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteSynonym({
    required String indexName,
    required String objectID,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteSynonym`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteSynonym`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/synonyms/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> get({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `get`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Get API key permissions.
  /// Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key.
  ///
  /// Parameters:
  /// * [key] API key.
  /// * [requestOptions] additional request configuration.
  Future<GetApiKeyResponse> getApiKey({
    required String key,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `getApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/keys/{key}'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetApiKeyResponse, GetApiKeyResponse>(
      response,
      'GetApiKeyResponse',
      growable: true,
    );
  }

  /// List available languages.
  /// Lists Algolia's [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language's [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<Map<String, Languages>> getDictionaryLanguages({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/dictionaries/*/languages',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Map<String, Languages>, Languages>(
      response,
      'Map<String, Languages>',
      growable: true,
    );
  }

  /// Get stop word settings.
  /// Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<GetDictionarySettingsResponse> getDictionarySettings({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/dictionaries/*/settings',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetDictionarySettingsResponse,
        GetDictionarySettingsResponse>(
      response,
      'GetDictionarySettingsResponse',
      growable: true,
    );
  }

  /// Return the latest log entries.
  /// The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There's also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself. > **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN's endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).
  ///
  /// Parameters:
  /// * [offset] First log entry to retrieve. Sorted by decreasing date with 0 being the most recent.
  /// * [length] Maximum number of entries to retrieve.
  /// * [indexName] Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
  /// * [type] Type of log entries to retrieve. When omitted, all log entries are retrieved.
  /// * [requestOptions] additional request configuration.
  Future<GetLogsResponse> getLogs({
    int? offset,
    int? length,
    String? indexName,
    LogType? type,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/logs',
      queryParams: {
        if (offset != null) 'offset': offset,
        if (length != null) 'length': length,
        if (indexName != null) 'indexName': indexName,
        if (type != null) 'type': type,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetLogsResponse, GetLogsResponse>(
      response,
      'GetLogsResponse',
      growable: true,
    );
  }

  /// Get a record.
  /// To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique record (object) identifier.
  /// * [attributesToRetrieve] Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified. [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won't be retrieved unless the request is authenticated with the admin API key.
  /// * [requestOptions] additional request configuration.
  Future<Map<String, String>> getObject({
    required String indexName,
    required String objectID,
    List<String>? attributesToRetrieve,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getObject`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (attributesToRetrieve != null)
          'attributesToRetrieve': attributesToRetrieve.join(','),
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Map<String, String>, String>(
      response,
      'Map<String, String>',
      growable: true,
    );
  }

  /// Get multiple records.
  /// Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.
  ///
  /// Parameters:
  /// * [getObjectsParams] Request object.
  /// * [requestOptions] additional request configuration.
  Future<GetObjectsResponse> getObjects({
    required GetObjectsParams getObjectsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/objects',
      isRead: true,
      body: getObjectsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetObjectsResponse, GetObjectsResponse>(
      response,
      'GetObjectsResponse',
      growable: true,
    );
  }

  /// Get a rule.
  /// Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique identifier of a rule object.
  /// * [requestOptions] additional request configuration.
  Future<Rule> getRule({
    required String indexName,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Rule, Rule>(
      response,
      'Rule',
      growable: true,
    );
  }

  /// Get index settings.
  /// Return an object containing an index's [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [requestOptions] additional request configuration.
  Future<IndexSettings> getSettings({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getSettings`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/settings'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<IndexSettings, IndexSettings>(
      response,
      'IndexSettings',
      growable: true,
    );
  }

  /// Get all allowed IP addresses.
  /// Get all allowed sources (IP addresses).
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<List<Source>> getSources({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/security/sources',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<List<Source>, Source>(
      response,
      'List<Source>',
      growable: true,
    );
  }

  /// Get a synonym object.
  /// Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique identifier of a synonym object.
  /// * [requestOptions] additional request configuration.
  Future<SynonymHit> getSynonym({
    required String indexName,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getSynonym`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getSynonym`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/synonyms/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SynonymHit, SynonymHit>(
      response,
      'SynonymHit',
      growable: true,
    );
  }

  /// Check a task's status.
  /// Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the status of that task.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [taskID] Unique task identifier.
  /// * [requestOptions] additional request configuration.
  Future<GetTaskResponse> getTask({
    required String indexName,
    required int taskID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getTask`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/task/{taskID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTaskResponse, GetTaskResponse>(
      response,
      'GetTaskResponse',
      growable: true,
    );
  }

  /// Get top userID.
  /// Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<GetTopUserIdsResponse> getTopUserIds({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping/top',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTopUserIdsResponse, GetTopUserIdsResponse>(
      response,
      'GetTopUserIdsResponse',
      growable: true,
    );
  }

  /// Get userID.
  /// Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
  ///
  /// Parameters:
  /// * [userID] userID to assign.
  /// * [requestOptions] additional request configuration.
  Future<UserId> getUserId({
    required String userID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      userID.isNotEmpty,
      'Parameter `userID` is required when calling `getUserId`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping/{userID}'.replaceAll(
          '{' r'userID' '}', Uri.encodeComponent(userID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UserId, UserId>(
      response,
      'UserId',
      growable: true,
    );
  }

  /// Get migration and user mapping status.
  /// To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
  ///
  /// Parameters:
  /// * [getClusters] Indicates whether to include the cluster's pending mapping state in the response.
  /// * [requestOptions] additional request configuration.
  Future<HasPendingMappingsResponse> hasPendingMappings({
    bool? getClusters,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping/pending',
      queryParams: {
        if (getClusters != null) 'getClusters': getClusters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<HasPendingMappingsResponse, HasPendingMappingsResponse>(
      response,
      'HasPendingMappingsResponse',
      growable: true,
    );
  }

  /// List API keys.
  /// List all API keys associated with your Algolia application, including their permissions and restrictions.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<ListApiKeysResponse> listApiKeys({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/keys',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListApiKeysResponse, ListApiKeysResponse>(
      response,
      'ListApiKeysResponse',
      growable: true,
    );
  }

  /// List clusters.
  /// List the available clusters in a multi-cluster setup.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<ListClustersResponse> listClusters({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListClustersResponse, ListClustersResponse>(
      response,
      'ListClustersResponse',
      growable: true,
    );
  }

  /// List indices.
  /// List indices in an Algolia application.
  ///
  /// Parameters:
  /// * [page] Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
  /// * [hitsPerPage] Maximum number of hits per page.
  /// * [requestOptions] additional request configuration.
  Future<ListIndicesResponse> listIndices({
    int? page,
    int? hitsPerPage,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes',
      queryParams: {
        if (page != null) 'page': page,
        if (hitsPerPage != null) 'hitsPerPage': hitsPerPage,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListIndicesResponse, ListIndicesResponse>(
      response,
      'ListIndicesResponse',
      growable: true,
    );
  }

  /// List userIDs.
  /// List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
  ///
  /// Parameters:
  /// * [page] Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
  /// * [hitsPerPage] Maximum number of hits per page.
  /// * [requestOptions] additional request configuration.
  Future<ListUserIdsResponse> listUserIds({
    int? page,
    int? hitsPerPage,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping',
      queryParams: {
        if (page != null) 'page': page,
        if (hitsPerPage != null) 'hitsPerPage': hitsPerPage,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListUserIdsResponse, ListUserIdsResponse>(
      response,
      'ListUserIdsResponse',
      growable: true,
    );
  }

  /// Batch write operations on multiple indices.
  /// To reduce the time spent on network round trips, you can perform several write actions in a single request. It's a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name.
  ///
  /// Parameters:
  /// * [batchParams]
  /// * [requestOptions] additional request configuration.
  Future<MultipleBatchResponse> multipleBatch({
    required BatchParams batchParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/batch',
      body: batchParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<MultipleBatchResponse, MultipleBatchResponse>(
      response,
      'MultipleBatchResponse',
      growable: true,
    );
  }

  /// Copy, move, or rename an index.
  /// This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms, and rules to a `destination` index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn't exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  > **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [operationIndexParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> operationIndex({
    required String indexName,
    required OperationIndexParams operationIndexParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `operationIndex`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/operation'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: operationIndexParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Update record attributes.
  /// Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique record (object) identifier.
  /// * [attributesToUpdate] Object with attributes to update. - one of types: [BuiltInOperation], [String],
  /// * [createIfNotExists] Indicates whether to create a new record if it doesn't exist yet.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtWithObjectIdResponse> partialUpdateObject({
    required String indexName,
    required String objectID,
    required Map<String, dynamic> attributesToUpdate,
    bool? createIfNotExists,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `partialUpdateObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `partialUpdateObject`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/{objectID}/partial'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (createIfNotExists != null) 'createIfNotExists': createIfNotExists,
      },
      body: attributesToUpdate,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtWithObjectIdResponse,
        UpdatedAtWithObjectIdResponse>(
      response,
      'UpdatedAtWithObjectIdResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> post({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `post`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> put({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `put`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Remove userID.
  /// Remove a userID and its associated data from the multi-clusters.
  ///
  /// Parameters:
  /// * [userID] userID to assign.
  /// * [requestOptions] additional request configuration.
  Future<RemoveUserIdResponse> removeUserId({
    required String userID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      userID.isNotEmpty,
      'Parameter `userID` is required when calling `removeUserId`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/clusters/mapping/{userID}'.replaceAll(
          '{' r'userID' '}', Uri.encodeComponent(userID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<RemoveUserIdResponse, RemoveUserIdResponse>(
      response,
      'RemoveUserIdResponse',
      growable: true,
    );
  }

  /// Replace all sources.
  /// Replace all allowed sources.
  ///
  /// Parameters:
  /// * [source] Allowed sources.
  /// * [requestOptions] additional request configuration.
  Future<ReplaceSourceResponse> replaceSources({
    required List<Source> source,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/security/sources',
      body: source,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ReplaceSourceResponse, ReplaceSourceResponse>(
      response,
      'ReplaceSourceResponse',
      growable: true,
    );
  }

  /// Restore API key.
  /// Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key.
  ///
  /// Parameters:
  /// * [key] API key.
  /// * [requestOptions] additional request configuration.
  Future<AddApiKeyResponse> restoreApiKey({
    required String key,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `restoreApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/keys/{key}/restore'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<AddApiKeyResponse, AddApiKeyResponse>(
      response,
      'AddApiKeyResponse',
      growable: true,
    );
  }

  /// Add or update a record.
  /// Add a record (object) to an index or replace it. If the record doesn't contain an `objectID`, Algolia automatically adds it. If you use an existing `objectID`, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [body] The Algolia record.
  /// * [requestOptions] additional request configuration.
  Future<SaveObjectResponse> saveObject({
    required String indexName,
    required Object body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveObject`.',
    );
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body` is required when calling `saveObject`.',
      );
    }
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body ` is required when calling `saveObject`.',
      );
    }
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SaveObjectResponse, SaveObjectResponse>(
      response,
      'SaveObjectResponse',
      growable: true,
    );
  }

  /// Create or update a rule.
  /// To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique identifier of a rule object.
  /// * [rule]
  /// * [forwardToReplicas] Indicates whether changed index settings are forwarded to the replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedRuleResponse> saveRule({
    required String indexName,
    required String objectID,
    required Rule rule,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `saveRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
      body: rule.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedRuleResponse, UpdatedRuleResponse>(
      response,
      'UpdatedRuleResponse',
      growable: true,
    );
  }

  /// Save a batch of rules.
  /// Create or update multiple rules.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [rules]
  /// * [forwardToReplicas] Indicates whether changed index settings are forwarded to the replica indices.
  /// * [clearExistingRules] Indicates whether existing rules should be deleted before adding this batch.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> saveRules({
    required String indexName,
    required List<Rule> rules,
    bool? forwardToReplicas,
    bool? clearExistingRules,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/rules/batch'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
        if (clearExistingRules != null)
          'clearExistingRules': clearExistingRules,
      },
      body: rules,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Save a synonym.
  /// Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym `objectID` doesn't exist, Algolia adds a new one. If you use an existing synonym `objectID`, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [objectID] Unique identifier of a synonym object.
  /// * [synonymHit]
  /// * [forwardToReplicas] Indicates whether changed index settings are forwarded to the replica indices.
  /// * [requestOptions] additional request configuration.
  Future<SaveSynonymResponse> saveSynonym({
    required String indexName,
    required String objectID,
    required SynonymHit synonymHit,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveSynonym`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `saveSynonym`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/synonyms/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
      body: synonymHit.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SaveSynonymResponse, SaveSynonymResponse>(
      response,
      'SaveSynonymResponse',
      growable: true,
    );
  }

  /// Save a batch of synonyms.
  /// Create or update multiple synonyms.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [synonymHit]
  /// * [forwardToReplicas] Indicates whether changed index settings are forwarded to the replica indices.
  /// * [replaceExistingSynonyms] Indicates whether to replace all synonyms in the index with the ones sent with this request.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> saveSynonyms({
    required String indexName,
    required List<SynonymHit> synonymHit,
    bool? forwardToReplicas,
    bool? replaceExistingSynonyms,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveSynonyms`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/synonyms/batch'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
        if (replaceExistingSynonyms != null)
          'replaceExistingSynonyms': replaceExistingSynonyms,
      },
      body: synonymHit,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Search multiple indices.
  /// Send multiple search queries to one or more indices.
  ///
  /// Parameters:
  /// * [searchMethodParams] Query requests and strategies. Results will be received in the same order as the queries.
  /// * [requestOptions] additional request configuration.
  Future<SearchResponses> search({
    required SearchMethodParams searchMethodParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/queries',
      isRead: true,
      body: searchMethodParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchResponses, SearchResponses>(
      response,
      'SearchResponses',
      growable: true,
    );
  }

  /// Search dictionary entries.
  /// Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.
  ///
  /// Parameters:
  /// * [dictionaryName] Dictionary to search in.
  /// * [searchDictionaryEntriesParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> searchDictionaryEntries({
    required DictionaryType dictionaryName,
    required SearchDictionaryEntriesParams searchDictionaryEntriesParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/dictionaries/{dictionaryName}/search'.replaceAll(
          '{' r'dictionaryName' '}',
          Uri.encodeComponent(dictionaryName.toString())),
      isRead: true,
      body: searchDictionaryEntriesParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Search for facet values.
  /// [Search for a facet's values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. > **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [facetName] Facet name.
  /// * [searchForFacetValuesRequest]
  /// * [requestOptions] additional request configuration.
  Future<SearchForFacetValuesResponse> searchForFacetValues({
    required String indexName,
    required String facetName,
    SearchForFacetValuesRequest? searchForFacetValuesRequest,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchForFacetValues`.',
    );
    assert(
      facetName.isNotEmpty,
      'Parameter `facetName` is required when calling `searchForFacetValues`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/facets/{facetName}/query'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'facetName' '}', Uri.encodeComponent(facetName.toString())),
      isRead: true,
      body: searchForFacetValuesRequest?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchForFacetValuesResponse,
        SearchForFacetValuesResponse>(
      response,
      'SearchForFacetValuesResponse',
      growable: true,
    );
  }

  /// Search for rules.
  /// Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [searchRulesParams]
  /// * [requestOptions] additional request configuration.
  Future<SearchRulesResponse> searchRules({
    required String indexName,
    SearchRulesParams? searchRulesParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/rules/search'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      body: searchRulesParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchRulesResponse, SearchRulesResponse>(
      response,
      'SearchRulesResponse',
      growable: true,
    );
  }

  /// Search an index.
  /// Return records that match the query.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [searchParams]  - one of types: [SearchParamsString], [SearchParamsObject],
  /// * [requestOptions] additional request configuration.
  Future<SearchResponse> searchSingleIndex({
    required String indexName,
    dynamic searchParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchSingleIndex`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/query'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      body: searchParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchResponse, SearchResponse>(
      response,
      'SearchResponse',
      growable: true,
    );
  }

  /// Search for synonyms.
  /// Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [type] Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms).
  /// * [page] Returns the requested page number (the first page is 0). Page size is set by `hitsPerPage`. When null, there's no pagination.
  /// * [hitsPerPage] Maximum number of hits per page.
  /// * [searchSynonymsParams] Body of the `searchSynonyms` operation.
  /// * [requestOptions] additional request configuration.
  Future<SearchSynonymsResponse> searchSynonyms({
    required String indexName,
    SynonymType? type,
    int? page,
    int? hitsPerPage,
    SearchSynonymsParams? searchSynonymsParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchSynonyms`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/synonyms/search'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      queryParams: {
        if (type != null) 'type': type,
        if (page != null) 'page': page,
        if (hitsPerPage != null) 'hitsPerPage': hitsPerPage,
      },
      body: searchSynonymsParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchSynonymsResponse, SearchSynonymsResponse>(
      response,
      'SearchSynonymsResponse',
      growable: true,
    );
  }

  /// Search for a user ID.
  /// Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time. To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
  ///
  /// Parameters:
  /// * [searchUserIdsParams]
  /// * [requestOptions] additional request configuration.
  Future<SearchUserIdsResponse> searchUserIds({
    required SearchUserIdsParams searchUserIdsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/clusters/mapping/search',
      isRead: true,
      body: searchUserIdsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchUserIdsResponse, SearchUserIdsResponse>(
      response,
      'SearchUserIdsResponse',
      growable: true,
    );
  }

  /// Set stop word settings.
  /// Set stop word settings for a specific language.
  ///
  /// Parameters:
  /// * [dictionarySettingsParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> setDictionarySettings({
    required DictionarySettingsParams dictionarySettingsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/dictionaries/*/settings',
      body: dictionarySettingsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Update index settings.
  /// Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.
  ///
  /// Parameters:
  /// * [indexName] Index on which to perform the request.
  /// * [indexSettings]
  /// * [forwardToReplicas] Indicates whether changed index settings are forwarded to the replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> setSettings({
    required String indexName,
    required IndexSettings indexSettings,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `setSettings`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/settings'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
      body: indexSettings.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Update an API key.
  /// Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key.
  ///
  /// Parameters:
  /// * [key] API key.
  /// * [apiKey]
  /// * [requestOptions] additional request configuration.
  Future<UpdateApiKeyResponse> updateApiKey({
    required String key,
    required ApiKey apiKey,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `updateApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/keys/{key}'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
      body: apiKey.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdateApiKeyResponse, UpdateApiKeyResponse>(
      response,
      'UpdateApiKeyResponse',
      growable: true,
    );
  }

  @override
  void dispose() => _retryStrategy.dispose();
}
