// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
// ignore_for_file: unused_element

import 'package:json_annotation/json_annotation.dart';

part 'base_index_settings.g.dart';

@JsonSerializable()
final class BaseIndexSettings {
  /// Returns a new [BaseIndexSettings] instance.
  const BaseIndexSettings({
    this.replicas,
    this.paginationLimitedTo,
    this.unretrievableAttributes,
    this.disableTypoToleranceOnWords,
    this.attributesToTransliterate,
    this.camelCaseAttributes,
    this.decompoundedAttributes,
    this.indexLanguages,
    this.disablePrefixOnAttributes,
    this.allowCompressionOfIntegerArray,
    this.numericAttributesForFiltering,
    this.separatorsToIndex,
    this.searchableAttributes,
    this.userData,
    this.customNormalization,
  });

  /// Creates [replicas](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/in-depth/replicas/), which are copies of a primary index with the same records but different settings.
  @JsonKey(name: r'replicas')
  final List<String>? replicas;

  /// Maximum number of hits accessible through pagination.
  @JsonKey(name: r'paginationLimitedTo')
  final int? paginationLimitedTo;

  /// Attributes that can't be retrieved at query time.
  @JsonKey(name: r'unretrievableAttributes')
  final List<String>? unretrievableAttributes;

  /// Words for which you want to turn off [typo tolerance](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/typo-tolerance/).
  @JsonKey(name: r'disableTypoToleranceOnWords')
  final List<String>? disableTypoToleranceOnWords;

  /// Attributes in your index to which [Japanese transliteration](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/language-specific-configurations/#japanese-transliteration-and-type-ahead) applies. This will ensure that words indexed in Katakana or Kanji can also be searched in Hiragana.
  @JsonKey(name: r'attributesToTransliterate')
  final List<String>? attributesToTransliterate;

  /// Attributes on which to split [camel case](https://wikipedia.org/wiki/Camel_case) words.
  @JsonKey(name: r'camelCaseAttributes')
  final List<String>? camelCaseAttributes;

  /// Attributes in your index to which [word segmentation](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) (decompounding) applies.
  @JsonKey(name: r'decompoundedAttributes')
  final Object? decompoundedAttributes;

  /// Set the languages of your index, for language-specific processing steps such as [tokenization](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/tokenization/) and [normalization](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/normalization/).
  @JsonKey(name: r'indexLanguages')
  final List<String>? indexLanguages;

  /// Attributes for which you want to turn off [prefix matching](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/override-search-engine-defaults/#adjusting-prefix-search).
  @JsonKey(name: r'disablePrefixOnAttributes')
  final List<String>? disablePrefixOnAttributes;

  /// Incidates whether the engine compresses arrays with exclusively non-negative integers. When enabled, the compressed arrays may be reordered.
  @JsonKey(name: r'allowCompressionOfIntegerArray')
  final bool? allowCompressionOfIntegerArray;

  /// Numeric attributes that can be used as [numerical filters](https://www.algolia.com/doc/guides/managing-results/rules/detecting-intent/how-to/applying-a-custom-filter-for-a-specific-query/#numerical-filters).
  @JsonKey(name: r'numericAttributesForFiltering')
  final List<String>? numericAttributesForFiltering;

  /// Controls which separators are added to an Algolia index as part of [normalization](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/#what-does-normalization-mean). Separators are all non-letter characters except spaces and currency characters, such as $€£¥.
  @JsonKey(name: r'separatorsToIndex')
  final String? separatorsToIndex;

  /// [Attributes used for searching](https://www.algolia.com/doc/guides/managing-results/must-do/searchable-attributes/), including determining [if matches at the beginning of a word are important (ordered) or not (unordered)](https://www.algolia.com/doc/guides/managing-results/must-do/searchable-attributes/how-to/configuring-searchable-attributes-the-right-way/#understanding-word-position).
  @JsonKey(name: r'searchableAttributes')
  final List<String>? searchableAttributes;

  /// Lets you store custom data in your indices.
  @JsonKey(name: r'userData')
  final Object? userData;

  /// A list of characters and their normalized replacements to override Algolia's default [normalization](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/normalization/).
  @JsonKey(name: r'customNormalization')
  final Map<String, Map<String, String>>? customNormalization;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BaseIndexSettings &&
          other.replicas == replicas &&
          other.paginationLimitedTo == paginationLimitedTo &&
          other.unretrievableAttributes == unretrievableAttributes &&
          other.disableTypoToleranceOnWords == disableTypoToleranceOnWords &&
          other.attributesToTransliterate == attributesToTransliterate &&
          other.camelCaseAttributes == camelCaseAttributes &&
          other.decompoundedAttributes == decompoundedAttributes &&
          other.indexLanguages == indexLanguages &&
          other.disablePrefixOnAttributes == disablePrefixOnAttributes &&
          other.allowCompressionOfIntegerArray ==
              allowCompressionOfIntegerArray &&
          other.numericAttributesForFiltering ==
              numericAttributesForFiltering &&
          other.separatorsToIndex == separatorsToIndex &&
          other.searchableAttributes == searchableAttributes &&
          other.userData == userData &&
          other.customNormalization == customNormalization;

  @override
  int get hashCode =>
      replicas.hashCode +
      paginationLimitedTo.hashCode +
      unretrievableAttributes.hashCode +
      disableTypoToleranceOnWords.hashCode +
      attributesToTransliterate.hashCode +
      camelCaseAttributes.hashCode +
      decompoundedAttributes.hashCode +
      indexLanguages.hashCode +
      disablePrefixOnAttributes.hashCode +
      allowCompressionOfIntegerArray.hashCode +
      numericAttributesForFiltering.hashCode +
      separatorsToIndex.hashCode +
      searchableAttributes.hashCode +
      (userData == null ? 0 : userData.hashCode) +
      customNormalization.hashCode;

  factory BaseIndexSettings.fromJson(Map<String, dynamic> json) =>
      _$BaseIndexSettingsFromJson(json);

  Map<String, dynamic> toJson() => _$BaseIndexSettingsToJson(this);

  @override
  String toString() {
    return toJson().toString();
  }
}
