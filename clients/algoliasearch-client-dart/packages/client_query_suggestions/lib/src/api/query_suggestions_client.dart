// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import 'package:algolia_client_core/algolia_client_core.dart';
import 'package:algolia_client_query_suggestions/src/deserialize.dart';
import 'package:algolia_client_query_suggestions/src/version.dart';

import 'package:algolia_client_query_suggestions/src/model/base_response.dart';
import 'package:algolia_client_query_suggestions/src/model/get_config_status200_response.dart';
import 'package:algolia_client_query_suggestions/src/model/get_log_file200_response.dart';
import 'package:algolia_client_query_suggestions/src/model/query_suggestions_configuration.dart';
import 'package:algolia_client_query_suggestions/src/model/query_suggestions_configuration_response.dart';
import 'package:algolia_client_query_suggestions/src/model/query_suggestions_configuration_with_index.dart';

final class QuerySuggestionsClient implements ApiClient {
  @override
  final String apiKey;

  @override
  final String appId;

  @override
  final ClientOptions options;

  final String region;

  final RetryStrategy _retryStrategy;

  QuerySuggestionsClient({
    required this.appId,
    required this.apiKey,
    this.options = const ClientOptions(),
    required this.region,
  }) : _retryStrategy = RetryStrategy.create(
            segment: AgentSegment(
                value: "QuerySuggestions", version: packageVersion),
            appId: appId,
            apiKey: apiKey,
            options: options,
            defaultHosts: () {
              final allowedRegions = ['eu', 'us'];
              assert(
                allowedRegions.contains(region),
                '`region` is required and must be one of the following: ${allowedRegions.join(', ')}',
              );
              final url = 'query-suggestions.{region}.algolia.com'
                  .replaceAll('{region}', region);
              return [Host(url: url)];
            }) {
    assert(appId.isNotEmpty, '`appId` is missing.');
    assert(apiKey.isNotEmpty, '`apiKey` is missing.');
  }

  /// Create a configuration.
  /// Create a new Query Suggestions configuration.  You can have up to 100 configurations per Algolia application.
  ///
  /// Parameters:
  /// * [querySuggestionsConfigurationWithIndex]
  /// * [requestOptions] additional request configuration.
  Future<BaseResponse> createConfig({
    required QuerySuggestionsConfigurationWithIndex
        querySuggestionsConfigurationWithIndex,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/configs',
      body: querySuggestionsConfigurationWithIndex.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<BaseResponse, BaseResponse>(
      response,
      'BaseResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> del({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `del`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Delete a configuration.
  /// Delete a Query Suggestions configuration.  Deleting only removes the configuration and stops updates to the Query Suggestions index. The Query Suggestions index itself is not deleted.
  ///
  /// Parameters:
  /// * [indexName] Query Suggestions index name.
  /// * [requestOptions] additional request configuration.
  Future<BaseResponse> deleteConfig({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteConfig`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/configs/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<BaseResponse, BaseResponse>(
      response,
      'BaseResponse',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> get({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `get`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// List configurations.
  /// List all Query Suggestions configurations of your Algolia application.
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<List<QuerySuggestionsConfigurationResponse>> getAllConfigs({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/configs',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<List<QuerySuggestionsConfigurationResponse>,
        QuerySuggestionsConfigurationResponse>(
      response,
      'List<QuerySuggestionsConfigurationResponse>',
      growable: true,
    );
  }

  /// Get a configuration.
  /// Get a single Query Suggestions configuration.
  ///
  /// Parameters:
  /// * [indexName] Query Suggestions index name.
  /// * [requestOptions] additional request configuration.
  Future<QuerySuggestionsConfigurationResponse> getConfig({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getConfig`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/configs/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<QuerySuggestionsConfigurationResponse,
        QuerySuggestionsConfigurationResponse>(
      response,
      'QuerySuggestionsConfigurationResponse',
      growable: true,
    );
  }

  /// Get configuration status.
  /// Report the status of a Query Suggestions index.
  ///
  /// Parameters:
  /// * [indexName] Query Suggestions index name.
  /// * [requestOptions] additional request configuration.
  Future<GetConfigStatus200Response> getConfigStatus({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getConfigStatus`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/configs/{indexName}/status'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetConfigStatus200Response, GetConfigStatus200Response>(
      response,
      'GetConfigStatus200Response',
      growable: true,
    );
  }

  /// Get logs.
  /// Get the logs for a single Query Suggestions index.
  ///
  /// Parameters:
  /// * [indexName] Query Suggestions index name.
  /// * [requestOptions] additional request configuration.
  Future<GetLogFile200Response> getLogFile({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getLogFile`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/logs/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetLogFile200Response, GetLogFile200Response>(
      response,
      'GetLogFile200Response',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> post({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `post`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Send requests to the Algolia REST API.
  /// This method allow you to send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> put({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `put`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Update a configuration.
  /// Update a QuerySuggestions configuration.
  ///
  /// Parameters:
  /// * [indexName] Query Suggestions index name.
  /// * [querySuggestionsConfiguration]
  /// * [requestOptions] additional request configuration.
  Future<BaseResponse> updateConfig({
    required String indexName,
    required QuerySuggestionsConfiguration querySuggestionsConfiguration,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `updateConfig`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/configs/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: querySuggestionsConfiguration.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<BaseResponse, BaseResponse>(
      response,
      'BaseResponse',
      growable: true,
    );
  }

  @override
  void dispose() => _retryStrategy.dispose();
}
