// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
// ignore_for_file: unused_element
import 'package:algoliasearch/src/model/dictionary_entry_state.dart';

import 'package:collection/collection.dart';
import 'package:json_annotation/json_annotation.dart';

part 'dictionary_entry.g.dart';

@JsonSerializable(createFieldMap: true)
final class DictionaryEntry extends DelegatingMap<String, dynamic> {
  /// Returns a new [DictionaryEntry] instance.
  const DictionaryEntry({
    required this.objectID,
    required this.language,
    this.word,
    this.words,
    this.decomposition,
    this.state,
    Map<String, dynamic> additionalProperties = const {},
  }) : super(additionalProperties);

  /// Unique identifier for a dictionary object.
  @JsonKey(name: r'objectID')
  final String objectID;

  /// [Supported language ISO code](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/).
  @JsonKey(name: r'language')
  final String language;

  /// Dictionary entry word. Usage depends on the type of dictionary entry. **`stopwordEntry`** The stop word you want to add or update. If the entry already exists in Algolia's standard dictionary, you can override its behavior by adding it to the custom dictionary and setting its `state` to `disabled`. **`compoundEntry`** When `decomposition` is empty: adds `word` as a compound atom. For example, atom “kino” decomposes the query “kopfkino” into \"kopf\" and \"kino\". When `decomposition` isn't empty: creates a decomposition exception. For example, when decomposition is set to the [\"hund\", \"hutte\"] exception, \"hundehutte\" decomposes into “hund” and “hutte”, discarding the linking \"e\".
  @JsonKey(name: r'word')
  final String? word;

  /// Compound dictionary [word declensions](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/). If the entry already exists in Algolia's standard dictionary, you can override its behavior by adding it to the custom dictionary and setting its `state` to `disabled`.
  @JsonKey(name: r'words')
  final List<String>? words;

  /// For compound entries, governs the behavior of the `word` parameter.
  @JsonKey(name: r'decomposition')
  final List<String>? decomposition;

  @JsonKey(name: r'state')
  final DictionaryEntryState? state;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DictionaryEntry &&
          other.objectID == objectID &&
          other.language == language &&
          other.word == word &&
          other.words == words &&
          other.decomposition == decomposition &&
          other.state == state &&
          const MapEquality<String, dynamic>().equals(this, this);

  @override
  int get hashCode =>
      objectID.hashCode +
      language.hashCode +
      word.hashCode +
      words.hashCode +
      decomposition.hashCode +
      state.hashCode +
      const MapEquality<String, dynamic>().hash(this);

  factory DictionaryEntry.fromJson(Map<String, dynamic> json) {
    final instance = _$DictionaryEntryFromJson(json);
    final additionalProperties = Map<String, dynamic>.from(json)
      ..removeWhere((key, value) => _$DictionaryEntryFieldMap.containsKey(key));
    return DictionaryEntry(
      objectID: instance.objectID,
      language: instance.language,
      word: instance.word,
      words: instance.words,
      decomposition: instance.decomposition,
      state: instance.state,
      additionalProperties: additionalProperties,
    );
  }

  Map<String, dynamic> toJson() => _$DictionaryEntryToJson(this)..addAll(this);

  @override
  String toString() {
    return toJson().toString();
  }
}
