# coding: utf-8

"""
    Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
"""


from typing import Any, Dict, List, Optional, Tuple, Union

from analytics.api_client import ApiClient
from analytics.api_response import ApiResponse
from analytics.models.direction import Direction
from analytics.models.get_average_click_position_response import (
    GetAverageClickPositionResponse,
)
from analytics.models.get_click_positions_response import GetClickPositionsResponse
from analytics.models.get_click_through_rate_response import GetClickThroughRateResponse
from analytics.models.get_conversation_rate_response import GetConversationRateResponse
from analytics.models.get_no_click_rate_response import GetNoClickRateResponse
from analytics.models.get_no_results_rate_response import GetNoResultsRateResponse
from analytics.models.get_searches_count_response import GetSearchesCountResponse
from analytics.models.get_searches_no_clicks_response import GetSearchesNoClicksResponse
from analytics.models.get_searches_no_results_response import (
    GetSearchesNoResultsResponse,
)
from analytics.models.get_status_response import GetStatusResponse
from analytics.models.get_top_countries_response import GetTopCountriesResponse
from analytics.models.get_top_filter_attributes_response import (
    GetTopFilterAttributesResponse,
)
from analytics.models.get_top_filter_for_attribute_response import (
    GetTopFilterForAttributeResponse,
)
from analytics.models.get_top_filters_no_results_response import (
    GetTopFiltersNoResultsResponse,
)
from analytics.models.get_top_hits_response import GetTopHitsResponse
from analytics.models.get_top_searches_response import GetTopSearchesResponse
from analytics.models.get_users_count_response import GetUsersCountResponse
from analytics.models.order_by import OrderBy
from analytics.rest import RESTResponseType
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, validate_call
from typing_extensions import Annotated


class AnalyticsClient:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def call_del(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._call_del_serialize(
            path=path,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def call_del_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._call_del_serialize(
            path=path,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def call_del_without_preload_content(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._call_del_serialize(
            path=path,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _call_del_serialize(
        self,
        path,
        parameters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if path is not None:
            _path_params["path"] = path
        # process the query parameters
        if parameters is not None:
            _query_params.append(("parameters", parameters))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/1{path}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_serialize(
            path=path,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_serialize(
            path=path,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_without_preload_content(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_serialize(
            path=path,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_serialize(
        self,
        path,
        parameters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if path is not None:
            _path_params["path"] = path
        # process the query parameters
        if parameters is not None:
            _query_params.append(("parameters", parameters))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/1{path}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_average_click_position(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetAverageClickPositionResponse:
        """Get average click position.

        Return the average click position for the complete time range and for individual days. > **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_average_click_position_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetAverageClickPositionResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_average_click_position_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetAverageClickPositionResponse]:
        """Get average click position.

        Return the average click position for the complete time range and for individual days. > **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_average_click_position_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetAverageClickPositionResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_average_click_position_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get average click position.

        Return the average click position for the complete time range and for individual days. > **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_average_click_position_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_average_click_position_serialize(
        self,
        index,
        start_date,
        end_date,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/clicks/averageClickPosition",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_click_positions(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetClickPositionsResponse:
        """Get click positions.

        Show the number of clicks events and their associated position in the search results.  > **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_click_positions_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetClickPositionsResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_click_positions_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetClickPositionsResponse]:
        """Get click positions.

        Show the number of clicks events and their associated position in the search results.  > **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_click_positions_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetClickPositionsResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_click_positions_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get click positions.

        Show the number of clicks events and their associated position in the search results.  > **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_click_positions_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_click_positions_serialize(
        self,
        index,
        start_date,
        end_date,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/clicks/positions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_click_through_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetClickThroughRateResponse:
        """Get click-through rate (CTR).

        Returns a [click-through rate (CTR)](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#click-through-rate).

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_click_through_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetClickThroughRateResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_click_through_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetClickThroughRateResponse]:
        """Get click-through rate (CTR).

        Returns a [click-through rate (CTR)](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#click-through-rate).

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_click_through_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetClickThroughRateResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_click_through_rate_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get click-through rate (CTR).

        Returns a [click-through rate (CTR)](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#click-through-rate).

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_click_through_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_click_through_rate_serialize(
        self,
        index,
        start_date,
        end_date,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/clicks/clickThroughRate",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_conversation_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetConversationRateResponse:
        """Get conversion rate (CR).

        Return a [conversion rate](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#conversion-rate).

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_conversation_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetConversationRateResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_conversation_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetConversationRateResponse]:
        """Get conversion rate (CR).

        Return a [conversion rate](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#conversion-rate).

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_conversation_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetConversationRateResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_conversation_rate_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get conversion rate (CR).

        Return a [conversion rate](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#conversion-rate).

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_conversation_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_conversation_rate_serialize(
        self,
        index,
        start_date,
        end_date,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/conversions/conversionRate",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_no_click_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNoClickRateResponse:
        """Get no click rate.

        Returns the rate at which searches don't lead to any clicks. The endpoint returns a value for the complete given time range, as well as a value per day. It also returns the count of searches and searches without clicks.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_no_click_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetNoClickRateResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_no_click_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNoClickRateResponse]:
        """Get no click rate.

        Returns the rate at which searches don't lead to any clicks. The endpoint returns a value for the complete given time range, as well as a value per day. It also returns the count of searches and searches without clicks.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_no_click_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetNoClickRateResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_no_click_rate_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get no click rate.

        Returns the rate at which searches don't lead to any clicks. The endpoint returns a value for the complete given time range, as well as a value per day. It also returns the count of searches and searches without clicks.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_no_click_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_no_click_rate_serialize(
        self,
        index,
        start_date,
        end_date,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/searches/noClickRate",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_no_results_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNoResultsRateResponse:
        """Get no results rate.

        Returns the rate at which searches didn't return any results.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_no_results_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetNoResultsRateResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_no_results_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNoResultsRateResponse]:
        """Get no results rate.

        Returns the rate at which searches didn't return any results.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_no_results_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetNoResultsRateResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_no_results_rate_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get no results rate.

        Returns the rate at which searches didn't return any results.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_no_results_rate_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_no_results_rate_serialize(
        self,
        index,
        start_date,
        end_date,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/searches/noResultRate",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_searches_count(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetSearchesCountResponse:
        """Get number of searches.

        Returns the number of searches within a time range.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_searches_count_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetSearchesCountResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_searches_count_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetSearchesCountResponse]:
        """Get number of searches.

        Returns the number of searches within a time range.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_searches_count_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetSearchesCountResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_searches_count_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get number of searches.

        Returns the number of searches within a time range.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_searches_count_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_searches_count_serialize(
        self,
        index,
        start_date,
        end_date,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/searches/count",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_searches_no_clicks(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetSearchesNoClicksResponse:
        """Get top searches with no clicks.

        Return the most popular of the last 1,000 searches that didn't lead to any clicks.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_searches_no_clicks_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetSearchesNoClicksResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_searches_no_clicks_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetSearchesNoClicksResponse]:
        """Get top searches with no clicks.

        Return the most popular of the last 1,000 searches that didn't lead to any clicks.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_searches_no_clicks_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetSearchesNoClicksResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_searches_no_clicks_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get top searches with no clicks.

        Return the most popular of the last 1,000 searches that didn't lead to any clicks.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_searches_no_clicks_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_searches_no_clicks_serialize(
        self,
        index,
        start_date,
        end_date,
        limit,
        offset,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if limit is not None:
            _query_params.append(("limit", limit))

        if offset is not None:
            _query_params.append(("offset", offset))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/searches/noClicks",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_searches_no_results(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetSearchesNoResultsResponse:
        """Get top searches with no results.

        Returns the most popular of the latest 1,000 searches that didn't return any results.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_searches_no_results_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetSearchesNoResultsResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_searches_no_results_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetSearchesNoResultsResponse]:
        """Get top searches with no results.

        Returns the most popular of the latest 1,000 searches that didn't return any results.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_searches_no_results_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetSearchesNoResultsResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_searches_no_results_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get top searches with no results.

        Returns the most popular of the latest 1,000 searches that didn't return any results.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_searches_no_results_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_searches_no_results_serialize(
        self,
        index,
        start_date,
        end_date,
        limit,
        offset,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if limit is not None:
            _query_params.append(("limit", limit))

        if offset is not None:
            _query_params.append(("offset", offset))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/searches/noResults",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_status(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetStatusResponse:
        """Get Analytics API status.

        Return the latest update time of the Analytics API for an index. If the index has been recently created or no search has been performed yet, `updatedAt` will be `null`. > **Note**: The Analytics API is updated every 5&nbsp;minutes.

        :param index: Index name to target. (required)
        :type index: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_status_serialize(
            index=index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetStatusResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_status_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetStatusResponse]:
        """Get Analytics API status.

        Return the latest update time of the Analytics API for an index. If the index has been recently created or no search has been performed yet, `updatedAt` will be `null`. > **Note**: The Analytics API is updated every 5&nbsp;minutes.

        :param index: Index name to target. (required)
        :type index: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_status_serialize(
            index=index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetStatusResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_status_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Analytics API status.

        Return the latest update time of the Analytics API for an index. If the index has been recently created or no search has been performed yet, `updatedAt` will be `null`. > **Note**: The Analytics API is updated every 5&nbsp;minutes.

        :param index: Index name to target. (required)
        :type index: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_status_serialize(
            index=index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_status_serialize(
        self,
        index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/status",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_top_countries(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetTopCountriesResponse:
        """Get top countries.

        Returns top countries. Limited to the 1,000 most frequent ones.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_countries_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopCountriesResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_top_countries_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetTopCountriesResponse]:
        """Get top countries.

        Returns top countries. Limited to the 1,000 most frequent ones.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_countries_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopCountriesResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_top_countries_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get top countries.

        Returns top countries. Limited to the 1,000 most frequent ones.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_countries_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_top_countries_serialize(
        self,
        index,
        start_date,
        end_date,
        limit,
        offset,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if limit is not None:
            _query_params.append(("limit", limit))

        if offset is not None:
            _query_params.append(("offset", offset))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/countries",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_top_filter_attributes(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetTopFilterAttributesResponse:
        """Get top filterable attributes.

        Return the most popular [filterable attributes](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/) in the 1,000 most recently used filters.

        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_filter_attributes_serialize(
            index=index,
            search=search,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopFilterAttributesResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_top_filter_attributes_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetTopFilterAttributesResponse]:
        """Get top filterable attributes.

        Return the most popular [filterable attributes](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/) in the 1,000 most recently used filters.

        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_filter_attributes_serialize(
            index=index,
            search=search,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopFilterAttributesResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_top_filter_attributes_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get top filterable attributes.

        Return the most popular [filterable attributes](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/) in the 1,000 most recently used filters.

        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_filter_attributes_serialize(
            index=index,
            search=search,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_top_filter_attributes_serialize(
        self,
        index,
        search,
        start_date,
        end_date,
        limit,
        offset,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if search is not None:
            _query_params.append(("search", search))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if limit is not None:
            _query_params.append(("limit", limit))

        if offset is not None:
            _query_params.append(("offset", offset))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/filters",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_top_filter_for_attribute(
        self,
        attribute: Annotated[StrictStr, Field(description="Attribute name.")],
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetTopFilterForAttributeResponse:
        """Get top filter values for an attribute.

        Returns the most popular filter values for an attribute in the 1,000 most recently used filters.

        :param attribute: Attribute name. (required)
        :type attribute: str
        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_filter_for_attribute_serialize(
            attribute=attribute,
            index=index,
            search=search,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopFilterForAttributeResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_top_filter_for_attribute_with_http_info(
        self,
        attribute: Annotated[StrictStr, Field(description="Attribute name.")],
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetTopFilterForAttributeResponse]:
        """Get top filter values for an attribute.

        Returns the most popular filter values for an attribute in the 1,000 most recently used filters.

        :param attribute: Attribute name. (required)
        :type attribute: str
        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_filter_for_attribute_serialize(
            attribute=attribute,
            index=index,
            search=search,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopFilterForAttributeResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_top_filter_for_attribute_without_preload_content(
        self,
        attribute: Annotated[StrictStr, Field(description="Attribute name.")],
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get top filter values for an attribute.

        Returns the most popular filter values for an attribute in the 1,000 most recently used filters.

        :param attribute: Attribute name. (required)
        :type attribute: str
        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_filter_for_attribute_serialize(
            attribute=attribute,
            index=index,
            search=search,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_top_filter_for_attribute_serialize(
        self,
        attribute,
        index,
        search,
        start_date,
        end_date,
        limit,
        offset,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if attribute is not None:
            _path_params["attribute"] = attribute
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if search is not None:
            _query_params.append(("search", search))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if limit is not None:
            _query_params.append(("limit", limit))

        if offset is not None:
            _query_params.append(("offset", offset))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/filters/{attribute}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_top_filters_no_results(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetTopFiltersNoResultsResponse:
        """Get top filters for a no result search.

        Returns top filters for filter-enabled searches that don't return results. Limited to the 1,000 most recently used filters.

        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_filters_no_results_serialize(
            index=index,
            search=search,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopFiltersNoResultsResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_top_filters_no_results_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetTopFiltersNoResultsResponse]:
        """Get top filters for a no result search.

        Returns top filters for filter-enabled searches that don't return results. Limited to the 1,000 most recently used filters.

        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_filters_no_results_serialize(
            index=index,
            search=search,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopFiltersNoResultsResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_top_filters_no_results_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get top filters for a no result search.

        Returns top filters for filter-enabled searches that don't return results. Limited to the 1,000 most recently used filters.

        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_filters_no_results_serialize(
            index=index,
            search=search,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_top_filters_no_results_serialize(
        self,
        index,
        search,
        start_date,
        end_date,
        limit,
        offset,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if search is not None:
            _query_params.append(("search", search))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if limit is not None:
            _query_params.append(("limit", limit))

        if offset is not None:
            _query_params.append(("offset", offset))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/filters/noResults",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_top_hits(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search."
            ),
        ] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetTopHitsResponse:
        """Get top hits.

        Return the most popular clicked results in the last 1,000 searches.

        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param click_analytics: Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
        :type click_analytics: bool
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_hits_serialize(
            index=index,
            search=search,
            click_analytics=click_analytics,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopHitsResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_top_hits_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search."
            ),
        ] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetTopHitsResponse]:
        """Get top hits.

        Return the most popular clicked results in the last 1,000 searches.

        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param click_analytics: Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
        :type click_analytics: bool
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_hits_serialize(
            index=index,
            search=search,
            click_analytics=click_analytics,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopHitsResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_top_hits_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        search: Annotated[Optional[StrictStr], Field(description="User query.")] = None,
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search."
            ),
        ] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get top hits.

        Return the most popular clicked results in the last 1,000 searches.

        :param index: Index name to target. (required)
        :type index: str
        :param search: User query.
        :type search: str
        :param click_analytics: Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
        :type click_analytics: bool
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_hits_serialize(
            index=index,
            search=search,
            click_analytics=click_analytics,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_top_hits_serialize(
        self,
        index,
        search,
        click_analytics,
        start_date,
        end_date,
        limit,
        offset,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if search is not None:
            _query_params.append(("search", search))

        if click_analytics is not None:
            _query_params.append(("clickAnalytics", click_analytics))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if limit is not None:
            _query_params.append(("limit", limit))

        if offset is not None:
            _query_params.append(("offset", offset))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/hits",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_top_searches(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search."
            ),
        ] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        order_by: Annotated[
            Optional[OrderBy], Field(description="Reorder the results.")
        ] = None,
        direction: Annotated[
            Optional[Direction],
            Field(
                description="Sorting direction of the results: ascending or descending. "
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetTopSearchesResponse:
        """Get top searches.

        Returns the most popular of the latest 1,000 searches. For each search, also returns the number of hits.

        :param index: Index name to target. (required)
        :type index: str
        :param click_analytics: Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
        :type click_analytics: bool
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param order_by: Reorder the results.
        :type order_by: OrderBy
        :param direction: Sorting direction of the results: ascending or descending.
        :type direction: Direction
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_searches_serialize(
            index=index,
            click_analytics=click_analytics,
            start_date=start_date,
            end_date=end_date,
            order_by=order_by,
            direction=direction,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopSearchesResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_top_searches_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search."
            ),
        ] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        order_by: Annotated[
            Optional[OrderBy], Field(description="Reorder the results.")
        ] = None,
        direction: Annotated[
            Optional[Direction],
            Field(
                description="Sorting direction of the results: ascending or descending. "
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetTopSearchesResponse]:
        """Get top searches.

        Returns the most popular of the latest 1,000 searches. For each search, also returns the number of hits.

        :param index: Index name to target. (required)
        :type index: str
        :param click_analytics: Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
        :type click_analytics: bool
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param order_by: Reorder the results.
        :type order_by: OrderBy
        :param direction: Sorting direction of the results: ascending or descending.
        :type direction: Direction
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_searches_serialize(
            index=index,
            click_analytics=click_analytics,
            start_date=start_date,
            end_date=end_date,
            order_by=order_by,
            direction=direction,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetTopSearchesResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_top_searches_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search."
            ),
        ] = None,
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        order_by: Annotated[
            Optional[OrderBy], Field(description="Reorder the results.")
        ] = None,
        direction: Annotated[
            Optional[Direction],
            Field(
                description="Sorting direction of the results: ascending or descending. "
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to return (page size)."),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Position of the starting record. Used for paging. 0 is the first record."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get top searches.

        Returns the most popular of the latest 1,000 searches. For each search, also returns the number of hits.

        :param index: Index name to target. (required)
        :type index: str
        :param click_analytics: Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
        :type click_analytics: bool
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param order_by: Reorder the results.
        :type order_by: OrderBy
        :param direction: Sorting direction of the results: ascending or descending.
        :type direction: Direction
        :param limit: Number of records to return (page size).
        :type limit: int
        :param offset: Position of the starting record. Used for paging. 0 is the first record.
        :type offset: int
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_top_searches_serialize(
            index=index,
            click_analytics=click_analytics,
            start_date=start_date,
            end_date=end_date,
            order_by=order_by,
            direction=direction,
            limit=limit,
            offset=offset,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_top_searches_serialize(
        self,
        index,
        click_analytics,
        start_date,
        end_date,
        order_by,
        direction,
        limit,
        offset,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if click_analytics is not None:
            _query_params.append(("clickAnalytics", click_analytics))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if order_by is not None:
            _query_params.append(("orderBy", order_by.value))

        if direction is not None:
            _query_params.append(("direction", direction.value))

        if limit is not None:
            _query_params.append(("limit", limit))

        if offset is not None:
            _query_params.append(("offset", offset))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/searches",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_users_count(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetUsersCountResponse:
        """Get user count.

        Return the count of unique users.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_users_count_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetUsersCountResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_users_count_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetUsersCountResponse]:
        """Get user count.

        Return the count of unique users.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_users_count_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetUsersCountResponse",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_users_count_without_preload_content(
        self,
        index: Annotated[StrictStr, Field(description="Index name to target.")],
        start_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="Start date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        end_date: Annotated[
            Optional[Annotated[str, Field(strict=True)]],
            Field(
                description="End date (a string in the format `YYYY-MM-DD`) of the period to analyze."
            ),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get user count.

        Return the count of unique users.

        :param index: Index name to target. (required)
        :type index: str
        :param start_date: Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._get_users_count_serialize(
            index=index,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_users_count_serialize(
        self,
        index,
        start_date,
        end_date,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            _query_params.append(("index", index))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        if tags is not None:
            _query_params.append(("tags", tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/2/users/count",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def post(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._post_serialize(
            path=path,
            parameters=parameters,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def post_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._post_serialize(
            path=path,
            parameters=parameters,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def post_without_preload_content(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._post_serialize(
            path=path,
            parameters=parameters,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_serialize(
        self,
        path,
        parameters,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if path is not None:
            _path_params["path"] = path
        # process the query parameters
        if parameters is not None:
            _query_params.append(("parameters", parameters))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/1{path}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._put_serialize(
            path=path,
            parameters=parameters,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._put_serialize(
            path=path,
            parameters=parameters,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "400": "ErrorBase",
            "402": "ErrorBase",
            "403": "ErrorBase",
            "404": "ErrorBase",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_without_preload_content(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._put_serialize(
            path=path,
            parameters=parameters,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_serialize(
        self,
        path,
        parameters,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if path is not None:
            _path_params["path"] = path
        # process the query parameters
        if parameters is not None:
            _query_params.append(("parameters", parameters))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["apiKey", "appId"]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/1{path}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
