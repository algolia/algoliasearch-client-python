# coding: utf-8

"""
Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
"""
from __future__ import annotations

from json import dumps
from typing import Annotated, Any, Dict, List, Optional, Self, Tuple, Union
from urllib.parse import quote

from pydantic import Field, StrictBool, StrictInt, StrictStr

from algoliasearch.analytics.config import AnalyticsConfig
from algoliasearch.analytics.models.direction import Direction
from algoliasearch.analytics.models.get_add_to_cart_rate_response import (
    GetAddToCartRateResponse,
)
from algoliasearch.analytics.models.get_average_click_position_response import (
    GetAverageClickPositionResponse,
)
from algoliasearch.analytics.models.get_click_positions_response import (
    GetClickPositionsResponse,
)
from algoliasearch.analytics.models.get_click_through_rate_response import (
    GetClickThroughRateResponse,
)
from algoliasearch.analytics.models.get_conversion_rate_response import (
    GetConversionRateResponse,
)
from algoliasearch.analytics.models.get_no_click_rate_response import (
    GetNoClickRateResponse,
)
from algoliasearch.analytics.models.get_no_results_rate_response import (
    GetNoResultsRateResponse,
)
from algoliasearch.analytics.models.get_purchase_rate_response import (
    GetPurchaseRateResponse,
)
from algoliasearch.analytics.models.get_revenue import GetRevenue
from algoliasearch.analytics.models.get_searches_count_response import (
    GetSearchesCountResponse,
)
from algoliasearch.analytics.models.get_searches_no_clicks_response import (
    GetSearchesNoClicksResponse,
)
from algoliasearch.analytics.models.get_searches_no_results_response import (
    GetSearchesNoResultsResponse,
)
from algoliasearch.analytics.models.get_status_response import GetStatusResponse
from algoliasearch.analytics.models.get_top_countries_response import (
    GetTopCountriesResponse,
)
from algoliasearch.analytics.models.get_top_filter_attributes_response import (
    GetTopFilterAttributesResponse,
)
from algoliasearch.analytics.models.get_top_filter_for_attribute_response import (
    GetTopFilterForAttributeResponse,
)
from algoliasearch.analytics.models.get_top_filters_no_results_response import (
    GetTopFiltersNoResultsResponse,
)
from algoliasearch.analytics.models.get_top_hits_response import GetTopHitsResponse
from algoliasearch.analytics.models.get_top_searches_response import (
    GetTopSearchesResponse,
)
from algoliasearch.analytics.models.get_users_count_response import (
    GetUsersCountResponse,
)
from algoliasearch.analytics.models.order_by import OrderBy
from algoliasearch.http.api_response import ApiResponse
from algoliasearch.http.request_options import RequestOptions
from algoliasearch.http.serializer import bodySerializer
from algoliasearch.http.transporter import Transporter
from algoliasearch.http.verb import Verb


class AnalyticsClient:
    """The Algolia 'AnalyticsClient' class.

    Args:
    app_id (str): The Algolia application ID to retrieve information from.
    api_key (str): The Algolia api key bound to the given `app_id`.
    region ("de" | "us"): The region of your Algolia application.

    Returns:
    The initialized API client.

    Example:
    _client = AnalyticsClient("YOUR_ALGOLIA_APP_ID", "YOUR_ALGOLIA_API_KEY", region="'de' or 'us'")
    _client_with_named_args = AnalyticsClient(app_id="YOUR_ALGOLIA_APP_ID", api_key="YOUR_ALGOLIA_API_KEY", region="'de' or 'us'")

    See `AnalyticsClient.create_with_config` for advanced configuration.
    """

    _transporter: Transporter
    _config: AnalyticsConfig
    _request_options: RequestOptions

    def __init__(
        self,
        app_id: Optional[str] = None,
        api_key: Optional[str] = None,
        region: Optional[str] = None,
        transporter: Optional[Transporter] = None,
        config: Optional[AnalyticsConfig] = None,
    ) -> None:
        if transporter is not None and config is None:
            config = transporter._config

        if config is None:
            config = AnalyticsConfig(app_id, api_key, region)
        self._config = config
        self._request_options = RequestOptions(config)

        if transporter is None:
            transporter = Transporter(config)
        self._transporter = transporter

    def create_with_config(
        config: AnalyticsConfig, transporter: Optional[Transporter] = None
    ) -> Self:
        """Allows creating a client with a customized `AnalyticsConfig` and `Transporter`. If `transporter` is not provided, the default one will be initialized from the given `config`.

        Args:
        config (AnalyticsConfig): The config of the API client.
        transporter (Transporter): The HTTP transporter, see `http/transporter.py` for implementation details.

        Returns:
        The initialized API client.

        Example:
        _client_with_custom_config = AnalyticsClient.create_with_config(config=AnalyticsConfig(...))
        _client_with_custom_config_and_transporter = AnalyticsClient.create_with_config(config=AnalyticsConfig(...), transporter=Transporter(...))
        """
        if transporter is None:
            transporter = Transporter(config)

        return AnalyticsClient(
            app_id=config.app_id,
            api_key=config.api_key,
            region=config.region,
            transporter=transporter,
            config=config,
        )

    async def __aenter__(self) -> None:
        return self

    async def __aexit__(self, exc_type, exc_value, traceback) -> None:
        """Closes the underlying `transporter` of the API client."""
        await self.close()

    async def close(self) -> None:
        """Closes the underlying `transporter` of the API client."""
        return await self._transporter.close()

    async def custom_delete_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        This method allow you to send requests to the Algolia REST API.


        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if path is None:
            raise ValueError(
                "Parameter `path` is required when calling `custom_delete`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if parameters is not None:
            for _qpkey, _qpvalue in parameters.items():
                _query_parameters.append((_qpkey, _qpvalue))

        return await self._transporter.request(
            verb=Verb.DELETE,
            path="/{path}".replace("{path}", path),
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def custom_delete(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        This method allow you to send requests to the Algolia REST API.


        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """
        return (
            await self.custom_delete_with_http_info(path, parameters, request_options)
        ).deserialize(object)

    async def custom_get_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        This method allow you to send requests to the Algolia REST API.


        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if path is None:
            raise ValueError("Parameter `path` is required when calling `custom_get`.")

        _query_parameters: List[Tuple[str, str]] = []

        if parameters is not None:
            for _qpkey, _qpvalue in parameters.items():
                _query_parameters.append((_qpkey, _qpvalue))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/{path}".replace("{path}", path),
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def custom_get(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        This method allow you to send requests to the Algolia REST API.


        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """
        return (
            await self.custom_get_with_http_info(path, parameters, request_options)
        ).deserialize(object)

    async def custom_post_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        This method allow you to send requests to the Algolia REST API.


        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if path is None:
            raise ValueError("Parameter `path` is required when calling `custom_post`.")

        _query_parameters: List[Tuple[str, str]] = []

        if parameters is not None:
            for _qpkey, _qpvalue in parameters.items():
                _query_parameters.append((_qpkey, _qpvalue))

        _data = {}
        if body is not None:
            _data = body

        return await self._transporter.request(
            verb=Verb.POST,
            path="/{path}".replace("{path}", path),
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                data=dumps(bodySerializer(_data)),
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def custom_post(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        This method allow you to send requests to the Algolia REST API.


        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """
        return (
            await self.custom_post_with_http_info(
                path, parameters, body, request_options
            )
        ).deserialize(object)

    async def custom_put_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        This method allow you to send requests to the Algolia REST API.


        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if path is None:
            raise ValueError("Parameter `path` is required when calling `custom_put`.")

        _query_parameters: List[Tuple[str, str]] = []

        if parameters is not None:
            for _qpkey, _qpvalue in parameters.items():
                _query_parameters.append((_qpkey, _qpvalue))

        _data = {}
        if body is not None:
            _data = body

        return await self._transporter.request(
            verb=Verb.PUT,
            path="/{path}".replace("{path}", path),
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                data=dumps(bodySerializer(_data)),
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def custom_put(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        This method allow you to send requests to the Algolia REST API.


        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """
        return (
            await self.custom_put_with_http_info(
                path, parameters, body, request_options
            )
        ).deserialize(object)

    async def get_add_to_cart_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the add-to-cart rate for all of your searches with at least one add-to-cart event, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_add_to_cart_rate`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/conversions/addToCartRate",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_add_to_cart_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetAddToCartRateResponse:
        """
        Retrieves the add-to-cart rate for all of your searches with at least one add-to-cart event, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetAddToCartRateResponse' result object.
        """
        return (
            await self.get_add_to_cart_rate_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetAddToCartRateResponse)

    async def get_average_click_position_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the average click position of your search results, including a daily breakdown.  The average click position is the average of all clicked search results' positions. For example, if users only ever click on the first result for any search, the average click position is 1. By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_average_click_position`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/clicks/averageClickPosition",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_average_click_position(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetAverageClickPositionResponse:
        """
        Retrieves the average click position of your search results, including a daily breakdown.  The average click position is the average of all clicked search results' positions. For example, if users only ever click on the first result for any search, the average click position is 1. By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetAverageClickPositionResponse' result object.
        """
        return (
            await self.get_average_click_position_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetAverageClickPositionResponse)

    async def get_click_positions_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the positions in the search results and their associated number of clicks.  This lets you check how many clicks the first, second, or tenth search results receive.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_click_positions`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/clicks/positions",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_click_positions(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetClickPositionsResponse:
        """
        Retrieves the positions in the search results and their associated number of clicks.  This lets you check how many clicks the first, second, or tenth search results receive.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetClickPositionsResponse' result object.
        """
        return (
            await self.get_click_positions_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetClickPositionsResponse)

    async def get_click_through_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the click-through rate for all of your searches with at least one click event, including a daily breakdown  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_click_through_rate`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/clicks/clickThroughRate",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_click_through_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetClickThroughRateResponse:
        """
        Retrieves the click-through rate for all of your searches with at least one click event, including a daily breakdown  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetClickThroughRateResponse' result object.
        """
        return (
            await self.get_click_through_rate_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetClickThroughRateResponse)

    async def get_conversion_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the conversion rate for all of your searches with at least one conversion event, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_conversion_rate`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/conversions/conversionRate",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_conversion_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetConversionRateResponse:
        """
        Retrieves the conversion rate for all of your searches with at least one conversion event, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetConversionRateResponse' result object.
        """
        return (
            await self.get_conversion_rate_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetConversionRateResponse)

    async def get_no_click_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the fraction of searches that didn't lead to any click within a time range, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_no_click_rate`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/searches/noClickRate",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_no_click_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetNoClickRateResponse:
        """
        Retrieves the fraction of searches that didn't lead to any click within a time range, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetNoClickRateResponse' result object.
        """
        return (
            await self.get_no_click_rate_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetNoClickRateResponse)

    async def get_no_results_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the fraction of searches that didn't return any results within a time range, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_no_results_rate`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/searches/noResultRate",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_no_results_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetNoResultsRateResponse:
        """
        Retrieves the fraction of searches that didn't return any results within a time range, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetNoResultsRateResponse' result object.
        """
        return (
            await self.get_no_results_rate_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetNoResultsRateResponse)

    async def get_purchase_rate_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the purchase rate for all of your searches with at least one purchase event, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_purchase_rate`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/conversions/purchaseRate",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_purchase_rate(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetPurchaseRateResponse:
        """
        Retrieves the purchase rate for all of your searches with at least one purchase event, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetPurchaseRateResponse' result object.
        """
        return (
            await self.get_purchase_rate_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetPurchaseRateResponse)

    async def get_revenue_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves revenue-related metrics, such as the total revenue or the average order value.  To retrieve revenue-related metrics, sent purchase events. By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_revenue`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/conversions/revenue",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_revenue(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetRevenue:
        """
        Retrieves revenue-related metrics, such as the total revenue or the average order value.  To retrieve revenue-related metrics, sent purchase events. By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetRevenue' result object.
        """
        return (
            await self.get_revenue_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetRevenue)

    async def get_searches_count_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the number of searches within a time range, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_searches_count`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/searches/count",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_searches_count(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetSearchesCountResponse:
        """
        Retrieves the number of searches within a time range, including a daily breakdown.  By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetSearchesCountResponse' result object.
        """
        return (
            await self.get_searches_count_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetSearchesCountResponse)

    async def get_searches_no_clicks_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the most popular searches that didn't lead to any clicks, from the 1,000 most frequent searches.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_searches_no_clicks`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if limit is not None:
            _query_parameters.append(("limit", limit))
        if offset is not None:
            _query_parameters.append(("offset", offset))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/searches/noClicks",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_searches_no_clicks(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetSearchesNoClicksResponse:
        """
        Retrieves the most popular searches that didn't lead to any clicks, from the 1,000 most frequent searches.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetSearchesNoClicksResponse' result object.
        """
        return (
            await self.get_searches_no_clicks_with_http_info(
                index, start_date, end_date, limit, offset, tags, request_options
            )
        ).deserialize(GetSearchesNoClicksResponse)

    async def get_searches_no_results_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the most popular searches that didn't return any results.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_searches_no_results`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if limit is not None:
            _query_parameters.append(("limit", limit))
        if offset is not None:
            _query_parameters.append(("offset", offset))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/searches/noResults",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_searches_no_results(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetSearchesNoResultsResponse:
        """
        Retrieves the most popular searches that didn't return any results.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetSearchesNoResultsResponse' result object.
        """
        return (
            await self.get_searches_no_results_with_http_info(
                index, start_date, end_date, limit, offset, tags, request_options
            )
        ).deserialize(GetSearchesNoResultsResponse)

    async def get_status_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the time when the Analytics data for the specified index was last updated.  The Analytics data is updated every 5 minutes.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError("Parameter `index` is required when calling `get_status`.")

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/status",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_status(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetStatusResponse:
        """
        Retrieves the time when the Analytics data for the specified index was last updated.  The Analytics data is updated every 5 minutes.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetStatusResponse' result object.
        """
        return (
            await self.get_status_with_http_info(index, request_options)
        ).deserialize(GetStatusResponse)

    async def get_top_countries_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the countries with the most searches to your index.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_top_countries`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if limit is not None:
            _query_parameters.append(("limit", limit))
        if offset is not None:
            _query_parameters.append(("offset", offset))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/countries",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_top_countries(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetTopCountriesResponse:
        """
        Retrieves the countries with the most searches to your index.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetTopCountriesResponse' result object.
        """
        return (
            await self.get_top_countries_with_http_info(
                index, start_date, end_date, limit, offset, tags, request_options
            )
        ).deserialize(GetTopCountriesResponse)

    async def get_top_filter_attributes_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        search: Annotated[
            Optional[StrictStr], Field(description="Search query.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the most frequently used filter attributes.  These are attributes of your records that you included in the `attributesForFaceting` setting.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param search: Search query.
        :type search: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_top_filter_attributes`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if search is not None:
            _query_parameters.append(("search", search))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if limit is not None:
            _query_parameters.append(("limit", limit))
        if offset is not None:
            _query_parameters.append(("offset", offset))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/filters",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_top_filter_attributes(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        search: Annotated[
            Optional[StrictStr], Field(description="Search query.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetTopFilterAttributesResponse:
        """
        Retrieves the most frequently used filter attributes.  These are attributes of your records that you included in the `attributesForFaceting` setting.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param search: Search query.
        :type search: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetTopFilterAttributesResponse' result object.
        """
        return (
            await self.get_top_filter_attributes_with_http_info(
                index,
                search,
                start_date,
                end_date,
                limit,
                offset,
                tags,
                request_options,
            )
        ).deserialize(GetTopFilterAttributesResponse)

    async def get_top_filter_for_attribute_with_http_info(
        self,
        attribute: Annotated[StrictStr, Field(description="Attribute name.")],
        index: Annotated[StrictStr, Field(description="Index name.")],
        search: Annotated[
            Optional[StrictStr], Field(description="Search query.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the most frequent filter (facet) values for a filter attribute.  These are attributes of your records that you included in the `attributesForFaceting` setting.

        Required API Key ACLs:
          - analytics

        :param attribute: Attribute name. (required)
        :type attribute: str
        :param index: Index name. (required)
        :type index: str
        :param search: Search query.
        :type search: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if attribute is None:
            raise ValueError(
                "Parameter `attribute` is required when calling `get_top_filter_for_attribute`."
            )

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_top_filter_for_attribute`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if search is not None:
            _query_parameters.append(("search", search))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if limit is not None:
            _query_parameters.append(("limit", limit))
        if offset is not None:
            _query_parameters.append(("offset", offset))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/filters/{attribute}".replace(
                "{attribute}", quote(str(attribute), safe="")
            ),
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_top_filter_for_attribute(
        self,
        attribute: Annotated[StrictStr, Field(description="Attribute name.")],
        index: Annotated[StrictStr, Field(description="Index name.")],
        search: Annotated[
            Optional[StrictStr], Field(description="Search query.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetTopFilterForAttributeResponse:
        """
        Retrieves the most frequent filter (facet) values for a filter attribute.  These are attributes of your records that you included in the `attributesForFaceting` setting.

        Required API Key ACLs:
          - analytics

        :param attribute: Attribute name. (required)
        :type attribute: str
        :param index: Index name. (required)
        :type index: str
        :param search: Search query.
        :type search: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetTopFilterForAttributeResponse' result object.
        """
        return (
            await self.get_top_filter_for_attribute_with_http_info(
                attribute,
                index,
                search,
                start_date,
                end_date,
                limit,
                offset,
                tags,
                request_options,
            )
        ).deserialize(GetTopFilterForAttributeResponse)

    async def get_top_filters_no_results_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        search: Annotated[
            Optional[StrictStr], Field(description="Search query.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the most frequently used filters for a search that didn't return any results.  To get the most frequent searches without results, use the [Retrieve searches without results](#tag/search/operation/getSearchesNoResults) operation.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param search: Search query.
        :type search: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_top_filters_no_results`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if search is not None:
            _query_parameters.append(("search", search))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if limit is not None:
            _query_parameters.append(("limit", limit))
        if offset is not None:
            _query_parameters.append(("offset", offset))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/filters/noResults",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_top_filters_no_results(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        search: Annotated[
            Optional[StrictStr], Field(description="Search query.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetTopFiltersNoResultsResponse:
        """
        Retrieves the most frequently used filters for a search that didn't return any results.  To get the most frequent searches without results, use the [Retrieve searches without results](#tag/search/operation/getSearchesNoResults) operation.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param search: Search query.
        :type search: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetTopFiltersNoResultsResponse' result object.
        """
        return (
            await self.get_top_filters_no_results_with_http_info(
                index,
                search,
                start_date,
                end_date,
                limit,
                offset,
                tags,
                request_options,
            )
        ).deserialize(GetTopFiltersNoResultsResponse)

    async def get_top_hits_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        search: Annotated[
            Optional[StrictStr], Field(description="Search query.")
        ] = None,
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include metrics related to click and conversion events in the response."
            ),
        ] = None,
        revenue_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include revenue-related metrics in the response.  If true, metrics related to click and conversion events are also included in the response. "
            ),
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the object IDs of the most frequent search results.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param search: Search query.
        :type search: str
        :param click_analytics: Whether to include metrics related to click and conversion events in the response.
        :type click_analytics: bool
        :param revenue_analytics: Whether to include revenue-related metrics in the response.  If true, metrics related to click and conversion events are also included in the response.
        :type revenue_analytics: bool
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_top_hits`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if search is not None:
            _query_parameters.append(("search", search))
        if click_analytics is not None:
            _query_parameters.append(("clickAnalytics", click_analytics))
        if revenue_analytics is not None:
            _query_parameters.append(("revenueAnalytics", revenue_analytics))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if limit is not None:
            _query_parameters.append(("limit", limit))
        if offset is not None:
            _query_parameters.append(("offset", offset))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/hits",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_top_hits(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        search: Annotated[
            Optional[StrictStr], Field(description="Search query.")
        ] = None,
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include metrics related to click and conversion events in the response."
            ),
        ] = None,
        revenue_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include revenue-related metrics in the response.  If true, metrics related to click and conversion events are also included in the response. "
            ),
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetTopHitsResponse:
        """
        Retrieves the object IDs of the most frequent search results.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param search: Search query.
        :type search: str
        :param click_analytics: Whether to include metrics related to click and conversion events in the response.
        :type click_analytics: bool
        :param revenue_analytics: Whether to include revenue-related metrics in the response.  If true, metrics related to click and conversion events are also included in the response.
        :type revenue_analytics: bool
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetTopHitsResponse' result object.
        """
        return (
            await self.get_top_hits_with_http_info(
                index,
                search,
                click_analytics,
                revenue_analytics,
                start_date,
                end_date,
                limit,
                offset,
                tags,
                request_options,
            )
        ).deserialize(GetTopHitsResponse)

    async def get_top_searches_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include metrics related to click and conversion events in the response."
            ),
        ] = None,
        revenue_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include revenue-related metrics in the response.  If true, metrics related to click and conversion events are also included in the response. "
            ),
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        order_by: Annotated[
            Optional[OrderBy],
            Field(
                description="Attribute by which to order the response items.  If the `clickAnalytics` parameter is false, only `searchCount` is available. "
            ),
        ] = None,
        direction: Annotated[
            Optional[Direction],
            Field(
                description="Sorting direction of the results: ascending or descending. "
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Returns the most popular search terms.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param click_analytics: Whether to include metrics related to click and conversion events in the response.
        :type click_analytics: bool
        :param revenue_analytics: Whether to include revenue-related metrics in the response.  If true, metrics related to click and conversion events are also included in the response.
        :type revenue_analytics: bool
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param order_by: Attribute by which to order the response items.  If the `clickAnalytics` parameter is false, only `searchCount` is available.
        :type order_by: OrderBy
        :param direction: Sorting direction of the results: ascending or descending.
        :type direction: Direction
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_top_searches`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if click_analytics is not None:
            _query_parameters.append(("clickAnalytics", click_analytics))
        if revenue_analytics is not None:
            _query_parameters.append(("revenueAnalytics", revenue_analytics))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if order_by is not None:
            _query_parameters.append(("orderBy", order_by))
        if direction is not None:
            _query_parameters.append(("direction", direction))
        if limit is not None:
            _query_parameters.append(("limit", limit))
        if offset is not None:
            _query_parameters.append(("offset", offset))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/searches",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_top_searches(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        click_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include metrics related to click and conversion events in the response."
            ),
        ] = None,
        revenue_analytics: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include revenue-related metrics in the response.  If true, metrics related to click and conversion events are also included in the response. "
            ),
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        order_by: Annotated[
            Optional[OrderBy],
            Field(
                description="Attribute by which to order the response items.  If the `clickAnalytics` parameter is false, only `searchCount` is available. "
            ),
        ] = None,
        direction: Annotated[
            Optional[Direction],
            Field(
                description="Sorting direction of the results: ascending or descending. "
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="Number of items to return.")
        ] = None,
        offset: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(description="Position of the first item to return."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetTopSearchesResponse:
        """
        Returns the most popular search terms.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param click_analytics: Whether to include metrics related to click and conversion events in the response.
        :type click_analytics: bool
        :param revenue_analytics: Whether to include revenue-related metrics in the response.  If true, metrics related to click and conversion events are also included in the response.
        :type revenue_analytics: bool
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param order_by: Attribute by which to order the response items.  If the `clickAnalytics` parameter is false, only `searchCount` is available.
        :type order_by: OrderBy
        :param direction: Sorting direction of the results: ascending or descending.
        :type direction: Direction
        :param limit: Number of items to return.
        :type limit: int
        :param offset: Position of the first item to return.
        :type offset: int
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetTopSearchesResponse' result object.
        """
        return (
            await self.get_top_searches_with_http_info(
                index,
                click_analytics,
                revenue_analytics,
                start_date,
                end_date,
                order_by,
                direction,
                limit,
                offset,
                tags,
                request_options,
            )
        ).deserialize(GetTopSearchesResponse)

    async def get_users_count_with_http_info(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieves the number of unique users within a time range, including a daily breakdown.  Since this endpoint returns the number of unique users, the sum of the daily values might be different from the total number.  By default, Algolia distinguishes search users by their IP address, _unless_ you include a pseudonymous user identifier in your search requests with the `userToken` API parameter or `x-algolia-usertoken` request header. By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index is None:
            raise ValueError(
                "Parameter `index` is required when calling `get_users_count`."
            )

        _query_parameters: List[Tuple[str, str]] = []

        if index is not None:
            _query_parameters.append(("index", index))
        if start_date is not None:
            _query_parameters.append(("startDate", start_date))
        if end_date is not None:
            _query_parameters.append(("endDate", end_date))
        if tags is not None:
            _query_parameters.append(("tags", tags))

        return await self._transporter.request(
            verb=Verb.GET,
            path="/2/users/count",
            request_options=self._request_options.merge(
                query_parameters=_query_parameters,
                user_request_options=request_options,
            ),
            use_read_transporter=False,
        )

    async def get_users_count(
        self,
        index: Annotated[StrictStr, Field(description="Index name.")],
        start_date: Annotated[
            Optional[StrictStr],
            Field(description="Start date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(description="End date (`YYYY-MM-DD`) of the period to analyze."),
        ] = None,
        tags: Annotated[
            Optional[StrictStr],
            Field(
                description="Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/). "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetUsersCountResponse:
        """
        Retrieves the number of unique users within a time range, including a daily breakdown.  Since this endpoint returns the number of unique users, the sum of the daily values might be different from the total number.  By default, Algolia distinguishes search users by their IP address, _unless_ you include a pseudonymous user identifier in your search requests with the `userToken` API parameter or `x-algolia-usertoken` request header. By default, the analyzed period includes the last eight days including the current day.

        Required API Key ACLs:
          - analytics

        :param index: Index name. (required)
        :type index: str
        :param start_date: Start date (`YYYY-MM-DD`) of the period to analyze.
        :type start_date: str
        :param end_date: End date (`YYYY-MM-DD`) of the period to analyze.
        :type end_date: str
        :param tags: Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
        :type tags: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetUsersCountResponse' result object.
        """
        return (
            await self.get_users_count_with_http_info(
                index, start_date, end_date, tags, request_options
            )
        ).deserialize(GetUsersCountResponse)
