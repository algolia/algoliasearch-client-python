# coding: utf-8

"""
Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
"""
from __future__ import annotations

from typing import Annotated, Any, Dict, List, Optional, Tuple, Union
from urllib.parse import quote

from pydantic import Field, StrictBool, StrictInt, StrictStr

from algoliasearch.http import ApiResponse, RequestOptions, Transporter, Verb
from algoliasearch.search.config import Config
from algoliasearch.search.models import (
    AddApiKeyResponse,
    ApiKey,
    AssignUserIdParams,
    AttributeToUpdate,
    BatchAssignUserIdsParams,
    BatchDictionaryEntriesParams,
    BatchParams,
    BatchResponse,
    BatchWriteParams,
    BrowseParams,
    BrowseResponse,
    CreatedAtResponse,
    DeleteApiKeyResponse,
    DeleteByParams,
    DeletedAtResponse,
    DeleteSourceResponse,
    DictionarySettingsParams,
    DictionaryType,
    GetApiKeyResponse,
    GetDictionarySettingsResponse,
    GetLogsResponse,
    GetObjectsParams,
    GetObjectsResponse,
    GetTaskResponse,
    GetTopUserIdsResponse,
    HasPendingMappingsResponse,
    IndexSettings,
    Languages,
    ListApiKeysResponse,
    ListClustersResponse,
    ListIndicesResponse,
    ListUserIdsResponse,
    LogType,
    MultipleBatchResponse,
    OperationIndexParams,
    RemoveUserIdResponse,
    ReplaceSourceResponse,
    Rule,
    SaveObjectResponse,
    SaveSynonymResponse,
    SearchDictionaryEntriesParams,
    SearchForFacetValuesRequest,
    SearchForFacetValuesResponse,
    SearchMethodParams,
    SearchParams,
    SearchResponse,
    SearchResponses,
    SearchRulesParams,
    SearchRulesResponse,
    SearchSynonymsParams,
    SearchSynonymsResponse,
    SearchUserIdsParams,
    SearchUserIdsResponse,
    Source,
    SynonymHit,
    SynonymType,
    UpdateApiKeyResponse,
    UpdatedAtResponse,
    UpdatedAtWithObjectIdResponse,
    UpdatedRuleResponse,
    UserId,
)

try:
    from typing import Self
except ImportError:
    from typing_extensions import Self


class SearchClient:
    def app_id(self) -> str:
        return self._config.app_id

    def __init__(self, transporter: Transporter, config: Config) -> None:
        self._transporter = transporter
        self._config = config

    def create_with_config(config: Config) -> Self:
        transporter = Transporter(config)

        return SearchClient(transporter, config)

    def create(app_id: Optional[str] = None, api_key: Optional[str] = None) -> Self:
        return SearchClient.create_with_config(Config(app_id, api_key))

    async def close(self) -> None:
        return await self._transporter.close()

    async def add_api_key_with_http_info(
        self,
        api_key: ApiKey,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Add API key.

        Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string.

        :param api_key: (required)
        :type api_key: ApiKey
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if api_key is None:
            raise ValueError("'api_key' is required when calling 'add_api_key'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/keys"

        if api_key is not None:
            _body = api_key

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def add_api_key(
        self,
        api_key: ApiKey,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> AddApiKeyResponse:
        """
        Add API key.

        Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string.

        :param api_key: (required)
        :type api_key: ApiKey
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'AddApiKeyResponse' result object.
        """

        response = await self.add_api_key_with_http_info(api_key, request_options)

        return response.deserialize(AddApiKeyResponse)

    async def add_or_update_object_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique record (object) identifier.")
        ],
        body: Annotated[Dict[str, Any], Field(description="Algolia record.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Add or update a record (using objectID).

        If you use an existing `objectID`, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique record (object) identifier. (required)
        :type object_id: str
        :param body: Algolia record. (required)
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError(
                "'index_name' is required when calling 'add_or_update_object'"
            )

        if object_id is None:
            raise ValueError(
                "'object_id' is required when calling 'add_or_update_object'"
            )

        if body is None:
            raise ValueError("'body' is required when calling 'add_or_update_object'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/{objectID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        if body is not None:
            _body = body

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def add_or_update_object(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique record (object) identifier.")
        ],
        body: Annotated[Dict[str, Any], Field(description="Algolia record.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtWithObjectIdResponse:
        """
        Add or update a record (using objectID).

        If you use an existing `objectID`, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique record (object) identifier. (required)
        :type object_id: str
        :param body: Algolia record. (required)
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtWithObjectIdResponse' result object.
        """

        response = await self.add_or_update_object_with_http_info(
            index_name, object_id, body, request_options
        )

        return response.deserialize(UpdatedAtWithObjectIdResponse)

    async def append_source_with_http_info(
        self,
        source: Annotated[Source, Field(description="Source to add.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Add a source.

        Add a source to the list of allowed sources.

        :param source: Source to add. (required)
        :type source: Source
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if source is None:
            raise ValueError("'source' is required when calling 'append_source'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/security/sources/append"

        if source is not None:
            _body = source

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def append_source(
        self,
        source: Annotated[Source, Field(description="Source to add.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> CreatedAtResponse:
        """
        Add a source.

        Add a source to the list of allowed sources.

        :param source: Source to add. (required)
        :type source: Source
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'CreatedAtResponse' result object.
        """

        response = await self.append_source_with_http_info(source, request_options)

        return response.deserialize(CreatedAtResponse)

    async def assign_user_id_with_http_info(
        self,
        x_algolia_user_id: Annotated[
            str, Field(strict=True, description="userID to assign.")
        ],
        assign_user_id_params: AssignUserIdParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Assign or move a user ID.

        Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID.

        :param x_algolia_user_id: userID to assign. (required)
        :type x_algolia_user_id: str
        :param assign_user_id_params: (required)
        :type assign_user_id_params: AssignUserIdParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if x_algolia_user_id is None:
            raise ValueError(
                "'x_algolia_user_id' is required when calling 'assign_user_id'"
            )

        if assign_user_id_params is None:
            raise ValueError(
                "'assign_user_id_params' is required when calling 'assign_user_id'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/clusters/mapping"

        if assign_user_id_params is not None:
            _body = assign_user_id_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def assign_user_id(
        self,
        x_algolia_user_id: Annotated[
            str, Field(strict=True, description="userID to assign.")
        ],
        assign_user_id_params: AssignUserIdParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> CreatedAtResponse:
        """
        Assign or move a user ID.

        Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID.

        :param x_algolia_user_id: userID to assign. (required)
        :type x_algolia_user_id: str
        :param assign_user_id_params: (required)
        :type assign_user_id_params: AssignUserIdParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'CreatedAtResponse' result object.
        """

        response = await self.assign_user_id_with_http_info(
            x_algolia_user_id, assign_user_id_params, request_options
        )

        return response.deserialize(CreatedAtResponse)

    async def batch_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        batch_write_params: BatchWriteParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Batch write operations on one index.

        To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported `action`s are equivalent to the individual operations of the same name.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param batch_write_params: (required)
        :type batch_write_params: BatchWriteParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'batch'")

        if batch_write_params is None:
            raise ValueError("'batch_write_params' is required when calling 'batch'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/batch".replace(
            "{indexName}", quote(str(index_name))
        )

        if batch_write_params is not None:
            _body = batch_write_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def batch(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        batch_write_params: BatchWriteParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> BatchResponse:
        """
        Batch write operations on one index.

        To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported `action`s are equivalent to the individual operations of the same name.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param batch_write_params: (required)
        :type batch_write_params: BatchWriteParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'BatchResponse' result object.
        """

        response = await self.batch_with_http_info(
            index_name, batch_write_params, request_options
        )

        return response.deserialize(BatchResponse)

    async def batch_assign_user_ids_with_http_info(
        self,
        x_algolia_user_id: Annotated[
            str, Field(strict=True, description="userID to assign.")
        ],
        batch_assign_user_ids_params: BatchAssignUserIdsParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Batch assign userIDs.

        Assign multiple user IDs to a cluster. **You can't _move_ users with this operation.**.

        :param x_algolia_user_id: userID to assign. (required)
        :type x_algolia_user_id: str
        :param batch_assign_user_ids_params: (required)
        :type batch_assign_user_ids_params: BatchAssignUserIdsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if x_algolia_user_id is None:
            raise ValueError(
                "'x_algolia_user_id' is required when calling 'batch_assign_user_ids'"
            )

        if batch_assign_user_ids_params is None:
            raise ValueError(
                "'batch_assign_user_ids_params' is required when calling 'batch_assign_user_ids'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/clusters/mapping/batch"

        if batch_assign_user_ids_params is not None:
            _body = batch_assign_user_ids_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def batch_assign_user_ids(
        self,
        x_algolia_user_id: Annotated[
            str, Field(strict=True, description="userID to assign.")
        ],
        batch_assign_user_ids_params: BatchAssignUserIdsParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> CreatedAtResponse:
        """
        Batch assign userIDs.

        Assign multiple user IDs to a cluster. **You can't _move_ users with this operation.**.

        :param x_algolia_user_id: userID to assign. (required)
        :type x_algolia_user_id: str
        :param batch_assign_user_ids_params: (required)
        :type batch_assign_user_ids_params: BatchAssignUserIdsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'CreatedAtResponse' result object.
        """

        response = await self.batch_assign_user_ids_with_http_info(
            x_algolia_user_id, batch_assign_user_ids_params, request_options
        )

        return response.deserialize(CreatedAtResponse)

    async def batch_dictionary_entries_with_http_info(
        self,
        dictionary_name: Annotated[
            DictionaryType, Field(description="Dictionary to search in.")
        ],
        batch_dictionary_entries_params: BatchDictionaryEntriesParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Batch dictionary entries.

        Add or remove a batch of dictionary entries.

        :param dictionary_name: Dictionary to search in. (required)
        :type dictionary_name: DictionaryType
        :param batch_dictionary_entries_params: (required)
        :type batch_dictionary_entries_params: BatchDictionaryEntriesParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if dictionary_name is None:
            raise ValueError(
                "'dictionary_name' is required when calling 'batch_dictionary_entries'"
            )

        if batch_dictionary_entries_params is None:
            raise ValueError(
                "'batch_dictionary_entries_params' is required when calling 'batch_dictionary_entries'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/dictionaries/{dictionaryName}/batch".replace(
            "{dictionaryName}", quote(str(dictionary_name))
        )

        if batch_dictionary_entries_params is not None:
            _body = batch_dictionary_entries_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def batch_dictionary_entries(
        self,
        dictionary_name: Annotated[
            DictionaryType, Field(description="Dictionary to search in.")
        ],
        batch_dictionary_entries_params: BatchDictionaryEntriesParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Batch dictionary entries.

        Add or remove a batch of dictionary entries.

        :param dictionary_name: Dictionary to search in. (required)
        :type dictionary_name: DictionaryType
        :param batch_dictionary_entries_params: (required)
        :type batch_dictionary_entries_params: BatchDictionaryEntriesParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.batch_dictionary_entries_with_http_info(
            dictionary_name, batch_dictionary_entries_params, request_options
        )

        return response.deserialize(UpdatedAtResponse)

    async def browse_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        browse_params: Optional[BrowseParams] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get all records from an index.

        Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn't support: - The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param browse_params:
        :type browse_params: BrowseParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'browse'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/browse".replace(
            "{indexName}", quote(str(index_name))
        )

        if browse_params is not None:
            _body = browse_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def browse(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        browse_params: Optional[BrowseParams] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> BrowseResponse:
        """
        Get all records from an index.

        Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn't support: - The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param browse_params:
        :type browse_params: BrowseParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'BrowseResponse' result object.
        """

        response = await self.browse_with_http_info(
            index_name, browse_params, request_options
        )

        return response.deserialize(BrowseResponse)

    async def clear_all_synonyms_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete all synonyms.

        Delete all synonyms in the index.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError(
                "'index_name' is required when calling 'clear_all_synonyms'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/synonyms/clear".replace(
            "{indexName}", quote(str(index_name))
        )

        if forward_to_replicas is not None:
            _query_params.append(("forwardToReplicas", forward_to_replicas))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def clear_all_synonyms(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Delete all synonyms.

        Delete all synonyms in the index.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.clear_all_synonyms_with_http_info(
            index_name, forward_to_replicas, request_options
        )

        return response.deserialize(UpdatedAtResponse)

    async def clear_objects_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete all records from an index.

        Delete the records but leave settings and index-specific API keys untouched.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'clear_objects'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/clear".replace(
            "{indexName}", quote(str(index_name))
        )

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def clear_objects(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Delete all records from an index.

        Delete the records but leave settings and index-specific API keys untouched.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.clear_objects_with_http_info(index_name, request_options)

        return response.deserialize(UpdatedAtResponse)

    async def clear_rules_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete all rules.

        Delete all rules in the index.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'clear_rules'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/rules/clear".replace(
            "{indexName}", quote(str(index_name))
        )

        if forward_to_replicas is not None:
            _query_params.append(("forwardToReplicas", forward_to_replicas))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def clear_rules(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Delete all rules.

        Delete all rules in the index.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.clear_rules_with_http_info(
            index_name, forward_to_replicas, request_options
        )

        return response.deserialize(UpdatedAtResponse)

    async def custom_delete_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if path is None:
            raise ValueError("'path' is required when calling 'custom_delete'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1{path}".replace("{path}", path)

        if parameters is not None:
            _query_params.append(("parameters", parameters))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def custom_delete(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """

        response = await self.custom_delete_with_http_info(
            path, parameters, request_options
        )

        return response.deserialize(object)

    async def custom_get_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if path is None:
            raise ValueError("'path' is required when calling 'custom_get'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1{path}".replace("{path}", path)

        if parameters is not None:
            _query_params.append(("parameters", parameters))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def custom_get(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """

        response = await self.custom_get_with_http_info(
            path, parameters, request_options
        )

        return response.deserialize(object)

    async def custom_post_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if path is None:
            raise ValueError("'path' is required when calling 'custom_post'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1{path}".replace("{path}", path)

        if parameters is not None:
            _query_params.append(("parameters", parameters))

        if body is not None:
            _body = body

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def custom_post(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """

        response = await self.custom_post_with_http_info(
            path, parameters, body, request_options
        )

        return response.deserialize(object)

    async def custom_put_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if path is None:
            raise ValueError("'path' is required when calling 'custom_put'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1{path}".replace("{path}", path)

        if parameters is not None:
            _query_params.append(("parameters", parameters))

        if body is not None:
            _body = body

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def custom_put(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """

        response = await self.custom_put_with_http_info(
            path, parameters, body, request_options
        )

        return response.deserialize(object)

    async def delete_api_key_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="API key.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete API key.

        Delete an existing API key. The request must be authenticated with the admin API key.

        :param key: API key. (required)
        :type key: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if key is None:
            raise ValueError("'key' is required when calling 'delete_api_key'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/keys/{key}".replace("{key}", quote(str(key)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def delete_api_key(
        self,
        key: Annotated[StrictStr, Field(description="API key.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeleteApiKeyResponse:
        """
        Delete API key.

        Delete an existing API key. The request must be authenticated with the admin API key.

        :param key: API key. (required)
        :type key: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeleteApiKeyResponse' result object.
        """

        response = await self.delete_api_key_with_http_info(key, request_options)

        return response.deserialize(DeleteApiKeyResponse)

    async def delete_by_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        delete_by_params: DeleteByParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete all records matching a query.

        This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn't accept empty filters or queries.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param delete_by_params: (required)
        :type delete_by_params: DeleteByParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'delete_by'")

        if delete_by_params is None:
            raise ValueError("'delete_by_params' is required when calling 'delete_by'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/deleteByQuery".replace(
            "{indexName}", quote(str(index_name))
        )

        if delete_by_params is not None:
            _body = delete_by_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def delete_by(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        delete_by_params: DeleteByParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeletedAtResponse:
        """
        Delete all records matching a query.

        This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn't accept empty filters or queries.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param delete_by_params: (required)
        :type delete_by_params: DeleteByParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeletedAtResponse' result object.
        """

        response = await self.delete_by_with_http_info(
            index_name, delete_by_params, request_options
        )

        return response.deserialize(DeletedAtResponse)

    async def delete_index_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete index.

        Delete an existing index.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'delete_index'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}".replace("{indexName}", quote(str(index_name)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def delete_index(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeletedAtResponse:
        """
        Delete index.

        Delete an existing index.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeletedAtResponse' result object.
        """

        response = await self.delete_index_with_http_info(index_name, request_options)

        return response.deserialize(DeletedAtResponse)

    async def delete_object_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique record (object) identifier.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete a record.

        To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy) instead.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique record (object) identifier. (required)
        :type object_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'delete_object'")

        if object_id is None:
            raise ValueError("'object_id' is required when calling 'delete_object'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/{objectID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def delete_object(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique record (object) identifier.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeletedAtResponse:
        """
        Delete a record.

        To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy) instead.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique record (object) identifier. (required)
        :type object_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeletedAtResponse' result object.
        """

        response = await self.delete_object_with_http_info(
            index_name, object_id, request_options
        )

        return response.deserialize(DeletedAtResponse)

    async def delete_rule_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a rule object.")
        ],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete a rule.

        Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a rule object. (required)
        :type object_id: str
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'delete_rule'")

        if object_id is None:
            raise ValueError("'object_id' is required when calling 'delete_rule'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/rules/{objectID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        if forward_to_replicas is not None:
            _query_params.append(("forwardToReplicas", forward_to_replicas))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def delete_rule(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a rule object.")
        ],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Delete a rule.

        Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a rule object. (required)
        :type object_id: str
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.delete_rule_with_http_info(
            index_name, object_id, forward_to_replicas, request_options
        )

        return response.deserialize(UpdatedAtResponse)

    async def delete_source_with_http_info(
        self,
        source: Annotated[
            StrictStr, Field(description="IP address range of the source.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Remove a source.

        Remove a source from the list of allowed sources.

        :param source: IP address range of the source. (required)
        :type source: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if source is None:
            raise ValueError("'source' is required when calling 'delete_source'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/security/sources/{source}".replace("{source}", quote(str(source)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def delete_source(
        self,
        source: Annotated[
            StrictStr, Field(description="IP address range of the source.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeleteSourceResponse:
        """
        Remove a source.

        Remove a source from the list of allowed sources.

        :param source: IP address range of the source. (required)
        :type source: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeleteSourceResponse' result object.
        """

        response = await self.delete_source_with_http_info(source, request_options)

        return response.deserialize(DeleteSourceResponse)

    async def delete_synonym_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a synonym object.")
        ],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete a synonym.

        Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a synonym object. (required)
        :type object_id: str
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'delete_synonym'")

        if object_id is None:
            raise ValueError("'object_id' is required when calling 'delete_synonym'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/synonyms/{objectID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        if forward_to_replicas is not None:
            _query_params.append(("forwardToReplicas", forward_to_replicas))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def delete_synonym(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a synonym object.")
        ],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeletedAtResponse:
        """
        Delete a synonym.

        Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a synonym object. (required)
        :type object_id: str
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeletedAtResponse' result object.
        """

        response = await self.delete_synonym_with_http_info(
            index_name, object_id, forward_to_replicas, request_options
        )

        return response.deserialize(DeletedAtResponse)

    async def get_api_key_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="API key.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get API key permissions.

        Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key.

        :param key: API key. (required)
        :type key: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if key is None:
            raise ValueError("'key' is required when calling 'get_api_key'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/keys/{key}".replace("{key}", quote(str(key)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_api_key(
        self,
        key: Annotated[StrictStr, Field(description="API key.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetApiKeyResponse:
        """
        Get API key permissions.

        Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key.

        :param key: API key. (required)
        :type key: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetApiKeyResponse' result object.
        """

        response = await self.get_api_key_with_http_info(key, request_options)

        return response.deserialize(GetApiKeyResponse)

    async def get_dictionary_languages_with_http_info(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> ApiResponse[str]:
        """
        List available languages.

        Lists Algolia's [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language's [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/dictionaries/*/languages"

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_dictionary_languages(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> Dict[str, Languages]:
        """
        List available languages.

        Lists Algolia's [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language's [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'Dict[str, Languages]' result object.
        """

        response = await self.get_dictionary_languages_with_http_info(request_options)

        return response.deserialize(Dict[str, Languages])

    async def get_dictionary_settings_with_http_info(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> ApiResponse[str]:
        """
        Get stop word settings.

        Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/dictionaries/*/settings"

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_dictionary_settings(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> GetDictionarySettingsResponse:
        """
        Get stop word settings.

        Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetDictionarySettingsResponse' result object.
        """

        response = await self.get_dictionary_settings_with_http_info(request_options)

        return response.deserialize(GetDictionarySettingsResponse)

    async def get_logs_with_http_info(
        self,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="First log entry to retrieve. Sorted by decreasing date with 0 being the most recent."
            ),
        ] = None,
        length: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True)]],
            Field(description="Maximum number of entries to retrieve."),
        ] = None,
        index_name: Annotated[
            Optional[StrictStr],
            Field(
                description="Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices."
            ),
        ] = None,
        type: Annotated[
            Optional[LogType],
            Field(
                description="Type of log entries to retrieve. When omitted, all log entries are retrieved."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Return the latest log entries.

        The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There's also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself. > **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN's endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).

        :param offset: First log entry to retrieve. Sorted by decreasing date with 0 being the most recent.
        :type offset: int
        :param length: Maximum number of entries to retrieve.
        :type length: int
        :param index_name: Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
        :type index_name: str
        :param type: Type of log entries to retrieve. When omitted, all log entries are retrieved.
        :type type: LogType
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/logs"

        if offset is not None:
            _query_params.append(("offset", offset))
        if length is not None:
            _query_params.append(("length", length))
        if index_name is not None:
            _query_params.append(("indexName", index_name))
        if type is not None:
            _query_params.append(("type", type.value))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_logs(
        self,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="First log entry to retrieve. Sorted by decreasing date with 0 being the most recent."
            ),
        ] = None,
        length: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True)]],
            Field(description="Maximum number of entries to retrieve."),
        ] = None,
        index_name: Annotated[
            Optional[StrictStr],
            Field(
                description="Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices."
            ),
        ] = None,
        type: Annotated[
            Optional[LogType],
            Field(
                description="Type of log entries to retrieve. When omitted, all log entries are retrieved."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetLogsResponse:
        """
        Return the latest log entries.

        The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There's also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself. > **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN's endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).

        :param offset: First log entry to retrieve. Sorted by decreasing date with 0 being the most recent.
        :type offset: int
        :param length: Maximum number of entries to retrieve.
        :type length: int
        :param index_name: Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
        :type index_name: str
        :param type: Type of log entries to retrieve. When omitted, all log entries are retrieved.
        :type type: LogType
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetLogsResponse' result object.
        """

        response = await self.get_logs_with_http_info(
            offset, length, index_name, type, request_options
        )

        return response.deserialize(GetLogsResponse)

    async def get_object_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique record (object) identifier.")
        ],
        attributes_to_retrieve: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified. [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won't be retrieved unless the request is authenticated with the admin API key. "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a record.

        To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique record (object) identifier. (required)
        :type object_id: str
        :param attributes_to_retrieve: Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified. [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won't be retrieved unless the request is authenticated with the admin API key.
        :type attributes_to_retrieve: List[str]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'get_object'")

        if object_id is None:
            raise ValueError("'object_id' is required when calling 'get_object'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/{objectID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        if attributes_to_retrieve is not None:
            _query_params.append(("attributesToRetrieve", attributes_to_retrieve))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_object(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique record (object) identifier.")
        ],
        attributes_to_retrieve: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified. [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won't be retrieved unless the request is authenticated with the admin API key. "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> Dict[str, str]:
        """
        Get a record.

        To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique record (object) identifier. (required)
        :type object_id: str
        :param attributes_to_retrieve: Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified. [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won't be retrieved unless the request is authenticated with the admin API key.
        :type attributes_to_retrieve: List[str]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'Dict[str, str]' result object.
        """

        response = await self.get_object_with_http_info(
            index_name, object_id, attributes_to_retrieve, request_options
        )

        return response.deserialize(Dict[str, str])

    async def get_objects_with_http_info(
        self,
        get_objects_params: Annotated[
            GetObjectsParams, Field(description="Request object.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get multiple records.

        Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.

        :param get_objects_params: Request object. (required)
        :type get_objects_params: GetObjectsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if get_objects_params is None:
            raise ValueError(
                "'get_objects_params' is required when calling 'get_objects'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/*/objects"

        if get_objects_params is not None:
            _body = get_objects_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_objects(
        self,
        get_objects_params: Annotated[
            GetObjectsParams, Field(description="Request object.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetObjectsResponse:
        """
        Get multiple records.

        Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.

        :param get_objects_params: Request object. (required)
        :type get_objects_params: GetObjectsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetObjectsResponse' result object.
        """

        response = await self.get_objects_with_http_info(
            get_objects_params, request_options
        )

        return response.deserialize(GetObjectsResponse)

    async def get_rule_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a rule object.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a rule.

        Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a rule object. (required)
        :type object_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'get_rule'")

        if object_id is None:
            raise ValueError("'object_id' is required when calling 'get_rule'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/rules/{objectID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_rule(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a rule object.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> Rule:
        """
        Get a rule.

        Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a rule object. (required)
        :type object_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'Rule' result object.
        """

        response = await self.get_rule_with_http_info(
            index_name, object_id, request_options
        )

        return response.deserialize(Rule)

    async def get_settings_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get index settings.

        Return an object containing an index's [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'get_settings'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/settings".replace(
            "{indexName}", quote(str(index_name))
        )

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_settings(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> IndexSettings:
        """
        Get index settings.

        Return an object containing an index's [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'IndexSettings' result object.
        """

        response = await self.get_settings_with_http_info(index_name, request_options)

        return response.deserialize(IndexSettings)

    async def get_sources_with_http_info(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> ApiResponse[str]:
        """
        Get all allowed IP addresses.

        Get all allowed sources (IP addresses).

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/security/sources"

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_sources(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> List[Source]:
        """
        Get all allowed IP addresses.

        Get all allowed sources (IP addresses).

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'List[Source]' result object.
        """

        response = await self.get_sources_with_http_info(request_options)

        return response.deserialize(List[Source])

    async def get_synonym_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a synonym object.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a synonym object.

        Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a synonym object. (required)
        :type object_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'get_synonym'")

        if object_id is None:
            raise ValueError("'object_id' is required when calling 'get_synonym'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/synonyms/{objectID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_synonym(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a synonym object.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SynonymHit:
        """
        Get a synonym object.

        Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a synonym object. (required)
        :type object_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SynonymHit' result object.
        """

        response = await self.get_synonym_with_http_info(
            index_name, object_id, request_options
        )

        return response.deserialize(SynonymHit)

    async def get_task_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        task_id: Annotated[StrictInt, Field(description="Unique task identifier.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Check a task's status.

        Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the status of that task.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param task_id: Unique task identifier. (required)
        :type task_id: int
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'get_task'")

        if task_id is None:
            raise ValueError("'task_id' is required when calling 'get_task'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/task/{taskID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{taskID}", quote(str(task_id)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_task(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        task_id: Annotated[StrictInt, Field(description="Unique task identifier.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> GetTaskResponse:
        """
        Check a task's status.

        Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the status of that task.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param task_id: Unique task identifier. (required)
        :type task_id: int
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetTaskResponse' result object.
        """

        response = await self.get_task_with_http_info(
            index_name, task_id, request_options
        )

        return response.deserialize(GetTaskResponse)

    async def get_top_user_ids_with_http_info(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> ApiResponse[str]:
        """
        Get top userID.

        Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/clusters/mapping/top"

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_top_user_ids(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> GetTopUserIdsResponse:
        """
        Get top userID.

        Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'GetTopUserIdsResponse' result object.
        """

        response = await self.get_top_user_ids_with_http_info(request_options)

        return response.deserialize(GetTopUserIdsResponse)

    async def get_user_id_with_http_info(
        self,
        user_id: Annotated[str, Field(strict=True, description="userID to assign.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get userID.

        Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

        :param user_id: userID to assign. (required)
        :type user_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if user_id is None:
            raise ValueError("'user_id' is required when calling 'get_user_id'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/clusters/mapping/{userID}".replace("{userID}", quote(str(user_id)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def get_user_id(
        self,
        user_id: Annotated[str, Field(strict=True, description="userID to assign.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UserId:
        """
        Get userID.

        Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

        :param user_id: userID to assign. (required)
        :type user_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UserId' result object.
        """

        response = await self.get_user_id_with_http_info(user_id, request_options)

        return response.deserialize(UserId)

    async def has_pending_mappings_with_http_info(
        self,
        get_clusters: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether to include the cluster's pending mapping state in the response."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get migration and user mapping status.

        To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.

        :param get_clusters: Indicates whether to include the cluster's pending mapping state in the response.
        :type get_clusters: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/clusters/mapping/pending"

        if get_clusters is not None:
            _query_params.append(("getClusters", get_clusters))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def has_pending_mappings(
        self,
        get_clusters: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether to include the cluster's pending mapping state in the response."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> HasPendingMappingsResponse:
        """
        Get migration and user mapping status.

        To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.

        :param get_clusters: Indicates whether to include the cluster's pending mapping state in the response.
        :type get_clusters: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'HasPendingMappingsResponse' result object.
        """

        response = await self.has_pending_mappings_with_http_info(
            get_clusters, request_options
        )

        return response.deserialize(HasPendingMappingsResponse)

    async def list_api_keys_with_http_info(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> ApiResponse[str]:
        """
        List API keys.

        List all API keys associated with your Algolia application, including their permissions and restrictions.

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/keys"

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def list_api_keys(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> ListApiKeysResponse:
        """
        List API keys.

        List all API keys associated with your Algolia application, including their permissions and restrictions.

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ListApiKeysResponse' result object.
        """

        response = await self.list_api_keys_with_http_info(request_options)

        return response.deserialize(ListApiKeysResponse)

    async def list_clusters_with_http_info(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> ApiResponse[str]:
        """
        List clusters.

        List the available clusters in a multi-cluster setup.

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/clusters"

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def list_clusters(
        self, request_options: Optional[Union[dict, RequestOptions]] = None
    ) -> ListClustersResponse:
        """
        List clusters.

        List the available clusters in a multi-cluster setup.

        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ListClustersResponse' result object.
        """

        response = await self.list_clusters_with_http_info(request_options)

        return response.deserialize(ListClustersResponse)

    async def list_indices_with_http_info(
        self,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(
                description="Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated. "
            ),
        ] = None,
        hits_per_page: Annotated[
            Optional[StrictInt], Field(description="Maximum number of hits per page.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        List indices.

        List indices in an Algolia application.

        :param page: Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
        :type page: int
        :param hits_per_page: Maximum number of hits per page.
        :type hits_per_page: int
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes"

        if page is not None:
            _query_params.append(("page", page))
        if hits_per_page is not None:
            _query_params.append(("hitsPerPage", hits_per_page))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def list_indices(
        self,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(
                description="Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated. "
            ),
        ] = None,
        hits_per_page: Annotated[
            Optional[StrictInt], Field(description="Maximum number of hits per page.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ListIndicesResponse:
        """
        List indices.

        List indices in an Algolia application.

        :param page: Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
        :type page: int
        :param hits_per_page: Maximum number of hits per page.
        :type hits_per_page: int
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ListIndicesResponse' result object.
        """

        response = await self.list_indices_with_http_info(
            page, hits_per_page, request_options
        )

        return response.deserialize(ListIndicesResponse)

    async def list_user_ids_with_http_info(
        self,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(
                description="Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated. "
            ),
        ] = None,
        hits_per_page: Annotated[
            Optional[StrictInt], Field(description="Maximum number of hits per page.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        List userIDs.

        List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

        :param page: Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
        :type page: int
        :param hits_per_page: Maximum number of hits per page.
        :type hits_per_page: int
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/clusters/mapping"

        if page is not None:
            _query_params.append(("page", page))
        if hits_per_page is not None:
            _query_params.append(("hitsPerPage", hits_per_page))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def list_user_ids(
        self,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(
                description="Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated. "
            ),
        ] = None,
        hits_per_page: Annotated[
            Optional[StrictInt], Field(description="Maximum number of hits per page.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ListUserIdsResponse:
        """
        List userIDs.

        List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

        :param page: Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
        :type page: int
        :param hits_per_page: Maximum number of hits per page.
        :type hits_per_page: int
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ListUserIdsResponse' result object.
        """

        response = await self.list_user_ids_with_http_info(
            page, hits_per_page, request_options
        )

        return response.deserialize(ListUserIdsResponse)

    async def multiple_batch_with_http_info(
        self,
        batch_params: BatchParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Batch write operations on multiple indices.

        To reduce the time spent on network round trips, you can perform several write actions in a single request. It's a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name.

        :param batch_params: (required)
        :type batch_params: BatchParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if batch_params is None:
            raise ValueError("'batch_params' is required when calling 'multiple_batch'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/*/batch"

        if batch_params is not None:
            _body = batch_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def multiple_batch(
        self,
        batch_params: BatchParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> MultipleBatchResponse:
        """
        Batch write operations on multiple indices.

        To reduce the time spent on network round trips, you can perform several write actions in a single request. It's a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name.

        :param batch_params: (required)
        :type batch_params: BatchParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'MultipleBatchResponse' result object.
        """

        response = await self.multiple_batch_with_http_info(
            batch_params, request_options
        )

        return response.deserialize(MultipleBatchResponse)

    async def operation_index_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        operation_index_params: OperationIndexParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Copy, move, or rename an index.

        This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms, and rules to a `destination` index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn't exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  > **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param operation_index_params: (required)
        :type operation_index_params: OperationIndexParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'operation_index'")

        if operation_index_params is None:
            raise ValueError(
                "'operation_index_params' is required when calling 'operation_index'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/operation".replace(
            "{indexName}", quote(str(index_name))
        )

        if operation_index_params is not None:
            _body = operation_index_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def operation_index(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        operation_index_params: OperationIndexParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Copy, move, or rename an index.

        This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms, and rules to a `destination` index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn't exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  > **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param operation_index_params: (required)
        :type operation_index_params: OperationIndexParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.operation_index_with_http_info(
            index_name, operation_index_params, request_options
        )

        return response.deserialize(UpdatedAtResponse)

    async def partial_update_object_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique record (object) identifier.")
        ],
        attributes_to_update: Annotated[
            Dict[str, AttributeToUpdate],
            Field(description="Object with attributes to update."),
        ],
        create_if_not_exists: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether to create a new record if it doesn't exist yet. "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Update record attributes.

        Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique record (object) identifier. (required)
        :type object_id: str
        :param attributes_to_update: Object with attributes to update. (required)
        :type attributes_to_update: Dict[str, AttributeToUpdate]
        :param create_if_not_exists: Indicates whether to create a new record if it doesn't exist yet.
        :type create_if_not_exists: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError(
                "'index_name' is required when calling 'partial_update_object'"
            )

        if object_id is None:
            raise ValueError(
                "'object_id' is required when calling 'partial_update_object'"
            )

        if attributes_to_update is None:
            raise ValueError(
                "'attributes_to_update' is required when calling 'partial_update_object'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/{objectID}/partial".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        if create_if_not_exists is not None:
            _query_params.append(("createIfNotExists", create_if_not_exists))

        if attributes_to_update is not None:
            _body = attributes_to_update

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def partial_update_object(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique record (object) identifier.")
        ],
        attributes_to_update: Annotated[
            Dict[str, AttributeToUpdate],
            Field(description="Object with attributes to update."),
        ],
        create_if_not_exists: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether to create a new record if it doesn't exist yet. "
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtWithObjectIdResponse:
        """
        Update record attributes.

        Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique record (object) identifier. (required)
        :type object_id: str
        :param attributes_to_update: Object with attributes to update. (required)
        :type attributes_to_update: Dict[str, AttributeToUpdate]
        :param create_if_not_exists: Indicates whether to create a new record if it doesn't exist yet.
        :type create_if_not_exists: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtWithObjectIdResponse' result object.
        """

        response = await self.partial_update_object_with_http_info(
            index_name,
            object_id,
            attributes_to_update,
            create_if_not_exists,
            request_options,
        )

        return response.deserialize(UpdatedAtWithObjectIdResponse)

    async def remove_user_id_with_http_info(
        self,
        user_id: Annotated[str, Field(strict=True, description="userID to assign.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Remove userID.

        Remove a userID and its associated data from the multi-clusters.

        :param user_id: userID to assign. (required)
        :type user_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if user_id is None:
            raise ValueError("'user_id' is required when calling 'remove_user_id'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/clusters/mapping/{userID}".replace("{userID}", quote(str(user_id)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def remove_user_id(
        self,
        user_id: Annotated[str, Field(strict=True, description="userID to assign.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> RemoveUserIdResponse:
        """
        Remove userID.

        Remove a userID and its associated data from the multi-clusters.

        :param user_id: userID to assign. (required)
        :type user_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'RemoveUserIdResponse' result object.
        """

        response = await self.remove_user_id_with_http_info(user_id, request_options)

        return response.deserialize(RemoveUserIdResponse)

    async def replace_sources_with_http_info(
        self,
        source: Annotated[List[Source], Field(description="Allowed sources.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Replace all sources.

        Replace all allowed sources.

        :param source: Allowed sources. (required)
        :type source: List[Source]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if source is None:
            raise ValueError("'source' is required when calling 'replace_sources'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/security/sources"

        if source is not None:
            _body = source

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def replace_sources(
        self,
        source: Annotated[List[Source], Field(description="Allowed sources.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ReplaceSourceResponse:
        """
        Replace all sources.

        Replace all allowed sources.

        :param source: Allowed sources. (required)
        :type source: List[Source]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ReplaceSourceResponse' result object.
        """

        response = await self.replace_sources_with_http_info(source, request_options)

        return response.deserialize(ReplaceSourceResponse)

    async def restore_api_key_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="API key.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Restore API key.

        Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key.

        :param key: API key. (required)
        :type key: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if key is None:
            raise ValueError("'key' is required when calling 'restore_api_key'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/keys/{key}/restore".replace("{key}", quote(str(key)))

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def restore_api_key(
        self,
        key: Annotated[StrictStr, Field(description="API key.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> AddApiKeyResponse:
        """
        Restore API key.

        Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key.

        :param key: API key. (required)
        :type key: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'AddApiKeyResponse' result object.
        """

        response = await self.restore_api_key_with_http_info(key, request_options)

        return response.deserialize(AddApiKeyResponse)

    async def save_object_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        body: Annotated[Dict[str, Any], Field(description="The Algolia record.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Add or update a record.

        Add a record (object) to an index or replace it. If the record doesn't contain an `objectID`, Algolia automatically adds it. If you use an existing `objectID`, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param body: The Algolia record. (required)
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'save_object'")

        if body is None:
            raise ValueError("'body' is required when calling 'save_object'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}".replace("{indexName}", quote(str(index_name)))

        if body is not None:
            _body = body

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def save_object(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        body: Annotated[Dict[str, Any], Field(description="The Algolia record.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SaveObjectResponse:
        """
        Add or update a record.

        Add a record (object) to an index or replace it. If the record doesn't contain an `objectID`, Algolia automatically adds it. If you use an existing `objectID`, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param body: The Algolia record. (required)
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SaveObjectResponse' result object.
        """

        response = await self.save_object_with_http_info(
            index_name, body, request_options
        )

        return response.deserialize(SaveObjectResponse)

    async def save_rule_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a rule object.")
        ],
        rule: Rule,
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Create or update a rule.

        To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a rule object. (required)
        :type object_id: str
        :param rule: (required)
        :type rule: Rule
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'save_rule'")

        if object_id is None:
            raise ValueError("'object_id' is required when calling 'save_rule'")

        if rule is None:
            raise ValueError("'rule' is required when calling 'save_rule'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/rules/{objectID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        if forward_to_replicas is not None:
            _query_params.append(("forwardToReplicas", forward_to_replicas))

        if rule is not None:
            _body = rule

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def save_rule(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a rule object.")
        ],
        rule: Rule,
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedRuleResponse:
        """
        Create or update a rule.

        To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a rule object. (required)
        :type object_id: str
        :param rule: (required)
        :type rule: Rule
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedRuleResponse' result object.
        """

        response = await self.save_rule_with_http_info(
            index_name, object_id, rule, forward_to_replicas, request_options
        )

        return response.deserialize(UpdatedRuleResponse)

    async def save_rules_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        rules: List[Rule],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        clear_existing_rules: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether existing rules should be deleted before adding this batch."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Save a batch of rules.

        Create or update multiple rules.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param rules: (required)
        :type rules: List[Rule]
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param clear_existing_rules: Indicates whether existing rules should be deleted before adding this batch.
        :type clear_existing_rules: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'save_rules'")

        if rules is None:
            raise ValueError("'rules' is required when calling 'save_rules'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/rules/batch".replace(
            "{indexName}", quote(str(index_name))
        )

        if forward_to_replicas is not None:
            _query_params.append(("forwardToReplicas", forward_to_replicas))
        if clear_existing_rules is not None:
            _query_params.append(("clearExistingRules", clear_existing_rules))

        if rules is not None:
            _body = rules

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def save_rules(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        rules: List[Rule],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        clear_existing_rules: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether existing rules should be deleted before adding this batch."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Save a batch of rules.

        Create or update multiple rules.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param rules: (required)
        :type rules: List[Rule]
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param clear_existing_rules: Indicates whether existing rules should be deleted before adding this batch.
        :type clear_existing_rules: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.save_rules_with_http_info(
            index_name,
            rules,
            forward_to_replicas,
            clear_existing_rules,
            request_options,
        )

        return response.deserialize(UpdatedAtResponse)

    async def save_synonym_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a synonym object.")
        ],
        synonym_hit: SynonymHit,
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Save a synonym.

        Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym `objectID` doesn't exist, Algolia adds a new one. If you use an existing synonym `objectID`, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a synonym object. (required)
        :type object_id: str
        :param synonym_hit: (required)
        :type synonym_hit: SynonymHit
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'save_synonym'")

        if object_id is None:
            raise ValueError("'object_id' is required when calling 'save_synonym'")

        if synonym_hit is None:
            raise ValueError("'synonym_hit' is required when calling 'save_synonym'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/synonyms/{objectID}".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{objectID}", quote(str(object_id)))

        if forward_to_replicas is not None:
            _query_params.append(("forwardToReplicas", forward_to_replicas))

        if synonym_hit is not None:
            _body = synonym_hit

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def save_synonym(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        object_id: Annotated[
            StrictStr, Field(description="Unique identifier of a synonym object.")
        ],
        synonym_hit: SynonymHit,
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SaveSynonymResponse:
        """
        Save a synonym.

        Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym `objectID` doesn't exist, Algolia adds a new one. If you use an existing synonym `objectID`, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param object_id: Unique identifier of a synonym object. (required)
        :type object_id: str
        :param synonym_hit: (required)
        :type synonym_hit: SynonymHit
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SaveSynonymResponse' result object.
        """

        response = await self.save_synonym_with_http_info(
            index_name, object_id, synonym_hit, forward_to_replicas, request_options
        )

        return response.deserialize(SaveSynonymResponse)

    async def save_synonyms_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        synonym_hit: List[SynonymHit],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        replace_existing_synonyms: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether to replace all synonyms in the index with the ones sent with this request."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Save a batch of synonyms.

        Create or update multiple synonyms.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param synonym_hit: (required)
        :type synonym_hit: List[SynonymHit]
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param replace_existing_synonyms: Indicates whether to replace all synonyms in the index with the ones sent with this request.
        :type replace_existing_synonyms: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'save_synonyms'")

        if synonym_hit is None:
            raise ValueError("'synonym_hit' is required when calling 'save_synonyms'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/synonyms/batch".replace(
            "{indexName}", quote(str(index_name))
        )

        if forward_to_replicas is not None:
            _query_params.append(("forwardToReplicas", forward_to_replicas))
        if replace_existing_synonyms is not None:
            _query_params.append(("replaceExistingSynonyms", replace_existing_synonyms))

        if synonym_hit is not None:
            _body = synonym_hit

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def save_synonyms(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        synonym_hit: List[SynonymHit],
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        replace_existing_synonyms: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether to replace all synonyms in the index with the ones sent with this request."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Save a batch of synonyms.

        Create or update multiple synonyms.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param synonym_hit: (required)
        :type synonym_hit: List[SynonymHit]
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param replace_existing_synonyms: Indicates whether to replace all synonyms in the index with the ones sent with this request.
        :type replace_existing_synonyms: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.save_synonyms_with_http_info(
            index_name,
            synonym_hit,
            forward_to_replicas,
            replace_existing_synonyms,
            request_options,
        )

        return response.deserialize(UpdatedAtResponse)

    async def search_with_http_info(
        self,
        search_method_params: Annotated[
            SearchMethodParams,
            Field(
                description="Query requests and strategies. Results will be received in the same order as the queries."
            ),
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search multiple indices.

        Send multiple search queries to one or more indices.

        :param search_method_params: Query requests and strategies. Results will be received in the same order as the queries. (required)
        :type search_method_params: SearchMethodParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if search_method_params is None:
            raise ValueError("'search_method_params' is required when calling 'search'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/*/queries"

        if search_method_params is not None:
            _body = search_method_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search(
        self,
        search_method_params: Annotated[
            SearchMethodParams,
            Field(
                description="Query requests and strategies. Results will be received in the same order as the queries."
            ),
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SearchResponses:
        """
        Search multiple indices.

        Send multiple search queries to one or more indices.

        :param search_method_params: Query requests and strategies. Results will be received in the same order as the queries. (required)
        :type search_method_params: SearchMethodParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SearchResponses' result object.
        """

        response = await self.search_with_http_info(
            search_method_params, request_options
        )

        return response.deserialize(SearchResponses)

    async def search_dictionary_entries_with_http_info(
        self,
        dictionary_name: Annotated[
            DictionaryType, Field(description="Dictionary to search in.")
        ],
        search_dictionary_entries_params: SearchDictionaryEntriesParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search dictionary entries.

        Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.

        :param dictionary_name: Dictionary to search in. (required)
        :type dictionary_name: DictionaryType
        :param search_dictionary_entries_params: (required)
        :type search_dictionary_entries_params: SearchDictionaryEntriesParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if dictionary_name is None:
            raise ValueError(
                "'dictionary_name' is required when calling 'search_dictionary_entries'"
            )

        if search_dictionary_entries_params is None:
            raise ValueError(
                "'search_dictionary_entries_params' is required when calling 'search_dictionary_entries'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/dictionaries/{dictionaryName}/search".replace(
            "{dictionaryName}", quote(str(dictionary_name))
        )

        if search_dictionary_entries_params is not None:
            _body = search_dictionary_entries_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_dictionary_entries(
        self,
        dictionary_name: Annotated[
            DictionaryType, Field(description="Dictionary to search in.")
        ],
        search_dictionary_entries_params: SearchDictionaryEntriesParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Search dictionary entries.

        Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.

        :param dictionary_name: Dictionary to search in. (required)
        :type dictionary_name: DictionaryType
        :param search_dictionary_entries_params: (required)
        :type search_dictionary_entries_params: SearchDictionaryEntriesParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.search_dictionary_entries_with_http_info(
            dictionary_name, search_dictionary_entries_params, request_options
        )

        return response.deserialize(UpdatedAtResponse)

    async def search_for_facet_values_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        facet_name: Annotated[StrictStr, Field(description="Facet name.")],
        search_for_facet_values_request: Optional[SearchForFacetValuesRequest] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search for facet values.

        [Search for a facet's values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. > **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param facet_name: Facet name. (required)
        :type facet_name: str
        :param search_for_facet_values_request:
        :type search_for_facet_values_request: SearchForFacetValuesRequest
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError(
                "'index_name' is required when calling 'search_for_facet_values'"
            )

        if facet_name is None:
            raise ValueError(
                "'facet_name' is required when calling 'search_for_facet_values'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/facets/{facetName}/query".replace(
            "{indexName}", quote(str(index_name))
        ).replace("{facetName}", quote(str(facet_name)))

        if search_for_facet_values_request is not None:
            _body = search_for_facet_values_request

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_for_facet_values(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        facet_name: Annotated[StrictStr, Field(description="Facet name.")],
        search_for_facet_values_request: Optional[SearchForFacetValuesRequest] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SearchForFacetValuesResponse:
        """
        Search for facet values.

        [Search for a facet's values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. > **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param facet_name: Facet name. (required)
        :type facet_name: str
        :param search_for_facet_values_request:
        :type search_for_facet_values_request: SearchForFacetValuesRequest
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SearchForFacetValuesResponse' result object.
        """

        response = await self.search_for_facet_values_with_http_info(
            index_name, facet_name, search_for_facet_values_request, request_options
        )

        return response.deserialize(SearchForFacetValuesResponse)

    async def search_rules_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        search_rules_params: Optional[SearchRulesParams] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search for rules.

        Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param search_rules_params:
        :type search_rules_params: SearchRulesParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'search_rules'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/rules/search".replace(
            "{indexName}", quote(str(index_name))
        )

        if search_rules_params is not None:
            _body = search_rules_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_rules(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        search_rules_params: Optional[SearchRulesParams] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SearchRulesResponse:
        """
        Search for rules.

        Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param search_rules_params:
        :type search_rules_params: SearchRulesParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SearchRulesResponse' result object.
        """

        response = await self.search_rules_with_http_info(
            index_name, search_rules_params, request_options
        )

        return response.deserialize(SearchRulesResponse)

    async def search_single_index_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        search_params: Optional[SearchParams] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search an index.

        Return records that match the query.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param search_params:
        :type search_params: SearchParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError(
                "'index_name' is required when calling 'search_single_index'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/query".replace(
            "{indexName}", quote(str(index_name))
        )

        if search_params is not None:
            _body = search_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_single_index(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        search_params: Optional[SearchParams] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SearchResponse:
        """
        Search an index.

        Return records that match the query.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param search_params:
        :type search_params: SearchParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SearchResponse' result object.
        """

        response = await self.search_single_index_with_http_info(
            index_name, search_params, request_options
        )

        return response.deserialize(SearchResponse)

    async def search_synonyms_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        type: Annotated[
            Optional[SynonymType],
            Field(
                description="Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms)."
            ),
        ] = None,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(
                description="Returns the requested page number (the first page is 0). Page size is set by `hitsPerPage`. When null, there's no pagination. "
            ),
        ] = None,
        hits_per_page: Annotated[
            Optional[StrictInt], Field(description="Maximum number of hits per page.")
        ] = None,
        search_synonyms_params: Annotated[
            Optional[SearchSynonymsParams],
            Field(description="Body of the `searchSynonyms` operation."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search for synonyms.

        Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param type: Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms).
        :type type: SynonymType
        :param page: Returns the requested page number (the first page is 0). Page size is set by `hitsPerPage`. When null, there's no pagination.
        :type page: int
        :param hits_per_page: Maximum number of hits per page.
        :type hits_per_page: int
        :param search_synonyms_params: Body of the `searchSynonyms` operation.
        :type search_synonyms_params: SearchSynonymsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'search_synonyms'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/synonyms/search".replace(
            "{indexName}", quote(str(index_name))
        )

        if type is not None:
            _query_params.append(("type", type.value))
        if page is not None:
            _query_params.append(("page", page))
        if hits_per_page is not None:
            _query_params.append(("hitsPerPage", hits_per_page))

        if search_synonyms_params is not None:
            _body = search_synonyms_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_synonyms(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        type: Annotated[
            Optional[SynonymType],
            Field(
                description="Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms)."
            ),
        ] = None,
        page: Annotated[
            Optional[Annotated[int, Field(strict=True, ge=0)]],
            Field(
                description="Returns the requested page number (the first page is 0). Page size is set by `hitsPerPage`. When null, there's no pagination. "
            ),
        ] = None,
        hits_per_page: Annotated[
            Optional[StrictInt], Field(description="Maximum number of hits per page.")
        ] = None,
        search_synonyms_params: Annotated[
            Optional[SearchSynonymsParams],
            Field(description="Body of the `searchSynonyms` operation."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SearchSynonymsResponse:
        """
        Search for synonyms.

        Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param type: Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms).
        :type type: SynonymType
        :param page: Returns the requested page number (the first page is 0). Page size is set by `hitsPerPage`. When null, there's no pagination.
        :type page: int
        :param hits_per_page: Maximum number of hits per page.
        :type hits_per_page: int
        :param search_synonyms_params: Body of the `searchSynonyms` operation.
        :type search_synonyms_params: SearchSynonymsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SearchSynonymsResponse' result object.
        """

        response = await self.search_synonyms_with_http_info(
            index_name,
            type,
            page,
            hits_per_page,
            search_synonyms_params,
            request_options,
        )

        return response.deserialize(SearchSynonymsResponse)

    async def search_user_ids_with_http_info(
        self,
        search_user_ids_params: SearchUserIdsParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search for a user ID.

        Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time. To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).

        :param search_user_ids_params: (required)
        :type search_user_ids_params: SearchUserIdsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if search_user_ids_params is None:
            raise ValueError(
                "'search_user_ids_params' is required when calling 'search_user_ids'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/clusters/mapping/search"

        if search_user_ids_params is not None:
            _body = search_user_ids_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_user_ids(
        self,
        search_user_ids_params: SearchUserIdsParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SearchUserIdsResponse:
        """
        Search for a user ID.

        Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time. To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).

        :param search_user_ids_params: (required)
        :type search_user_ids_params: SearchUserIdsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SearchUserIdsResponse' result object.
        """

        response = await self.search_user_ids_with_http_info(
            search_user_ids_params, request_options
        )

        return response.deserialize(SearchUserIdsResponse)

    async def set_dictionary_settings_with_http_info(
        self,
        dictionary_settings_params: DictionarySettingsParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Set stop word settings.

        Set stop word settings for a specific language.

        :param dictionary_settings_params: (required)
        :type dictionary_settings_params: DictionarySettingsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if dictionary_settings_params is None:
            raise ValueError(
                "'dictionary_settings_params' is required when calling 'set_dictionary_settings'"
            )

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/dictionaries/*/settings"

        if dictionary_settings_params is not None:
            _body = dictionary_settings_params

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def set_dictionary_settings(
        self,
        dictionary_settings_params: DictionarySettingsParams,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Set stop word settings.

        Set stop word settings for a specific language.

        :param dictionary_settings_params: (required)
        :type dictionary_settings_params: DictionarySettingsParams
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.set_dictionary_settings_with_http_info(
            dictionary_settings_params, request_options
        )

        return response.deserialize(UpdatedAtResponse)

    async def set_settings_with_http_info(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        index_settings: IndexSettings,
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Update index settings.

        Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param index_settings: (required)
        :type index_settings: IndexSettings
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if index_name is None:
            raise ValueError("'index_name' is required when calling 'set_settings'")

        if index_settings is None:
            raise ValueError("'index_settings' is required when calling 'set_settings'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/indexes/{indexName}/settings".replace(
            "{indexName}", quote(str(index_name))
        )

        if forward_to_replicas is not None:
            _query_params.append(("forwardToReplicas", forward_to_replicas))

        if index_settings is not None:
            _body = index_settings

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def set_settings(
        self,
        index_name: Annotated[
            StrictStr, Field(description="Index on which to perform the request.")
        ],
        index_settings: IndexSettings,
        forward_to_replicas: Annotated[
            Optional[StrictBool],
            Field(
                description="Indicates whether changed index settings are forwarded to the replica indices."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdatedAtResponse:
        """
        Update index settings.

        Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.

        :param index_name: Index on which to perform the request. (required)
        :type index_name: str
        :param index_settings: (required)
        :type index_settings: IndexSettings
        :param forward_to_replicas: Indicates whether changed index settings are forwarded to the replica indices.
        :type forward_to_replicas: bool
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdatedAtResponse' result object.
        """

        response = await self.set_settings_with_http_info(
            index_name, index_settings, forward_to_replicas, request_options
        )

        return response.deserialize(UpdatedAtResponse)

    async def update_api_key_with_http_info(
        self,
        key: Annotated[StrictStr, Field(description="API key.")],
        api_key: ApiKey,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Update an API key.

        Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key.

        :param key: API key. (required)
        :type key: str
        :param api_key: (required)
        :type api_key: ApiKey
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        if key is None:
            raise ValueError("'key' is required when calling 'update_api_key'")

        if api_key is None:
            raise ValueError("'api_key' is required when calling 'update_api_key'")

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        _path = "/1/keys/{key}".replace("{key}", quote(str(key)))

        if api_key is not None:
            _body = api_key

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_path,
            data=_param[0],
            request_options=_param[1],
            use_read_transporter=False,
        )

        response.data = response.raw_data

        return response

    async def update_api_key(
        self,
        key: Annotated[StrictStr, Field(description="API key.")],
        api_key: ApiKey,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> UpdateApiKeyResponse:
        """
        Update an API key.

        Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key.

        :param key: API key. (required)
        :type key: str
        :param api_key: (required)
        :type api_key: ApiKey
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'UpdateApiKeyResponse' result object.
        """

        response = await self.update_api_key_with_http_info(
            key, api_key, request_options
        )

        return response.deserialize(UpdateApiKeyResponse)
