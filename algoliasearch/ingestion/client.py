# coding: utf-8

"""
Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
"""
from __future__ import annotations

from re import match
from typing import Annotated, Any, Dict, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictInt, StrictStr

from algoliasearch.http import ApiResponse, RequestOptions, Transporter, Verb
from algoliasearch.ingestion.config import Config
from algoliasearch.ingestion.models import (
    ActionType,
    Authentication,
    AuthenticationCreate,
    AuthenticationCreateResponse,
    AuthenticationSearch,
    AuthenticationSortKeys,
    AuthenticationType,
    AuthenticationUpdate,
    AuthenticationUpdateResponse,
    DeleteResponse,
    Destination,
    DestinationCreate,
    DestinationCreateResponse,
    DestinationSearch,
    DestinationSortKeys,
    DestinationType,
    DestinationUpdate,
    DestinationUpdateResponse,
    DockerSourceDiscover,
    DockerSourceStreams,
    Event,
    EventSortKeys,
    EventStatus,
    EventType,
    ListAuthenticationsResponse,
    ListDestinationsResponse,
    ListEventsResponse,
    ListSourcesResponse,
    ListTasksResponse,
    OrderKeys,
    PlatformWithNone,
    Run,
    RunListResponse,
    RunResponse,
    RunSortKeys,
    RunStatus,
    Source,
    SourceCreate,
    SourceCreateResponse,
    SourceSearch,
    SourceSortKeys,
    SourceType,
    SourceUpdate,
    SourceUpdateResponse,
    Task,
    TaskCreate,
    TaskCreateResponse,
    TaskSearch,
    TaskSortKeys,
    TaskUpdate,
    TaskUpdateResponse,
    TriggerType,
)

try:
    from typing import Self
except ImportError:
    from typing_extensions import Self


class IngestionClient:
    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        "int": int,
        "float": float,
        "str": str,
        "bool": bool,
        "object": object,
    }

    def app_id(self) -> str:
        return self._config.app_id

    def __init__(self, transporter: Transporter, config: Config) -> None:
        self._transporter = transporter
        self._config = config

    def create_with_config(config: Config) -> Self:
        transporter = Transporter(config)

        return IngestionClient(transporter, config)

    def create(app_id: Optional[str] = None, api_key: Optional[str] = None) -> Self:
        return IngestionClient.create_with_config(Config(app_id, api_key))

    async def close(self) -> None:
        return await self._transporter.close()

    def __deserialize(self, data: Optional[dict], klass: any = None) -> dict:
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith("List["):
                sub_kls = match(r"List\[(.*)]", klass).group(1)
                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]

            if klass.startswith("Dict["):
                sub_kls = match(r"Dict\[([^,]*), (.*)]", klass).group(2)
                return {k: self.__deserialize(v, sub_kls) for k, v in data.items()}

            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]

        if klass in self.PRIMITIVE_TYPES:
            try:
                return klass(data)
            except UnicodeEncodeError:
                return str(data)
            except TypeError:
                return data
        elif klass == object:
            return data
        else:
            return klass.from_json(data)

    async def call_del_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if path is not None:
            _path_params["path"] = path

        if parameters is not None:
            _query_params.append(("parameters", parameters))

        _param = self._transporter.param_serialize(
            path="/1{path}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def call_del(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """

        response = await self.call_del_with_http_info(path, parameters, request_options)

        return self.__deserialize(response.raw_data, object)

    async def create_authentication_with_http_info(
        self,
        authentication_create: AuthenticationCreate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Create a authentication.

        Create a authentication.

        :param authentication_create:  (required)
        :type authentication_create: AuthenticationCreate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if authentication_create is not None:
            _body_params = authentication_create

        _param = self._transporter.param_serialize(
            path="/1/authentications",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def create_authentication(
        self,
        authentication_create: AuthenticationCreate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> AuthenticationCreateResponse:
        """
        Create a authentication.

        Create a authentication.

        :param authentication_create:  (required)
        :type authentication_create: AuthenticationCreate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'AuthenticationCreateResponse' result object.
        """

        response = await self.create_authentication_with_http_info(
            authentication_create, request_options
        )

        return self.__deserialize(response.raw_data, AuthenticationCreateResponse)

    async def create_destination_with_http_info(
        self,
        destination_create: DestinationCreate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Create a destination.

        Create a destination.

        :param destination_create:  (required)
        :type destination_create: DestinationCreate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if destination_create is not None:
            _body_params = destination_create

        _param = self._transporter.param_serialize(
            path="/1/destinations",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def create_destination(
        self,
        destination_create: DestinationCreate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DestinationCreateResponse:
        """
        Create a destination.

        Create a destination.

        :param destination_create:  (required)
        :type destination_create: DestinationCreate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DestinationCreateResponse' result object.
        """

        response = await self.create_destination_with_http_info(
            destination_create, request_options
        )

        return self.__deserialize(response.raw_data, DestinationCreateResponse)

    async def create_source_with_http_info(
        self,
        source_create: SourceCreate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Create a source.

        Create a source.

        :param source_create:  (required)
        :type source_create: SourceCreate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if source_create is not None:
            _body_params = source_create

        _param = self._transporter.param_serialize(
            path="/1/sources",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def create_source(
        self,
        source_create: SourceCreate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SourceCreateResponse:
        """
        Create a source.

        Create a source.

        :param source_create:  (required)
        :type source_create: SourceCreate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SourceCreateResponse' result object.
        """

        response = await self.create_source_with_http_info(
            source_create, request_options
        )

        return self.__deserialize(response.raw_data, SourceCreateResponse)

    async def create_task_with_http_info(
        self,
        task_create: TaskCreate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Create a task.

        Create a task.

        :param task_create:  (required)
        :type task_create: TaskCreate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if task_create is not None:
            _body_params = task_create

        _param = self._transporter.param_serialize(
            path="/1/tasks",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def create_task(
        self,
        task_create: TaskCreate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> TaskCreateResponse:
        """
        Create a task.

        Create a task.

        :param task_create:  (required)
        :type task_create: TaskCreate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'TaskCreateResponse' result object.
        """

        response = await self.create_task_with_http_info(task_create, request_options)

        return self.__deserialize(response.raw_data, TaskCreateResponse)

    async def delete_authentication_with_http_info(
        self,
        authentication_id: Annotated[
            StrictStr, Field(description="The authentication UUID.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete a authentication.

        Soft delete the authentication of the given authenticationID.

        :param authentication_id: The authentication UUID. (required)
        :type authentication_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if authentication_id is not None:
            _path_params["authenticationID"] = authentication_id

        _param = self._transporter.param_serialize(
            path="/1/authentications/{authenticationID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def delete_authentication(
        self,
        authentication_id: Annotated[
            StrictStr, Field(description="The authentication UUID.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeleteResponse:
        """
        Delete a authentication.

        Soft delete the authentication of the given authenticationID.

        :param authentication_id: The authentication UUID. (required)
        :type authentication_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeleteResponse' result object.
        """

        response = await self.delete_authentication_with_http_info(
            authentication_id, request_options
        )

        return self.__deserialize(response.raw_data, DeleteResponse)

    async def delete_destination_with_http_info(
        self,
        destination_id: Annotated[
            StrictStr, Field(description="The destination UUID.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete a destination.

        Soft delete the destination of the given destinationID.

        :param destination_id: The destination UUID. (required)
        :type destination_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if destination_id is not None:
            _path_params["destinationID"] = destination_id

        _param = self._transporter.param_serialize(
            path="/1/destinations/{destinationID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def delete_destination(
        self,
        destination_id: Annotated[
            StrictStr, Field(description="The destination UUID.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeleteResponse:
        """
        Delete a destination.

        Soft delete the destination of the given destinationID.

        :param destination_id: The destination UUID. (required)
        :type destination_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeleteResponse' result object.
        """

        response = await self.delete_destination_with_http_info(
            destination_id, request_options
        )

        return self.__deserialize(response.raw_data, DeleteResponse)

    async def delete_source_with_http_info(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete a source.

        Soft delete the source of the given sourceID.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if source_id is not None:
            _path_params["sourceID"] = source_id

        _param = self._transporter.param_serialize(
            path="/1/sources/{sourceID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def delete_source(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeleteResponse:
        """
        Delete a source.

        Soft delete the source of the given sourceID.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeleteResponse' result object.
        """

        response = await self.delete_source_with_http_info(source_id, request_options)

        return self.__deserialize(response.raw_data, DeleteResponse)

    async def delete_task_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Delete a task.

        Soft delete the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if task_id is not None:
            _path_params["taskID"] = task_id

        _param = self._transporter.param_serialize(
            path="/1/tasks/{taskID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.DELETE,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def delete_task(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DeleteResponse:
        """
        Delete a task.

        Soft delete the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DeleteResponse' result object.
        """

        response = await self.delete_task_with_http_info(task_id, request_options)

        return self.__deserialize(response.raw_data, DeleteResponse)

    async def disable_task_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Disable a task.

        Disable the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if task_id is not None:
            _path_params["taskID"] = task_id

        _param = self._transporter.param_serialize(
            path="/1/tasks/{taskID}/disable",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def disable_task(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> TaskUpdateResponse:
        """
        Disable a task.

        Disable the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'TaskUpdateResponse' result object.
        """

        response = await self.disable_task_with_http_info(task_id, request_options)

        return self.__deserialize(response.raw_data, TaskUpdateResponse)

    async def enable_task_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Enable a task.

        Enable the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if task_id is not None:
            _path_params["taskID"] = task_id

        _param = self._transporter.param_serialize(
            path="/1/tasks/{taskID}/enable",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def enable_task(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> TaskUpdateResponse:
        """
        Enable a task.

        Enable the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'TaskUpdateResponse' result object.
        """

        response = await self.enable_task_with_http_info(task_id, request_options)

        return self.__deserialize(response.raw_data, TaskUpdateResponse)

    async def get_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if path is not None:
            _path_params["path"] = path

        if parameters is not None:
            _query_params.append(("parameters", parameters))

        _param = self._transporter.param_serialize(
            path="/1{path}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """

        response = await self.get_with_http_info(path, parameters, request_options)

        return self.__deserialize(response.raw_data, object)

    async def get_authentication_with_http_info(
        self,
        authentication_id: Annotated[
            StrictStr, Field(description="The authentication UUID.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a authentication.

        Get the authentication of the given authenticationID.

        :param authentication_id: The authentication UUID. (required)
        :type authentication_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if authentication_id is not None:
            _path_params["authenticationID"] = authentication_id

        _param = self._transporter.param_serialize(
            path="/1/authentications/{authenticationID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_authentication(
        self,
        authentication_id: Annotated[
            StrictStr, Field(description="The authentication UUID.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> Authentication:
        """
        Get a authentication.

        Get the authentication of the given authenticationID.

        :param authentication_id: The authentication UUID. (required)
        :type authentication_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'Authentication' result object.
        """

        response = await self.get_authentication_with_http_info(
            authentication_id, request_options
        )

        return self.__deserialize(response.raw_data, Authentication)

    async def get_authentications_with_http_info(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        type: Annotated[
            Optional[List[AuthenticationType]],
            Field(description="The type of the authentications to retrieve."),
        ] = None,
        platform: Annotated[
            Optional[List[PlatformWithNone]],
            Field(description="The platform of the authentications to retrieve."),
        ] = None,
        sort: Annotated[
            Optional[AuthenticationSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a list of authentications.

        Get a list of authentications for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param type: The type of the authentications to retrieve.
        :type type: List[AuthenticationType]
        :param platform: The platform of the authentications to retrieve.
        :type platform: List[PlatformWithNone]
        :param sort: The key by which the list should be sorted.
        :type sort: AuthenticationSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if items_per_page is not None:
            _query_params.append(("itemsPerPage", items_per_page))

        if page is not None:
            _query_params.append(("page", page))

        if type is not None:
            _query_params.append(("type", type))

        if platform is not None:
            _query_params.append(("platform", platform))

        if sort is not None:
            _query_params.append(("sort", sort.value))

        if order is not None:
            _query_params.append(("order", order.value))

        _param = self._transporter.param_serialize(
            path="/1/authentications",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_authentications(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        type: Annotated[
            Optional[List[AuthenticationType]],
            Field(description="The type of the authentications to retrieve."),
        ] = None,
        platform: Annotated[
            Optional[List[PlatformWithNone]],
            Field(description="The platform of the authentications to retrieve."),
        ] = None,
        sort: Annotated[
            Optional[AuthenticationSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ListAuthenticationsResponse:
        """
        Get a list of authentications.

        Get a list of authentications for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param type: The type of the authentications to retrieve.
        :type type: List[AuthenticationType]
        :param platform: The platform of the authentications to retrieve.
        :type platform: List[PlatformWithNone]
        :param sort: The key by which the list should be sorted.
        :type sort: AuthenticationSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ListAuthenticationsResponse' result object.
        """

        response = await self.get_authentications_with_http_info(
            items_per_page, page, type, platform, sort, order, request_options
        )

        return self.__deserialize(response.raw_data, ListAuthenticationsResponse)

    async def get_destination_with_http_info(
        self,
        destination_id: Annotated[
            StrictStr, Field(description="The destination UUID.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a destination.

        Get the destination of the given destinationID.

        :param destination_id: The destination UUID. (required)
        :type destination_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if destination_id is not None:
            _path_params["destinationID"] = destination_id

        _param = self._transporter.param_serialize(
            path="/1/destinations/{destinationID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_destination(
        self,
        destination_id: Annotated[
            StrictStr, Field(description="The destination UUID.")
        ],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> Destination:
        """
        Get a destination.

        Get the destination of the given destinationID.

        :param destination_id: The destination UUID. (required)
        :type destination_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'Destination' result object.
        """

        response = await self.get_destination_with_http_info(
            destination_id, request_options
        )

        return self.__deserialize(response.raw_data, Destination)

    async def get_destinations_with_http_info(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        type: Annotated[
            Optional[List[DestinationType]],
            Field(description="The type of the destinations to retrive."),
        ] = None,
        authentication_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="The authenticationIDs of the destinations to retrive."),
        ] = None,
        sort: Annotated[
            Optional[DestinationSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a list of destinations.

        Get a list of destinations for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param type: The type of the destinations to retrive.
        :type type: List[DestinationType]
        :param authentication_id: The authenticationIDs of the destinations to retrive.
        :type authentication_id: List[str]
        :param sort: The key by which the list should be sorted.
        :type sort: DestinationSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if items_per_page is not None:
            _query_params.append(("itemsPerPage", items_per_page))

        if page is not None:
            _query_params.append(("page", page))

        if type is not None:
            _query_params.append(("type", type))

        if authentication_id is not None:
            _query_params.append(("authenticationID", authentication_id))

        if sort is not None:
            _query_params.append(("sort", sort.value))

        if order is not None:
            _query_params.append(("order", order.value))

        _param = self._transporter.param_serialize(
            path="/1/destinations",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_destinations(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        type: Annotated[
            Optional[List[DestinationType]],
            Field(description="The type of the destinations to retrive."),
        ] = None,
        authentication_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="The authenticationIDs of the destinations to retrive."),
        ] = None,
        sort: Annotated[
            Optional[DestinationSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ListDestinationsResponse:
        """
        Get a list of destinations.

        Get a list of destinations for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param type: The type of the destinations to retrive.
        :type type: List[DestinationType]
        :param authentication_id: The authenticationIDs of the destinations to retrive.
        :type authentication_id: List[str]
        :param sort: The key by which the list should be sorted.
        :type sort: DestinationSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ListDestinationsResponse' result object.
        """

        response = await self.get_destinations_with_http_info(
            items_per_page, page, type, authentication_id, sort, order, request_options
        )

        return self.__deserialize(response.raw_data, ListDestinationsResponse)

    async def get_docker_source_streams_with_http_info(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Retrieve a stream listing.

        Retrieve a stream listing for a given Singer specification compatible docker type source ID.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if source_id is not None:
            _path_params["sourceID"] = source_id

        _param = self._transporter.param_serialize(
            path="/1/sources/{sourceID}/discover",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_docker_source_streams(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DockerSourceStreams:
        """
        Retrieve a stream listing.

        Retrieve a stream listing for a given Singer specification compatible docker type source ID.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DockerSourceStreams' result object.
        """

        response = await self.get_docker_source_streams_with_http_info(
            source_id, request_options
        )

        return self.__deserialize(response.raw_data, DockerSourceStreams)

    async def get_event_with_http_info(
        self,
        run_id: Annotated[StrictStr, Field(description="The run UUID.")],
        event_id: Annotated[StrictStr, Field(description="The event UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get an event.

        Get a single event for a specific runID.

        :param run_id: The run UUID. (required)
        :type run_id: str
        :param event_id: The event UUID. (required)
        :type event_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if run_id is not None:
            _path_params["runID"] = run_id
        if event_id is not None:
            _path_params["eventID"] = event_id

        _param = self._transporter.param_serialize(
            path="/1/runs/{runID}/events/{eventID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_event(
        self,
        run_id: Annotated[StrictStr, Field(description="The run UUID.")],
        event_id: Annotated[StrictStr, Field(description="The event UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> Event:
        """
        Get an event.

        Get a single event for a specific runID.

        :param run_id: The run UUID. (required)
        :type run_id: str
        :param event_id: The event UUID. (required)
        :type event_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'Event' result object.
        """

        response = await self.get_event_with_http_info(
            run_id, event_id, request_options
        )

        return self.__deserialize(response.raw_data, Event)

    async def get_events_with_http_info(
        self,
        run_id: Annotated[StrictStr, Field(description="The run UUID.")],
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        status: Annotated[
            Optional[List[EventStatus]],
            Field(description="Filter the status of the events."),
        ] = None,
        type: Annotated[
            Optional[List[EventType]],
            Field(description="Filter the type of the events."),
        ] = None,
        sort: Annotated[
            Optional[EventSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(
                description="The start date (in RFC3339 format) of the events fetching window. Defaults to 'now'-3 hours if omitted."
            ),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(
                description="The end date (in RFC3339 format) of the events fetching window. Defaults to 'now' days if omitted."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a list of events.

        Get a list of events associated to the given runID, for the given query parameters.

        :param run_id: The run UUID. (required)
        :type run_id: str
        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param status: Filter the status of the events.
        :type status: List[EventStatus]
        :param type: Filter the type of the events.
        :type type: List[EventType]
        :param sort: The key by which the list should be sorted.
        :type sort: EventSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param start_date: The start date (in RFC3339 format) of the events fetching window. Defaults to 'now'-3 hours if omitted.
        :type start_date: str
        :param end_date: The end date (in RFC3339 format) of the events fetching window. Defaults to 'now' days if omitted.
        :type end_date: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if run_id is not None:
            _path_params["runID"] = run_id

        if items_per_page is not None:
            _query_params.append(("itemsPerPage", items_per_page))

        if page is not None:
            _query_params.append(("page", page))

        if status is not None:
            _query_params.append(("status", status))

        if type is not None:
            _query_params.append(("type", type))

        if sort is not None:
            _query_params.append(("sort", sort.value))

        if order is not None:
            _query_params.append(("order", order.value))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        _param = self._transporter.param_serialize(
            path="/1/runs/{runID}/events",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_events(
        self,
        run_id: Annotated[StrictStr, Field(description="The run UUID.")],
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        status: Annotated[
            Optional[List[EventStatus]],
            Field(description="Filter the status of the events."),
        ] = None,
        type: Annotated[
            Optional[List[EventType]],
            Field(description="Filter the type of the events."),
        ] = None,
        sort: Annotated[
            Optional[EventSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(
                description="The start date (in RFC3339 format) of the events fetching window. Defaults to 'now'-3 hours if omitted."
            ),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(
                description="The end date (in RFC3339 format) of the events fetching window. Defaults to 'now' days if omitted."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ListEventsResponse:
        """
        Get a list of events.

        Get a list of events associated to the given runID, for the given query parameters.

        :param run_id: The run UUID. (required)
        :type run_id: str
        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param status: Filter the status of the events.
        :type status: List[EventStatus]
        :param type: Filter the type of the events.
        :type type: List[EventType]
        :param sort: The key by which the list should be sorted.
        :type sort: EventSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param start_date: The start date (in RFC3339 format) of the events fetching window. Defaults to 'now'-3 hours if omitted.
        :type start_date: str
        :param end_date: The end date (in RFC3339 format) of the events fetching window. Defaults to 'now' days if omitted.
        :type end_date: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ListEventsResponse' result object.
        """

        response = await self.get_events_with_http_info(
            run_id,
            items_per_page,
            page,
            status,
            type,
            sort,
            order,
            start_date,
            end_date,
            request_options,
        )

        return self.__deserialize(response.raw_data, ListEventsResponse)

    async def get_run_with_http_info(
        self,
        run_id: Annotated[StrictStr, Field(description="The run UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a run.

        Get a single run for the given ID.

        :param run_id: The run UUID. (required)
        :type run_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if run_id is not None:
            _path_params["runID"] = run_id

        _param = self._transporter.param_serialize(
            path="/1/runs/{runID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_run(
        self,
        run_id: Annotated[StrictStr, Field(description="The run UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> Run:
        """
        Get a run.

        Get a single run for the given ID.

        :param run_id: The run UUID. (required)
        :type run_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'Run' result object.
        """

        response = await self.get_run_with_http_info(run_id, request_options)

        return self.__deserialize(response.raw_data, Run)

    async def get_runs_with_http_info(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        status: Annotated[
            Optional[List[RunStatus]],
            Field(description="Filter the status of the runs."),
        ] = None,
        task_id: Annotated[
            Optional[StrictStr], Field(description="Filter by taskID.")
        ] = None,
        sort: Annotated[
            Optional[RunSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(
                description="The start date (in RFC3339 format) of the runs fetching window. Defaults to 'now'-7 days if omitted."
            ),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(
                description="The end date (in RFC3339 format) of the runs fetching window. Defaults to 'now' days if omitted."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a list of runs.

        Get a list of runs for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param status: Filter the status of the runs.
        :type status: List[RunStatus]
        :param task_id: Filter by taskID.
        :type task_id: str
        :param sort: The key by which the list should be sorted.
        :type sort: RunSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param start_date: The start date (in RFC3339 format) of the runs fetching window. Defaults to 'now'-7 days if omitted.
        :type start_date: str
        :param end_date: The end date (in RFC3339 format) of the runs fetching window. Defaults to 'now' days if omitted.
        :type end_date: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if items_per_page is not None:
            _query_params.append(("itemsPerPage", items_per_page))

        if page is not None:
            _query_params.append(("page", page))

        if status is not None:
            _query_params.append(("status", status))

        if task_id is not None:
            _query_params.append(("taskID", task_id))

        if sort is not None:
            _query_params.append(("sort", sort.value))

        if order is not None:
            _query_params.append(("order", order.value))

        if start_date is not None:
            _query_params.append(("startDate", start_date))

        if end_date is not None:
            _query_params.append(("endDate", end_date))

        _param = self._transporter.param_serialize(
            path="/1/runs",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_runs(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        status: Annotated[
            Optional[List[RunStatus]],
            Field(description="Filter the status of the runs."),
        ] = None,
        task_id: Annotated[
            Optional[StrictStr], Field(description="Filter by taskID.")
        ] = None,
        sort: Annotated[
            Optional[RunSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(
                description="The start date (in RFC3339 format) of the runs fetching window. Defaults to 'now'-7 days if omitted."
            ),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(
                description="The end date (in RFC3339 format) of the runs fetching window. Defaults to 'now' days if omitted."
            ),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> RunListResponse:
        """
        Get a list of runs.

        Get a list of runs for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param status: Filter the status of the runs.
        :type status: List[RunStatus]
        :param task_id: Filter by taskID.
        :type task_id: str
        :param sort: The key by which the list should be sorted.
        :type sort: RunSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param start_date: The start date (in RFC3339 format) of the runs fetching window. Defaults to 'now'-7 days if omitted.
        :type start_date: str
        :param end_date: The end date (in RFC3339 format) of the runs fetching window. Defaults to 'now' days if omitted.
        :type end_date: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'RunListResponse' result object.
        """

        response = await self.get_runs_with_http_info(
            items_per_page,
            page,
            status,
            task_id,
            sort,
            order,
            start_date,
            end_date,
            request_options,
        )

        return self.__deserialize(response.raw_data, RunListResponse)

    async def get_source_with_http_info(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a source.

        Get the source of the given sourceID.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if source_id is not None:
            _path_params["sourceID"] = source_id

        _param = self._transporter.param_serialize(
            path="/1/sources/{sourceID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_source(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> Source:
        """
        Get a source.

        Get the source of the given sourceID.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'Source' result object.
        """

        response = await self.get_source_with_http_info(source_id, request_options)

        return self.__deserialize(response.raw_data, Source)

    async def get_sources_with_http_info(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        type: Annotated[
            Optional[List[SourceType]],
            Field(description="The type of the sources to retrieve."),
        ] = None,
        authentication_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="The authenticationIDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication. "
            ),
        ] = None,
        sort: Annotated[
            Optional[SourceSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a list of sources.

        Get a list of sources for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param type: The type of the sources to retrieve.
        :type type: List[SourceType]
        :param authentication_id: The authenticationIDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
        :type authentication_id: List[str]
        :param sort: The key by which the list should be sorted.
        :type sort: SourceSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if items_per_page is not None:
            _query_params.append(("itemsPerPage", items_per_page))

        if page is not None:
            _query_params.append(("page", page))

        if type is not None:
            _query_params.append(("type", type))

        if authentication_id is not None:
            _query_params.append(("authenticationID", authentication_id))

        if sort is not None:
            _query_params.append(("sort", sort.value))

        if order is not None:
            _query_params.append(("order", order.value))

        _param = self._transporter.param_serialize(
            path="/1/sources",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_sources(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        type: Annotated[
            Optional[List[SourceType]],
            Field(description="The type of the sources to retrieve."),
        ] = None,
        authentication_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="The authenticationIDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication. "
            ),
        ] = None,
        sort: Annotated[
            Optional[SourceSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ListSourcesResponse:
        """
        Get a list of sources.

        Get a list of sources for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param type: The type of the sources to retrieve.
        :type type: List[SourceType]
        :param authentication_id: The authenticationIDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
        :type authentication_id: List[str]
        :param sort: The key by which the list should be sorted.
        :type sort: SourceSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ListSourcesResponse' result object.
        """

        response = await self.get_sources_with_http_info(
            items_per_page, page, type, authentication_id, sort, order, request_options
        )

        return self.__deserialize(response.raw_data, ListSourcesResponse)

    async def get_task_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a task.

        Get the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if task_id is not None:
            _path_params["taskID"] = task_id

        _param = self._transporter.param_serialize(
            path="/1/tasks/{taskID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_task(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> Task:
        """
        Get a task.

        Get the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'Task' result object.
        """

        response = await self.get_task_with_http_info(task_id, request_options)

        return self.__deserialize(response.raw_data, Task)

    async def get_tasks_with_http_info(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        action: Annotated[
            Optional[List[ActionType]],
            Field(description="The action of the tasks to retrieve."),
        ] = None,
        enabled: Annotated[
            Optional[StrictBool],
            Field(description="Whether the task is enabled or not."),
        ] = None,
        source_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="The sourceIDs of the tasks to retrive."),
        ] = None,
        destination_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="The destinationIDs of the tasks to retrive."),
        ] = None,
        trigger_type: Annotated[
            Optional[List[TriggerType]],
            Field(description="The trigger type of the task."),
        ] = None,
        sort: Annotated[
            Optional[TaskSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Get a list of tasks.

        Get a list of tasks for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param action: The action of the tasks to retrieve.
        :type action: List[ActionType]
        :param enabled: Whether the task is enabled or not.
        :type enabled: bool
        :param source_id: The sourceIDs of the tasks to retrive.
        :type source_id: List[str]
        :param destination_id: The destinationIDs of the tasks to retrive.
        :type destination_id: List[str]
        :param trigger_type: The trigger type of the task.
        :type trigger_type: List[TriggerType]
        :param sort: The key by which the list should be sorted.
        :type sort: TaskSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if items_per_page is not None:
            _query_params.append(("itemsPerPage", items_per_page))

        if page is not None:
            _query_params.append(("page", page))

        if action is not None:
            _query_params.append(("action", action))

        if enabled is not None:
            _query_params.append(("enabled", enabled))

        if source_id is not None:
            _query_params.append(("sourceID", source_id))

        if destination_id is not None:
            _query_params.append(("destinationID", destination_id))

        if trigger_type is not None:
            _query_params.append(("triggerType", trigger_type))

        if sort is not None:
            _query_params.append(("sort", sort.value))

        if order is not None:
            _query_params.append(("order", order.value))

        _param = self._transporter.param_serialize(
            path="/1/tasks",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.GET,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def get_tasks(
        self,
        items_per_page: Annotated[
            Optional[StrictInt],
            Field(description="The number of items per page to return."),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="The page number to fetch, starting at 1."),
        ] = None,
        action: Annotated[
            Optional[List[ActionType]],
            Field(description="The action of the tasks to retrieve."),
        ] = None,
        enabled: Annotated[
            Optional[StrictBool],
            Field(description="Whether the task is enabled or not."),
        ] = None,
        source_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="The sourceIDs of the tasks to retrive."),
        ] = None,
        destination_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="The destinationIDs of the tasks to retrive."),
        ] = None,
        trigger_type: Annotated[
            Optional[List[TriggerType]],
            Field(description="The trigger type of the task."),
        ] = None,
        sort: Annotated[
            Optional[TaskSortKeys],
            Field(description="The key by which the list should be sorted."),
        ] = None,
        order: Annotated[
            Optional[OrderKeys], Field(description="The order of the returned list.")
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ListTasksResponse:
        """
        Get a list of tasks.

        Get a list of tasks for the given query parameters, with pagination details.

        :param items_per_page: The number of items per page to return.
        :type items_per_page: int
        :param page: The page number to fetch, starting at 1.
        :type page: int
        :param action: The action of the tasks to retrieve.
        :type action: List[ActionType]
        :param enabled: Whether the task is enabled or not.
        :type enabled: bool
        :param source_id: The sourceIDs of the tasks to retrive.
        :type source_id: List[str]
        :param destination_id: The destinationIDs of the tasks to retrive.
        :type destination_id: List[str]
        :param trigger_type: The trigger type of the task.
        :type trigger_type: List[TriggerType]
        :param sort: The key by which the list should be sorted.
        :type sort: TaskSortKeys
        :param order: The order of the returned list.
        :type order: OrderKeys
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'ListTasksResponse' result object.
        """

        response = await self.get_tasks_with_http_info(
            items_per_page,
            page,
            action,
            enabled,
            source_id,
            destination_id,
            trigger_type,
            sort,
            order,
            request_options,
        )

        return self.__deserialize(response.raw_data, ListTasksResponse)

    async def post_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if path is not None:
            _path_params["path"] = path

        if parameters is not None:
            _query_params.append(("parameters", parameters))

        if body is not None:
            _body_params = body

        _param = self._transporter.param_serialize(
            path="/1{path}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def post(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """

        response = await self.post_with_http_info(
            path, parameters, body, request_options
        )

        return self.__deserialize(response.raw_data, object)

    async def put_with_http_info(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if path is not None:
            _path_params["path"] = path

        if parameters is not None:
            _query_params.append(("parameters", parameters))

        if body is not None:
            _body_params = body

        _param = self._transporter.param_serialize(
            path="/1{path}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PUT,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def put(
        self,
        path: Annotated[
            StrictStr,
            Field(
                description='Path of the endpoint, anything after "/1" must be specified.'
            ),
        ],
        parameters: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Query parameters to apply to the current query."),
        ] = None,
        body: Annotated[
            Optional[Dict[str, Any]],
            Field(description="Parameters to send with the custom request."),
        ] = None,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> object:
        """
        Send requests to the Algolia REST API.

        This method allow you to send requests to the Algolia REST API.

        :param path: Path of the endpoint, anything after \"/1\" must be specified. (required)
        :type path: str
        :param parameters: Query parameters to apply to the current query.
        :type parameters: Dict[str, object]
        :param body: Parameters to send with the custom request.
        :type body: object
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'object' result object.
        """

        response = await self.put_with_http_info(
            path, parameters, body, request_options
        )

        return self.__deserialize(response.raw_data, object)

    async def run_task_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Run a task.

        Run the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if task_id is not None:
            _path_params["taskID"] = task_id

        _param = self._transporter.param_serialize(
            path="/1/tasks/{taskID}/run",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def run_task(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> RunResponse:
        """
        Run a task.

        Run the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'RunResponse' result object.
        """

        response = await self.run_task_with_http_info(task_id, request_options)

        return self.__deserialize(response.raw_data, RunResponse)

    async def search_authentications_with_http_info(
        self,
        authentication_search: AuthenticationSearch,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search among authentications.

        Search among authentications with a defined set of parameters.

        :param authentication_search: (required)
        :type authentication_search: AuthenticationSearch
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if authentication_search is not None:
            _body_params = authentication_search

        _param = self._transporter.param_serialize(
            path="/1/authentications/search",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_authentications(
        self,
        authentication_search: AuthenticationSearch,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> List[Authentication]:
        """
        Search among authentications.

        Search among authentications with a defined set of parameters.

        :param authentication_search: (required)
        :type authentication_search: AuthenticationSearch
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'List[Authentication]' result object.
        """

        response = await self.search_authentications_with_http_info(
            authentication_search, request_options
        )

        return self.__deserialize(response.raw_data, List[Authentication])

    async def search_destinations_with_http_info(
        self,
        destination_search: DestinationSearch,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search among destinations.

        Search among destinations with a defined set of parameters.

        :param destination_search: (required)
        :type destination_search: DestinationSearch
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if destination_search is not None:
            _body_params = destination_search

        _param = self._transporter.param_serialize(
            path="/1/destinations/search",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_destinations(
        self,
        destination_search: DestinationSearch,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> List[Destination]:
        """
        Search among destinations.

        Search among destinations with a defined set of parameters.

        :param destination_search: (required)
        :type destination_search: DestinationSearch
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'List[Destination]' result object.
        """

        response = await self.search_destinations_with_http_info(
            destination_search, request_options
        )

        return self.__deserialize(response.raw_data, List[Destination])

    async def search_sources_with_http_info(
        self,
        source_search: SourceSearch,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search among sources.

        Search among sources with a defined set of parameters.

        :param source_search: (required)
        :type source_search: SourceSearch
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if source_search is not None:
            _body_params = source_search

        _param = self._transporter.param_serialize(
            path="/1/sources/search",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_sources(
        self,
        source_search: SourceSearch,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> List[Source]:
        """
        Search among sources.

        Search among sources with a defined set of parameters.

        :param source_search: (required)
        :type source_search: SourceSearch
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'List[Source]' result object.
        """

        response = await self.search_sources_with_http_info(
            source_search, request_options
        )

        return self.__deserialize(response.raw_data, List[Source])

    async def search_tasks_with_http_info(
        self,
        task_search: TaskSearch,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Search among tasks.

        Search among tasks with a defined set of parameters.

        :param task_search: (required)
        :type task_search: TaskSearch
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if task_search is not None:
            _body_params = task_search

        _param = self._transporter.param_serialize(
            path="/1/tasks/search",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def search_tasks(
        self,
        task_search: TaskSearch,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> List[Task]:
        """
        Search among tasks.

        Search among tasks with a defined set of parameters.

        :param task_search: (required)
        :type task_search: TaskSearch
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'List[Task]' result object.
        """

        response = await self.search_tasks_with_http_info(task_search, request_options)

        return self.__deserialize(response.raw_data, List[Task])

    async def trigger_docker_source_discover_with_http_info(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Trigger a stream listing request.

        Trigger a stream listing request for a Singer specification compatible docker type source.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if source_id is not None:
            _path_params["sourceID"] = source_id

        _param = self._transporter.param_serialize(
            path="/1/sources/{sourceID}/discover",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.POST,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def trigger_docker_source_discover(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DockerSourceDiscover:
        """
        Trigger a stream listing request.

        Trigger a stream listing request for a Singer specification compatible docker type source.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DockerSourceDiscover' result object.
        """

        response = await self.trigger_docker_source_discover_with_http_info(
            source_id, request_options
        )

        return self.__deserialize(response.raw_data, DockerSourceDiscover)

    async def update_authentication_with_http_info(
        self,
        authentication_id: Annotated[
            StrictStr, Field(description="The authentication UUID.")
        ],
        authentication_update: AuthenticationUpdate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Update a authentication.

        Update the authentication of the given authenticationID.

        :param authentication_id: The authentication UUID. (required)
        :type authentication_id: str
        :param authentication_update: (required)
        :type authentication_update: AuthenticationUpdate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if authentication_id is not None:
            _path_params["authenticationID"] = authentication_id

        if authentication_update is not None:
            _body_params = authentication_update

        _param = self._transporter.param_serialize(
            path="/1/authentications/{authenticationID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PATCH,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def update_authentication(
        self,
        authentication_id: Annotated[
            StrictStr, Field(description="The authentication UUID.")
        ],
        authentication_update: AuthenticationUpdate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> AuthenticationUpdateResponse:
        """
        Update a authentication.

        Update the authentication of the given authenticationID.

        :param authentication_id: The authentication UUID. (required)
        :type authentication_id: str
        :param authentication_update: (required)
        :type authentication_update: AuthenticationUpdate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'AuthenticationUpdateResponse' result object.
        """

        response = await self.update_authentication_with_http_info(
            authentication_id, authentication_update, request_options
        )

        return self.__deserialize(response.raw_data, AuthenticationUpdateResponse)

    async def update_destination_with_http_info(
        self,
        destination_id: Annotated[
            StrictStr, Field(description="The destination UUID.")
        ],
        destination_update: DestinationUpdate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Update a destination.

        Update the destination of the given destinationID.

        :param destination_id: The destination UUID. (required)
        :type destination_id: str
        :param destination_update: (required)
        :type destination_update: DestinationUpdate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if destination_id is not None:
            _path_params["destinationID"] = destination_id

        if destination_update is not None:
            _body_params = destination_update

        _param = self._transporter.param_serialize(
            path="/1/destinations/{destinationID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PATCH,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def update_destination(
        self,
        destination_id: Annotated[
            StrictStr, Field(description="The destination UUID.")
        ],
        destination_update: DestinationUpdate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> DestinationUpdateResponse:
        """
        Update a destination.

        Update the destination of the given destinationID.

        :param destination_id: The destination UUID. (required)
        :type destination_id: str
        :param destination_update: (required)
        :type destination_update: DestinationUpdate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'DestinationUpdateResponse' result object.
        """

        response = await self.update_destination_with_http_info(
            destination_id, destination_update, request_options
        )

        return self.__deserialize(response.raw_data, DestinationUpdateResponse)

    async def update_source_with_http_info(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        source_update: SourceUpdate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Update a source.

        Update the source of the given sourceID.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param source_update: (required)
        :type source_update: SourceUpdate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if source_id is not None:
            _path_params["sourceID"] = source_id

        if source_update is not None:
            _body_params = source_update

        _param = self._transporter.param_serialize(
            path="/1/sources/{sourceID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PATCH,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def update_source(
        self,
        source_id: Annotated[StrictStr, Field(description="The source UUID.")],
        source_update: SourceUpdate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> SourceUpdateResponse:
        """
        Update a source.

        Update the source of the given sourceID.

        :param source_id: The source UUID. (required)
        :type source_id: str
        :param source_update: (required)
        :type source_update: SourceUpdate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'SourceUpdateResponse' result object.
        """

        response = await self.update_source_with_http_info(
            source_id, source_update, request_options
        )

        return self.__deserialize(response.raw_data, SourceUpdateResponse)

    async def update_task_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        task_update: TaskUpdate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> ApiResponse[str]:
        """
        Update a task.

        Update the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param task_update: (required)
        :type task_update: TaskUpdate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _body_params: Optional[bytes] = None

        if task_id is not None:
            _path_params["taskID"] = task_id

        if task_update is not None:
            _body_params = task_update

        _param = self._transporter.param_serialize(
            path="/1/tasks/{taskID}",
            path_params=_path_params,
            query_params=_query_params,
            body=_body_params,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.PATCH,
            path=_param[0],
            data=_param[1],
            request_options=_param[2],
            use_read_transporter=True,
        )

        response.data = response.raw_data

        return response

    async def update_task(
        self,
        task_id: Annotated[StrictStr, Field(description="The task UUID.")],
        task_update: TaskUpdate,
        request_options: Optional[Union[dict, RequestOptions]] = None,
    ) -> TaskUpdateResponse:
        """
        Update a task.

        Update the task of the given taskID.

        :param task_id: The task UUID. (required)
        :type task_id: str
        :param task_update: (required)
        :type task_update: TaskUpdate
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the deserialized response in a 'TaskUpdateResponse' result object.
        """

        response = await self.update_task_with_http_info(
            task_id, task_update, request_options
        )

        return self.__deserialize(response.raw_data, TaskUpdateResponse)
